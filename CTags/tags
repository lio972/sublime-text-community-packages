!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ACCESS_COUNT	.\c.c	/^	ACCESS_COUNT$/;"	e	enum:eVisibilityType	file:
ACCESS_DEFAULT	.\c.c	/^	ACCESS_DEFAULT,      \/* Java-specific *\/$/;"	e	enum:eVisibilityType	file:
ACCESS_LOCAL	.\c.c	/^	ACCESS_LOCAL,$/;"	e	enum:eVisibilityType	file:
ACCESS_PRIVATE	.\c.c	/^	ACCESS_PRIVATE,$/;"	e	enum:eVisibilityType	file:
ACCESS_PROTECTED	.\c.c	/^	ACCESS_PROTECTED,$/;"	e	enum:eVisibilityType	file:
ACCESS_PUBLIC	.\c.c	/^	ACCESS_PUBLIC,$/;"	e	enum:eVisibilityType	file:
ACCESS_UNDEFINED	.\c.c	/^	ACCESS_UNDEFINED,$/;"	e	enum:eVisibilityType	file:
ALNUM	.\php.c	59;"	d	file:
ALNUM	.\php.c	62;"	d	file:
ALPHA	.\php.c	58;"	d	file:
ALPHA	.\php.c	61;"	d	file:
ANCHOR_BUF_SIZE	.\main.c	47;"	d	file:
ANCHOR_SIZE	.\main.c	48;"	d	file:
ARG_ARGV	.\args.h	/^typedef enum { ARG_NONE, ARG_STRING, ARG_ARGV, ARG_FILE } argType;$/;"	e	enum:__anon1
ARG_FILE	.\args.h	/^typedef enum { ARG_NONE, ARG_STRING, ARG_ARGV, ARG_FILE } argType;$/;"	e	enum:__anon1
ARG_NONE	.\args.h	/^typedef enum { ARG_NONE, ARG_STRING, ARG_ARGV, ARG_FILE } argType;$/;"	e	enum:__anon1
ARG_STRING	.\args.h	/^typedef enum { ARG_NONE, ARG_STRING, ARG_ARGV, ARG_FILE } argType;$/;"	e	enum:__anon1
AS	.\mk_qdos.mak	/^AS  = $(P)as68$/;"	m
ASFLAGS	.\mk_qdos.mak	/^ASFLAGS  = -V$/;"	m
ASM	.\mk_qdos.mak	/^ASM = $(P)qmac$/;"	m
ASMFLAGS	.\mk_qdos.mak	/^ASMFLAGS = -nolist$/;"	m
AT_STRINGS_BEG	.\regex.c	3078;"	d	file:
AT_STRINGS_END	.\regex.c	3079;"	d	file:
AT_WORD_BOUNDARY	.\regex.c	3093;"	d	file:
AUTHOR	.\ctags.html	/^<a name="AUTHOR"><\/a>$/;"	a
AUTHOR_EMAIL	.\ctags.h	24;"	d
AUTHOR_NAME	.\ctags.h	23;"	d
Ancestors	.\fortran.c	/^} Ancestors = { 0, 0, NULL };$/;"	v	typeref:struct:__anon20	file:
AnonymousID	.\c.c	/^static int AnonymousID = 0;$/;"	v	file:
Arguments	.\args.h	/^} Arguments;$/;"	t	typeref:struct:sArgs
AsmKeywords	.\asm.c	/^static const asmKeyword AsmKeywords [] = {$/;"	v	file:
AsmKeywords	.\whatever\asm.c	/^static const asmKeyword AsmKeywords [] = {$/;"	v	file:
AsmKind	.\asm.c	/^} AsmKind;$/;"	t	typeref:enum:__anon3	file:
AsmKind	.\whatever\asm.c	/^} AsmKind;$/;"	t	typeref:enum:__anon76	file:
AsmKinds	.\asm.c	/^static kindOption AsmKinds [] = {$/;"	v	file:
AsmKinds	.\whatever\asm.c	/^static kindOption AsmKinds [] = {$/;"	v	file:
AsmParser	.\asm.c	/^extern parserDefinition* AsmParser (void)$/;"	f
AsmParser	.\whatever\asm.c	/^extern parserDefinition* AsmParser (void)$/;"	f
AspKinds	.\asp.c	/^static kindOption AspKinds [] = {$/;"	v	file:
AspParser	.\asp.c	/^extern parserDefinition* AspParser (void)$/;"	f
Assert	.\debug.h	32;"	d
Assert	.\debug.h	36;"	d
AwkKinds	.\awk.c	/^static kindOption AwkKinds [] = {$/;"	v	file:
AwkParser	.\awk.c	/^extern parserDefinition* AwkParser ()$/;"	f
BACKSLASH	.\read.h	/^	BACKSLASH     = '\\\\',$/;"	e	enum:eCharacters
BACK_REFERENCE_COUNT	.\lregex.c	45;"	d	file:
BCC	.\mk_bc5.mak	/^BCC = bcc32$/;"	m
BCCLOC	.\mk_bc3.mak	/^BCCLOC  = c:\\borlandc$/;"	m
BUF_PUSH	.\regex.c	887;"	d	file:
BUF_PUSH_2	.\regex.c	895;"	d	file:
BUF_PUSH_3	.\regex.c	904;"	d	file:
BUGS	.\ctags.html	/^<a name="BUGS"><\/a>$/;"	a
BUILD_MPW_TOOL	.\e_mac.h	18;"	d
BYTEWIDTH	.\regex.c	229;"	d	file:
BasicKind	.\basic.c	/^} BasicKind;$/;"	t	typeref:enum:__anon8	file:
BasicKinds	.\basic.c	/^static kindOption BasicKinds[] = {$/;"	v	file:
BasicParser	.\basic.c	/^parserDefinition *BasicParser (void)$/;"	f
BetaKinds	.\beta.c	/^static kindOption BetaKinds [] = {$/;"	v	file:
BetaParser	.\beta.c	/^extern parserDefinition* BetaParser (void)$/;"	f
BooleanOptions	.\options.c	/^static booleanOption BooleanOptions [] = {$/;"	v	file:
BraceFormat	.\get.c	/^static boolean BraceFormat = FALSE;$/;"	v	file:
BuiltInParsers	.\parse.c	/^static parserDefinitionFunc* BuiltInParsers[] = { PARSER_LIST };$/;"	v	file:
CASE_INSENSITIVE_FILENAMES	.\e_djgpp.h	14;"	d
CASE_INSENSITIVE_FILENAMES	.\e_msoft.h	19;"	d
CASE_INSENSITIVE_FILENAMES	.\e_os2.h	15;"	d
CASE_INSENSITIVE_FILENAMES	.\e_vms.h	14;"	d
CAVEATS	.\ctags.html	/^<a name="CAVEATS"><\/a>$/;"	a
CC	.\mk_bc3.mak	/^CC	= $(BCCLOC)\\bin\\bcc$/;"	m
CC	.\mk_manx.mak	/^CC = cc$/;"	m
CC	.\mk_ming.mak	/^CC = gcc$/;"	m
CC	.\mk_mpw.mak	/^CC			= mwcppc$/;"	m
CC	.\mk_qdos.mak	/^CC  = $(P)cc$/;"	m
CCFLAGS	.\mk_qdos.mak	/^CCFLAGS  = -tmp$(T) -v -Y$(P) -I$(P)include_ -O$/;"	m
CFLAGS	.\mk_bc3.mak	/^CFLAGS	= -DMSDOS -ml -d -w-ccc -w-par -w-pia -w-rch -w-sus $(INC)$/;"	m
CFLAGS	.\mk_bc5.mak	/^CFLAGS = -d -DSTRICT -lTpe -lap$/;"	m
CFLAGS	.\mk_djg.mak	/^CFLAGS	= -O2 -Wall -DMSDOS$/;"	m
CFLAGS	.\mk_manx.mak	/^CFLAGS = $(OPTIONS) -wapruq -ps -qf -DAMIGA -Dconst=$/;"	m
CFLAGS	.\mk_ming.mak	/^CFLAGS = -Wall$/;"	m
CFLAGS	.\mk_sas.mak	/^CFLAGS= def AMIGA opt parm r sint$/;"	m
CHAR_CLASS_MAX_LENGTH	.\regex.c	1033;"	d	file:
CHAR_SET_SIZE	.\regex.c	89;"	d	file:
CHAR_SYMBOL	.\read.h	/^	CHAR_SYMBOL   = ('C' + 0x80)$/;"	e	enum:eCharacters
CK_CLASS	.\c.c	/^	CK_CLASS, CK_DEFINE, CK_ENUMERATOR, CK_FUNCTION,$/;"	e	enum:__anon12	file:
CK_DEFINE	.\c.c	/^	CK_CLASS, CK_DEFINE, CK_ENUMERATOR, CK_FUNCTION,$/;"	e	enum:__anon12	file:
CK_ENUMERATION	.\c.c	/^	CK_ENUMERATION, CK_LOCAL, CK_MEMBER, CK_NAMESPACE, CK_PROTOTYPE,$/;"	e	enum:__anon12	file:
CK_ENUMERATOR	.\c.c	/^	CK_CLASS, CK_DEFINE, CK_ENUMERATOR, CK_FUNCTION,$/;"	e	enum:__anon12	file:
CK_EXTERN_VARIABLE	.\c.c	/^	CK_EXTERN_VARIABLE$/;"	e	enum:__anon12	file:
CK_FUNCTION	.\c.c	/^	CK_CLASS, CK_DEFINE, CK_ENUMERATOR, CK_FUNCTION,$/;"	e	enum:__anon12	file:
CK_LOCAL	.\c.c	/^	CK_ENUMERATION, CK_LOCAL, CK_MEMBER, CK_NAMESPACE, CK_PROTOTYPE,$/;"	e	enum:__anon12	file:
CK_MEMBER	.\c.c	/^	CK_ENUMERATION, CK_LOCAL, CK_MEMBER, CK_NAMESPACE, CK_PROTOTYPE,$/;"	e	enum:__anon12	file:
CK_NAMESPACE	.\c.c	/^	CK_ENUMERATION, CK_LOCAL, CK_MEMBER, CK_NAMESPACE, CK_PROTOTYPE,$/;"	e	enum:__anon12	file:
CK_PROTOTYPE	.\c.c	/^	CK_ENUMERATION, CK_LOCAL, CK_MEMBER, CK_NAMESPACE, CK_PROTOTYPE,$/;"	e	enum:__anon12	file:
CK_STRUCT	.\c.c	/^	CK_STRUCT, CK_TYPEDEF, CK_UNION, CK_VARIABLE,$/;"	e	enum:__anon12	file:
CK_TYPEDEF	.\c.c	/^	CK_STRUCT, CK_TYPEDEF, CK_UNION, CK_VARIABLE,$/;"	e	enum:__anon12	file:
CK_UNDEFINED	.\c.c	/^	CK_UNDEFINED = -1,$/;"	e	enum:__anon12	file:
CK_UNION	.\c.c	/^	CK_STRUCT, CK_TYPEDEF, CK_UNION, CK_VARIABLE,$/;"	e	enum:__anon12	file:
CK_VARIABLE	.\c.c	/^	CK_STRUCT, CK_TYPEDEF, CK_UNION, CK_VARIABLE,$/;"	e	enum:__anon12	file:
CKinds	.\c.c	/^static kindOption CKinds [] = {$/;"	v	file:
CLOCKS_PER_SEC	.\main.c	404;"	d	file:
CLOCKS_PER_SEC	.\main.c	408;"	d	file:
CLOCK_AVAILABLE	.\main.c	402;"	d	file:
CLOCK_AVAILABLE	.\main.c	407;"	d	file:
COMMENT_C	.\get.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	e	enum:__anon23	file:
COMMENT_CPLUS	.\get.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	e	enum:__anon23	file:
COMMENT_NONE	.\get.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	e	enum:__anon23	file:
COMPILE_STACK_EMPTY	.\regex.c	1003;"	d	file:
COMPILE_STACK_FULL	.\regex.c	1004;"	d	file:
COMPILE_STACK_TOP	.\regex.c	1007;"	d	file:
CONST_FILE	.\read.h	15;"	d
CONST_FILE	.\read.h	17;"	d
CONST_OPTION	.\options.h	15;"	d
CONST_OPTION	.\options.h	17;"	d
COptions	.\mk_mpw.mak	/^COptions	= -nodefaults -i : -i- -i {CIncludes} -opt full$/;"	m
CParser	.\c.c	/^extern parserDefinition* CParser (void)$/;"	f
CREDITS	.\ctags.html	/^<a name="CREDITS"><\/a>$/;"	a
CRETURN	.\read.h	/^	CRETURN       = '\\r',$/;"	e	enum:eCharacters
CSK_CLASS	.\c.c	/^	CSK_CLASS, CSK_DEFINE, CSK_ENUMERATOR, CSK_EVENT, CSK_FIELD,$/;"	e	enum:__anon13	file:
CSK_DEFINE	.\c.c	/^	CSK_CLASS, CSK_DEFINE, CSK_ENUMERATOR, CSK_EVENT, CSK_FIELD,$/;"	e	enum:__anon13	file:
CSK_ENUMERATION	.\c.c	/^	CSK_ENUMERATION, CSK_INTERFACE, CSK_LOCAL, CSK_METHOD,$/;"	e	enum:__anon13	file:
CSK_ENUMERATOR	.\c.c	/^	CSK_CLASS, CSK_DEFINE, CSK_ENUMERATOR, CSK_EVENT, CSK_FIELD,$/;"	e	enum:__anon13	file:
CSK_EVENT	.\c.c	/^	CSK_CLASS, CSK_DEFINE, CSK_ENUMERATOR, CSK_EVENT, CSK_FIELD,$/;"	e	enum:__anon13	file:
CSK_FIELD	.\c.c	/^	CSK_CLASS, CSK_DEFINE, CSK_ENUMERATOR, CSK_EVENT, CSK_FIELD,$/;"	e	enum:__anon13	file:
CSK_INTERFACE	.\c.c	/^	CSK_ENUMERATION, CSK_INTERFACE, CSK_LOCAL, CSK_METHOD,$/;"	e	enum:__anon13	file:
CSK_LOCAL	.\c.c	/^	CSK_ENUMERATION, CSK_INTERFACE, CSK_LOCAL, CSK_METHOD,$/;"	e	enum:__anon13	file:
CSK_METHOD	.\c.c	/^	CSK_ENUMERATION, CSK_INTERFACE, CSK_LOCAL, CSK_METHOD,$/;"	e	enum:__anon13	file:
CSK_NAMESPACE	.\c.c	/^	CSK_NAMESPACE, CSK_PROPERTY, CSK_STRUCT, CSK_TYPEDEF$/;"	e	enum:__anon13	file:
CSK_PROPERTY	.\c.c	/^	CSK_NAMESPACE, CSK_PROPERTY, CSK_STRUCT, CSK_TYPEDEF$/;"	e	enum:__anon13	file:
CSK_STRUCT	.\c.c	/^	CSK_NAMESPACE, CSK_PROPERTY, CSK_STRUCT, CSK_TYPEDEF$/;"	e	enum:__anon13	file:
CSK_TYPEDEF	.\c.c	/^	CSK_NAMESPACE, CSK_PROPERTY, CSK_STRUCT, CSK_TYPEDEF$/;"	e	enum:__anon13	file:
CSK_UNDEFINED	.\c.c	/^	CSK_UNDEFINED = -1,$/;"	e	enum:__anon13	file:
CTAGS_ENVIRONMENT	.\options.c	35;"	d	file:
CTAGS_FILE	.\options.c	38;"	d	file:
CTagsCache	.\ctags.py	/^class CTagsCache(object):$/;"	c
CTagsTest	.\ctags.py	/^class CTagsTest(unittest.TestCase):$/;"	c
CheckFile	.\options.c	/^static const char *CheckFile;$/;"	v	file:
ClassNames	.\jscript.c	/^static stringList *ClassNames;$/;"	v	file:
CobolParser	.\cobol.c	/^extern parserDefinition* CobolParser ()$/;"	f
CollectingSignature	.\c.c	/^static boolean CollectingSignature;$/;"	v	file:
Column	.\fortran.c	/^static unsigned int Column;$/;"	v	file:
Comment	.\get.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	t	typeref:enum:__anon23	file:
CommentLevel	.\sml.c	/^static unsigned int CommentLevel = 0;$/;"	v	file:
Cpp	.\get.c	/^static cppState Cpp = {$/;"	v	file:
CppParser	.\c.c	/^extern parserDefinition* CppParser (void)$/;"	f
CsharpKinds	.\c.c	/^static kindOption CsharpKinds [] = {$/;"	v	file:
CsharpParser	.\c.c	/^extern parserDefinition* CsharpParser (void)$/;"	f
CurrentDirectory	.\routines.c	/^char *CurrentDirectory;$/;"	v
CurrentStatement	.\c.c	/^static statementInfo *CurrentStatement = NULL;$/;"	v	file:
DEBUG_CPP	.\debug.h	/^	DEBUG_CPP    = 0x10,  \/* echo characters out of pre-processor *\/$/;"	e	enum:eDebugLevels
DEBUG_OPTION	.\debug.h	/^	DEBUG_OPTION = 0x08,  \/* echo option parsing *\/$/;"	e	enum:eDebugLevels
DEBUG_PARSE	.\debug.h	/^	DEBUG_PARSE  = 0x02,  \/* echo parsing results *\/$/;"	e	enum:eDebugLevels
DEBUG_POP	.\regex.c	2336;"	d	file:
DEBUG_POP	.\regex.c	2339;"	d	file:
DEBUG_PRINT1	.\regex.c	471;"	d	file:
DEBUG_PRINT1	.\regex.c	785;"	d	file:
DEBUG_PRINT2	.\regex.c	472;"	d	file:
DEBUG_PRINT2	.\regex.c	786;"	d	file:
DEBUG_PRINT3	.\regex.c	473;"	d	file:
DEBUG_PRINT3	.\regex.c	787;"	d	file:
DEBUG_PRINT4	.\regex.c	474;"	d	file:
DEBUG_PRINT4	.\regex.c	788;"	d	file:
DEBUG_PRINT_COMPILED_PATTERN	.\regex.c	475;"	d	file:
DEBUG_PRINT_COMPILED_PATTERN	.\regex.c	789;"	d	file:
DEBUG_PRINT_DOUBLE_STRING	.\regex.c	477;"	d	file:
DEBUG_PRINT_DOUBLE_STRING	.\regex.c	790;"	d	file:
DEBUG_PUSH	.\regex.c	2335;"	d	file:
DEBUG_PUSH	.\regex.c	2338;"	d	file:
DEBUG_RAW	.\debug.h	/^	DEBUG_RAW    = 0x20   \/* echo raw (filtered) characters *\/$/;"	e	enum:eDebugLevels
DEBUG_READ	.\debug.h	/^	DEBUG_READ   = 0x01,  \/* echo raw (filtered) characters *\/$/;"	e	enum:eDebugLevels
DEBUG_STATEMENT	.\regex.c	470;"	d	file:
DEBUG_STATEMENT	.\regex.c	784;"	d	file:
DEBUG_STATUS	.\debug.h	/^	DEBUG_STATUS = 0x04,  \/* echo file status information *\/$/;"	e	enum:eDebugLevels
DECL_BASE	.\c.c	/^	DECL_BASE,           \/* base type (default) *\/$/;"	e	enum:eDeclaration	file:
DECL_CLASS	.\c.c	/^	DECL_CLASS,$/;"	e	enum:eDeclaration	file:
DECL_COUNT	.\c.c	/^	DECL_COUNT$/;"	e	enum:eDeclaration	file:
DECL_ENUM	.\c.c	/^	DECL_ENUM,$/;"	e	enum:eDeclaration	file:
DECL_EVENT	.\c.c	/^	DECL_EVENT,$/;"	e	enum:eDeclaration	file:
DECL_FUNCTION	.\c.c	/^	DECL_FUNCTION,$/;"	e	enum:eDeclaration	file:
DECL_IGNORE	.\c.c	/^	DECL_IGNORE,         \/* non-taggable "declaration" *\/$/;"	e	enum:eDeclaration	file:
DECL_INTERFACE	.\c.c	/^	DECL_INTERFACE,$/;"	e	enum:eDeclaration	file:
DECL_NAMESPACE	.\c.c	/^	DECL_NAMESPACE,$/;"	e	enum:eDeclaration	file:
DECL_NOMANGLE	.\c.c	/^	DECL_NOMANGLE,       \/* C++ name demangling block *\/$/;"	e	enum:eDeclaration	file:
DECL_NONE	.\c.c	/^	DECL_NONE,$/;"	e	enum:eDeclaration	file:
DECL_PACKAGE	.\c.c	/^	DECL_PACKAGE,$/;"	e	enum:eDeclaration	file:
DECL_PROGRAM	.\c.c	/^	DECL_PROGRAM,        \/* Vera program *\/$/;"	e	enum:eDeclaration	file:
DECL_STRUCT	.\c.c	/^	DECL_STRUCT,$/;"	e	enum:eDeclaration	file:
DECL_TASK	.\c.c	/^	DECL_TASK,           \/* Vera task *\/$/;"	e	enum:eDeclaration	file:
DECL_UNION	.\c.c	/^	DECL_UNION,$/;"	e	enum:eDeclaration	file:
DEFAULT_FILE_FORMAT	.\e_mac.h	21;"	d
DEFAULT_FILE_FORMAT	.\e_riscos.h	21;"	d
DEFAULT_FILE_FORMAT	.\options.c	53;"	d	file:
DEFINES	.\mk_bc5.mak	/^DEFINES = -DWIN32 $(REGEX_DEFINE)$/;"	m
DEFINES	.\mk_ming.mak	/^DEFINES = -DWIN32$/;"	m
DEFINES	.\mk_mvc.mak	/^DEFINES = -DWIN32 $(REGEX_DEFINE)$/;"	m
DEFINES	.\mk_os2.mak	/^DEFINES=-DOS2$/;"	m
DESCRIPTION	.\ctags.html	/^<a name="DESCRIPTION"><\/a>$/;"	a
DIR	.\e_mac.h	/^} DIR;$/;"	t	typeref:struct:__anon19
DOUBLE_FAIL_STACK	.\regex.c	2299;"	d	file:
DOUBLE_QUOTE	.\read.h	/^	DOUBLE_QUOTE  = '"',$/;"	e	enum:eCharacters
DRCTV_DEFINE	.\get.c	/^	DRCTV_DEFINE,  \/* "#define" encountered *\/$/;"	e	enum:eState	file:
DRCTV_HASH	.\get.c	/^	DRCTV_HASH,    \/* initial '#' read; determine directive *\/$/;"	e	enum:eState	file:
DRCTV_IF	.\get.c	/^	DRCTV_IF,      \/* "#if" or "#ifdef" encountered *\/$/;"	e	enum:eState	file:
DRCTV_NONE	.\get.c	/^	DRCTV_NONE,    \/* no known directive - ignore to end of line *\/$/;"	e	enum:eState	file:
DRCTV_PRAGMA	.\get.c	/^	DRCTV_PRAGMA,  \/* #pragma encountered *\/$/;"	e	enum:eState	file:
DRCTV_UNDEF	.\get.c	/^	DRCTV_UNDEF    \/* "#undef" encountered *\/$/;"	e	enum:eState	file:
Debug	.\eiffel.c	/^static int Debug;$/;"	v	file:
DebugStatement	.\debug.h	30;"	d
DebugStatement	.\debug.h	34;"	d
EKIND_CLASS	.\eiffel.c	/^	EKIND_CLASS, EKIND_FEATURE, EKIND_LOCAL, EKIND_QUALIFIED_TAGS$/;"	e	enum:__anon16	file:
EKIND_FEATURE	.\eiffel.c	/^	EKIND_CLASS, EKIND_FEATURE, EKIND_LOCAL, EKIND_QUALIFIED_TAGS$/;"	e	enum:__anon16	file:
EKIND_LOCAL	.\eiffel.c	/^	EKIND_CLASS, EKIND_FEATURE, EKIND_LOCAL, EKIND_QUALIFIED_TAGS$/;"	e	enum:__anon16	file:
EKIND_QUALIFIED_TAGS	.\eiffel.c	/^	EKIND_CLASS, EKIND_FEATURE, EKIND_LOCAL, EKIND_QUALIFIED_TAGS$/;"	e	enum:__anon16	file:
ENVIRONMENT VARIABLES	.\ctags.html	/^<a name="ENVIRONMENT VARIABLES"><\/a>$/;"	a
ENVIRONMENT_HEADERS	.\source.mak	/^ENVIRONMENT_HEADERS = \\$/;"	m
ENVIRONMENT_SOURCES	.\source.mak	/^ENVIRONMENT_SOURCES = \\$/;"	m
ETAGS	.\options.c	42;"	d	file:
ETAGS_ENVIRONMENT	.\options.c	36;"	d	file:
ETAGS_FILE	.\options.c	39;"	d	file:
EVER_MATCHED_SOMETHING	.\regex.c	3028;"	d	file:
EXEC	.\mk_qdos.mak	/^EXEC = ctags$/;"	m
EXIT_ERR	.\argproc.c	36;"	d	file:
EXIT_OK	.\argproc.c	35;"	d	file:
EXTEND_BUFFER	.\regex.c	941;"	d	file:
EXTENSION_SEPARATOR	.\options.c	47;"	d	file:
EXTRACT_NUMBER	.\regex.c	403;"	d	file:
EXTRACT_NUMBER	.\regex.c	421;"	d	file:
EXTRACT_NUMBER	.\regex.c	422;"	d	file:
EXTRACT_NUMBER_AND_INCR	.\regex.c	430;"	d	file:
EXTRACT_NUMBER_AND_INCR	.\regex.c	447;"	d	file:
EXTRACT_NUMBER_AND_INCR	.\regex.c	448;"	d	file:
EXTRA_INC	.\mk_bc5.mak	/^EXTRA_INC = -I$(REGEX_DIR)$/;"	m
EXTRA_LIBS	.\mk_bc3.mak	/^EXTRA_LIBS =$/;"	m
EXTRA_LIBS	.\mk_bc5.mak	/^EXTRA_LIBS = $(REGEX_DIR)\\gnu_regex.lib$/;"	m
EXTRA_LIBS	.\mk_bc5.mak	/^EXTRA_LIBS = regex.obj$/;"	m
EXTRA_LIBS	.\mk_mvc.mak	/^EXTRA_LIBS = regex.obj$/;"	m
EX_LINENUM	.\options.h	/^	EX_LINENUM,  \/* -n  only line numbers in tag file *\/$/;"	e	enum:eLocate
EX_MIX	.\options.h	/^	EX_MIX,      \/* line numbers for defines, patterns otherwise *\/$/;"	e	enum:eLocate
EX_PATTERN	.\options.h	/^	EX_PATTERN   \/* -N  only patterns in tag file *\/$/;"	e	enum:eLocate
E_AMIGA_H	.\e_amiga.h	12;"	d
E_DJGPP_H	.\e_djgpp.h	12;"	d
E_MAC_H	.\e_mac.h	16;"	d
E_MSOFT_H	.\e_msoft.h	12;"	d
E_OS2_H	.\e_os2.h	12;"	d
E_QDOS_H	.\e_qdos.h	12;"	d
E_RISCOS_H	.\e_riscos.h	18;"	d
E_VMS_H	.\e_vms.h	12;"	d
EiffelKeywordTable	.\eiffel.c	/^static const keywordDesc EiffelKeywordTable [] = {$/;"	v	file:
EiffelKinds	.\eiffel.c	/^static kindOption EiffelKinds [] = {$/;"	v	file:
EiffelParser	.\eiffel.c	/^extern parserDefinition* EiffelParser (void)$/;"	f
EmptyString	.\readtags.c	/^const char *const EmptyString = "";$/;"	v
ErlangKinds	.\erlang.c	/^static kindOption ErlangKinds[] = {$/;"	v	file:
ErlangParser	.\erlang.c	/^extern parserDefinition *ErlangParser (void)$/;"	f
Exception	.\c.c	/^static jmp_buf Exception;$/;"	v	file:
Exception	.\eiffel.c	/^static jmp_buf Exception;$/;"	v	file:
Exception	.\fortran.c	/^static jmp_buf Exception;$/;"	v	file:
Exception	.\jscript.c	/^static jmp_buf Exception;$/;"	v	file:
Exception	.\sql.c	/^static jmp_buf Exception;$/;"	v	file:
Exception	.\verilog.c	/^static jmp_buf Exception;$/;"	v	file:
ExceptionBraceFormattingError	.\c.c	/^	ExceptionBraceFormattingError$/;"	e	enum:eException	file:
ExceptionEOF	.\c.c	/^	ExceptionNone, ExceptionEOF, ExceptionFormattingError,$/;"	e	enum:eException	file:
ExceptionEOF	.\eiffel.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionEOF	.\fortran.c	/^	ExceptionNone, ExceptionEOF, ExceptionFixedFormat, ExceptionLoop$/;"	e	enum:eException	file:
ExceptionEOF	.\jscript.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionEOF	.\sql.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionEOF	.\verilog.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionFixedFormat	.\fortran.c	/^	ExceptionNone, ExceptionEOF, ExceptionFixedFormat, ExceptionLoop$/;"	e	enum:eException	file:
ExceptionFormattingError	.\c.c	/^	ExceptionNone, ExceptionEOF, ExceptionFormattingError,$/;"	e	enum:eException	file:
ExceptionLoop	.\fortran.c	/^	ExceptionNone, ExceptionEOF, ExceptionFixedFormat, ExceptionLoop$/;"	e	enum:eException	file:
ExceptionNone	.\c.c	/^	ExceptionNone, ExceptionEOF, ExceptionFormattingError,$/;"	e	enum:eException	file:
ExceptionNone	.\eiffel.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionNone	.\fortran.c	/^	ExceptionNone, ExceptionEOF, ExceptionFixedFormat, ExceptionLoop$/;"	e	enum:eException	file:
ExceptionNone	.\jscript.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionNone	.\sql.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
ExceptionNone	.\verilog.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	e	enum:eException	file:
Excluded	.\options.c	/^static stringList* Excluded;$/;"	v	file:
ExecutableName	.\routines.c	/^static const char *ExecutableName;$/;"	v	file:
ExecutableProgram	.\routines.c	/^static const char *ExecutableProgram;$/;"	v	file:
FAIL_STACK_EMPTY	.\regex.c	2271;"	d	file:
FAIL_STACK_FULL	.\regex.c	2273;"	d	file:
FAIL_STACK_PTR_EMPTY	.\regex.c	2272;"	d	file:
FAIL_STACK_TOP	.\regex.c	2274;"	d	file:
FALSE	.\general.h	/^typedef enum { FALSE, TRUE } boolean;$/;"	e	enum:__anon22
FALSE	.\general.h	/^typedef enum { FALSE, TRUE } booleanType;$/;"	e	enum:__anon21
FALSE	.\general.h	90;"	d
FALSE	.\general.h	98;"	d
FATAL	.\routines.h	/^enum eErrorTypes { FATAL = 1, WARNING = 2, PERROR = 4 };$/;"	e	enum:eErrorTypes
FA_DIREC	.\e_msoft.h	71;"	d
FILEBUF_INCR	.\qdos.c	41;"	d	file:
FILEBUF_INIT	.\qdos.c	40;"	d	file:
FILES	.\ctags.html	/^<a name="FILES"><\/a>$/;"	a
FILE_WRITE	.\read.c	21;"	d	file:
FIRST_STRING_P	.\regex.c	221;"	d	file:
FORMFEED	.\read.h	/^	FORMFEED      = '\\f',$/;"	e	enum:eCharacters
FREE_VAR	.\regex.c	3100;"	d	file:
FREE_VARIABLES	.\regex.c	3101;"	d	file:
FREE_VARIABLES	.\regex.c	3116;"	d	file:
Features	.\options.c	/^static const char *const Features [] = {$/;"	v	file:
File	.\eiffel.c	/^static FILE *File;$/;"	v	file:
File	.\read.c	/^inputFile File;  \/* globally read through macros *\/$/;"	v
FileName	.\eiffel.c	/^static const char *FileName;$/;"	v	file:
FilesRequired	.\options.c	/^static boolean FilesRequired = TRUE;$/;"	v	file:
FocusRestorer	.\plugin_helpers.py	/^class FocusRestorer(object):$/;"	c
FortranKeywordTable	.\fortran.c	/^static const keywordDesc FortranKeywordTable [] = {$/;"	v	file:
FortranKinds	.\fortran.c	/^static kindOption FortranKinds [] = {$/;"	v	file:
FortranParser	.\fortran.c	/^extern parserDefinition* FortranParser (void)$/;"	f
FreeSourceForm	.\fortran.c	/^static boolean FreeSourceForm;$/;"	v	file:
FunctionNames	.\jscript.c	/^static stringList *FunctionNames;$/;"	v	file:
GET_BUFFER_SPACE	.\regex.c	882;"	d	file:
GET_UNSIGNED_NUMBER	.\regex.c	1017;"	d	file:
GenericNames	.\eiffel.c	/^static stringList *GenericNames;$/;"	v	file:
HASH_EXPONENT	.\keyword.c	27;"	d	file:
HAVE_CHMOD	.\e_riscos.h	27;"	d
HAVE_CHSIZE	.\e_msoft.h	30;"	d
HAVE_CHSIZE	.\e_os2.h	25;"	d
HAVE_CHSIZE	.\e_riscos.h	28;"	d
HAVE_CLOCK	.\e_amiga.h	18;"	d
HAVE_CLOCK	.\e_djgpp.h	30;"	d
HAVE_CLOCK	.\e_mac.h	26;"	d
HAVE_CLOCK	.\e_msoft.h	29;"	d
HAVE_CLOCK	.\e_os2.h	24;"	d
HAVE_CLOCK	.\e_qdos.h	22;"	d
HAVE_CLOCK	.\e_riscos.h	29;"	d
HAVE_CLOCK	.\e_vms.h	25;"	d
HAVE_DIRECT_H	.\e_msoft.h	50;"	d
HAVE_DIRENT_H	.\e_djgpp.h	18;"	d
HAVE_DIRENT_H	.\e_msoft.h	44;"	d
HAVE_DIRENT_H	.\e_msoft.h	67;"	d
HAVE_DIRENT_H	.\e_os2.h	16;"	d
HAVE_DIRENT_H	.\e_qdos.h	14;"	d
HAVE_DIRENT_H	.\e_riscos.h	45;"	d
HAVE_DIR_H	.\e_djgpp.h	17;"	d
HAVE_DIR_H	.\e_msoft.h	43;"	d
HAVE_DIR_H	.\e_msoft.h	66;"	d
HAVE_DOS_H	.\e_msoft.h	22;"	d
HAVE_FCNTL_H	.\e_djgpp.h	19;"	d
HAVE_FCNTL_H	.\e_mac.h	33;"	d
HAVE_FCNTL_H	.\e_msoft.h	23;"	d
HAVE_FCNTL_H	.\e_os2.h	17;"	d
HAVE_FCNTL_H	.\e_riscos.h	46;"	d
HAVE_FCNTL_H	.\e_vms.h	21;"	d
HAVE_FGETPOS	.\e_amiga.h	19;"	d
HAVE_FGETPOS	.\e_djgpp.h	31;"	d
HAVE_FGETPOS	.\e_mac.h	27;"	d
HAVE_FGETPOS	.\e_msoft.h	31;"	d
HAVE_FGETPOS	.\e_msoft.h	63;"	d
HAVE_FGETPOS	.\e_os2.h	26;"	d
HAVE_FGETPOS	.\e_qdos.h	23;"	d
HAVE_FGETPOS	.\e_riscos.h	30;"	d
HAVE_FGETPOS	.\e_vms.h	26;"	d
HAVE_FINDFIRST	.\e_msoft.h	45;"	d
HAVE_FINDNEXT	.\e_msoft.h	36;"	d
HAVE_FNMATCH	.\e_djgpp.h	32;"	d
HAVE_FNMATCH	.\e_riscos.h	31;"	d
HAVE_FNMATCH_H	.\e_djgpp.h	20;"	d
HAVE_FNMATCH_H	.\e_riscos.h	47;"	d
HAVE_FTRUNCATE	.\e_os2.h	27;"	d
HAVE_FTRUNCATE	.\e_qdos.h	24;"	d
HAVE_FTRUNCATE	.\e_riscos.h	32;"	d
HAVE_IO_H	.\e_msoft.h	24;"	d
HAVE_IO_H	.\e_os2.h	18;"	d
HAVE_MKSTEMP	.\e_djgpp.h	33;"	d
HAVE_MKSTEMP	.\e_riscos.h	33;"	d
HAVE_OPENDIR	.\e_djgpp.h	34;"	d
HAVE_OPENDIR	.\e_mac.h	28;"	d
HAVE_OPENDIR	.\e_os2.h	28;"	d
HAVE_OPENDIR	.\e_qdos.h	25;"	d
HAVE_OPENDIR	.\e_riscos.h	34;"	d
HAVE_PUTENV	.\e_qdos.h	26;"	d
HAVE_PUTENV	.\e_riscos.h	35;"	d
HAVE_REGCOMP	.\e_djgpp.h	35;"	d
HAVE_REGCOMP	.\e_os2.h	29;"	d
HAVE_REGCOMP	.\e_riscos.h	36;"	d
HAVE_REGEX	.\general.h	53;"	d
HAVE_REMOVE	.\e_djgpp.h	36;"	d
HAVE_REMOVE	.\e_mac.h	29;"	d
HAVE_REMOVE	.\e_os2.h	30;"	d
HAVE_REMOVE	.\e_qdos.h	27;"	d
HAVE_REMOVE	.\e_riscos.h	37;"	d
HAVE_SETENV	.\e_djgpp.h	37;"	d
HAVE_SETENV	.\e_mac.h	30;"	d
HAVE_SETENV	.\e_riscos.h	38;"	d
HAVE_STAT_H	.\e_riscos.h	48;"	d
HAVE_STAT_H	.\e_vms.h	18;"	d
HAVE_STAT_ST_INO	.\e_djgpp.h	38;"	d
HAVE_STDLIB_H	.\e_amiga.h	14;"	d
HAVE_STDLIB_H	.\e_djgpp.h	21;"	d
HAVE_STDLIB_H	.\e_mac.h	34;"	d
HAVE_STDLIB_H	.\e_mac.h	40;"	d
HAVE_STDLIB_H	.\e_msoft.h	25;"	d
HAVE_STDLIB_H	.\e_os2.h	19;"	d
HAVE_STDLIB_H	.\e_qdos.h	15;"	d
HAVE_STDLIB_H	.\e_riscos.h	49;"	d
HAVE_STDLIB_H	.\e_vms.h	15;"	d
HAVE_STRCASECMP	.\e_djgpp.h	39;"	d
HAVE_STRERROR	.\e_amiga.h	20;"	d
HAVE_STRERROR	.\e_djgpp.h	40;"	d
HAVE_STRERROR	.\e_mac.h	31;"	d
HAVE_STRERROR	.\e_msoft.h	35;"	d
HAVE_STRERROR	.\e_os2.h	31;"	d
HAVE_STRERROR	.\e_qdos.h	28;"	d
HAVE_STRERROR	.\e_riscos.h	39;"	d
HAVE_STRERROR	.\e_vms.h	27;"	d
HAVE_STRICMP	.\e_amiga.h	21;"	d
HAVE_STRICMP	.\e_msoft.h	32;"	d
HAVE_STRICMP	.\e_os2.h	32;"	d
HAVE_STRICMP	.\e_riscos.h	40;"	d
HAVE_STRING_H	.\e_djgpp.h	22;"	d
HAVE_STRING_H	.\e_mac.h	35;"	d
HAVE_STRING_H	.\e_riscos.h	50;"	d
HAVE_STRNCASECMP	.\e_djgpp.h	41;"	d
HAVE_STRNICMP	.\e_amiga.h	22;"	d
HAVE_STRNICMP	.\e_msoft.h	33;"	d
HAVE_STRNICMP	.\e_os2.h	33;"	d
HAVE_STRNICMP	.\e_riscos.h	41;"	d
HAVE_STRSTR	.\e_djgpp.h	42;"	d
HAVE_STRSTR	.\e_mac.h	32;"	d
HAVE_STRSTR	.\e_msoft.h	34;"	d
HAVE_STRSTR	.\e_os2.h	34;"	d
HAVE_STRSTR	.\e_qdos.h	29;"	d
HAVE_STRSTR	.\e_riscos.h	42;"	d
HAVE_STRSTR	.\e_vms.h	28;"	d
HAVE_SYS_DIR_H	.\e_djgpp.h	23;"	d
HAVE_SYS_DIR_H	.\e_mac.h	36;"	d
HAVE_SYS_DIR_H	.\e_riscos.h	51;"	d
HAVE_SYS_STAT_H	.\e_amiga.h	15;"	d
HAVE_SYS_STAT_H	.\e_djgpp.h	24;"	d
HAVE_SYS_STAT_H	.\e_msoft.h	26;"	d
HAVE_SYS_STAT_H	.\e_os2.h	20;"	d
HAVE_SYS_STAT_H	.\e_qdos.h	16;"	d
HAVE_SYS_STAT_H	.\e_riscos.h	52;"	d
HAVE_SYS_STAT_H	.\e_vms.h	22;"	d
HAVE_SYS_TIMES_H	.\e_djgpp.h	25;"	d
HAVE_SYS_TIMES_H	.\e_mac.h	37;"	d
HAVE_SYS_TIMES_H	.\e_qdos.h	17;"	d
HAVE_SYS_TIMES_H	.\e_riscos.h	53;"	d
HAVE_SYS_TYPES_H	.\e_amiga.h	16;"	d
HAVE_SYS_TYPES_H	.\e_djgpp.h	26;"	d
HAVE_SYS_TYPES_H	.\e_msoft.h	27;"	d
HAVE_SYS_TYPES_H	.\e_os2.h	21;"	d
HAVE_SYS_TYPES_H	.\e_qdos.h	18;"	d
HAVE_SYS_TYPES_H	.\e_riscos.h	54;"	d
HAVE_SYS_TYPES_H	.\e_vms.h	23;"	d
HAVE_TEMPNAM	.\e_msoft.h	37;"	d
HAVE_TIMES	.\e_qdos.h	30;"	d
HAVE_TIMES	.\e_riscos.h	43;"	d
HAVE_TIME_H	.\e_amiga.h	17;"	d
HAVE_TIME_H	.\e_djgpp.h	27;"	d
HAVE_TIME_H	.\e_mac.h	38;"	d
HAVE_TIME_H	.\e_msoft.h	28;"	d
HAVE_TIME_H	.\e_os2.h	22;"	d
HAVE_TIME_H	.\e_qdos.h	19;"	d
HAVE_TIME_H	.\e_riscos.h	55;"	d
HAVE_TIME_H	.\e_vms.h	16;"	d
HAVE_TRUNCATE	.\e_djgpp.h	43;"	d
HAVE_TRUNCATE	.\e_os2.h	35;"	d
HAVE_TRUNCATE	.\e_qdos.h	31;"	d
HAVE_TRUNCATE	.\e_riscos.h	44;"	d
HAVE_TYPES_H	.\e_mac.h	39;"	d
HAVE_TYPES_H	.\e_vms.h	19;"	d
HAVE_UNISTD_H	.\e_djgpp.h	28;"	d
HAVE_UNISTD_H	.\e_os2.h	23;"	d
HAVE_UNISTD_H	.\e_qdos.h	20;"	d
HAVE_UNISTD_H	.\e_riscos.h	56;"	d
HAVE_UNISTD_H	.\e_vms.h	29;"	d
HAVE__FINDFIRST	.\e_msoft.h	49;"	d
HAVE__FINDFIRST	.\e_msoft.h	68;"	d
HEADERS	.\mk_mpw.mak	/^HEADERS	= ¶$/;"	m
HEADERS	.\mk_qdos.mak	/^HEADERS = e_qdos.h \\$/;"	m
HEADERS	.\source.mak	/^HEADERS = \\$/;"	m
HOW TO USE WITH GNU EMACS	.\ctags.html	/^<a name="HOW TO USE WITH GNU EMACS"><\/a>$/;"	a
HOW TO USE WITH NEDIT	.\ctags.html	/^<a name="HOW TO USE WITH NEDIT"><\/a>$/;"	a
HOW TO USE WITH VI	.\ctags.html	/^<a name="HOW TO USE WITH VI"><\/a>$/;"	a
HashTable	.\keyword.c	/^static hashEntry **HashTable = NULL;$/;"	v	file:
HeaderExtensions	.\options.c	/^static const char *const HeaderExtensions [] = {$/;"	v	file:
HtmlParser	.\html.c	/^extern parserDefinition* HtmlParser (void)$/;"	f
IGNORE_SEPARATORS	.\options.c	50;"	d	file:
IMP_ABSTRACT	.\c.c	/^	IMP_ABSTRACT,$/;"	e	enum:eImplementation	file:
IMP_COUNT	.\c.c	/^	IMP_COUNT$/;"	e	enum:eImplementation	file:
IMP_DEFAULT	.\c.c	/^	IMP_DEFAULT,$/;"	e	enum:eImplementation	file:
IMP_PURE_VIRTUAL	.\c.c	/^	IMP_PURE_VIRTUAL,$/;"	e	enum:eImplementation	file:
IMP_VIRTUAL	.\c.c	/^	IMP_VIRTUAL,$/;"	e	enum:eImplementation	file:
INC	.\mk_bc3.mak	/^INC	= -I$(BCCLOC)\\include$/;"	m
INCLUDES	.\mk_bc5.mak	/^INCLUDES = $(EXTRA_INC)$/;"	m
INCLUDES	.\mk_mvc.mak	/^INCLUDES = -I.$/;"	m
INIT_BUF_SIZE	.\regex.c	879;"	d	file:
INIT_COMPILE_STACK_SIZE	.\regex.c	1001;"	d	file:
INIT_FAILURE_ALLOC	.\regex.c	2253;"	d	file:
INIT_FAIL_STACK	.\regex.c	2279;"	d	file:
INSERT_JUMP	.\regex.c	923;"	d	file:
INSERT_JUMP2	.\regex.c	927;"	d	file:
INTERNAL_SORT	.\e_mac.h	22;"	d
INTERNAL_SORT	.\e_riscos.h	22;"	d
INVOCATION	.\options.c	33;"	d	file:
ISALNUM	.\regex.c	147;"	d	file:
ISALPHA	.\regex.c	148;"	d	file:
ISBLANK	.\regex.c	135;"	d	file:
ISBLANK	.\regex.c	137;"	d	file:
ISCNTRL	.\regex.c	149;"	d	file:
ISDIGIT	.\regex.c	146;"	d	file:
ISGRAPH	.\regex.c	140;"	d	file:
ISGRAPH	.\regex.c	142;"	d	file:
ISLOWER	.\regex.c	150;"	d	file:
ISPRINT	.\regex.c	145;"	d	file:
ISPUNCT	.\regex.c	151;"	d	file:
ISSPACE	.\regex.c	152;"	d	file:
ISUPPER	.\regex.c	153;"	d	file:
ISXDIGIT	.\regex.c	154;"	d	file:
IS_ACTIVE	.\regex.c	3026;"	d	file:
IS_CHAR_CLASS	.\regex.c	1035;"	d	file:
JK_ACCESS	.\c.c	/^	JK_LOCAL, JK_METHOD, JK_PACKAGE, JK_ACCESS, JK_CLASS_PREFIX$/;"	e	enum:__anon14	file:
JK_CLASS	.\c.c	/^	JK_CLASS, JK_ENUM_CONSTANT, JK_FIELD, JK_ENUM, JK_INTERFACE,$/;"	e	enum:__anon14	file:
JK_CLASS_PREFIX	.\c.c	/^	JK_LOCAL, JK_METHOD, JK_PACKAGE, JK_ACCESS, JK_CLASS_PREFIX$/;"	e	enum:__anon14	file:
JK_ENUM	.\c.c	/^	JK_CLASS, JK_ENUM_CONSTANT, JK_FIELD, JK_ENUM, JK_INTERFACE,$/;"	e	enum:__anon14	file:
JK_ENUM_CONSTANT	.\c.c	/^	JK_CLASS, JK_ENUM_CONSTANT, JK_FIELD, JK_ENUM, JK_INTERFACE,$/;"	e	enum:__anon14	file:
JK_FIELD	.\c.c	/^	JK_CLASS, JK_ENUM_CONSTANT, JK_FIELD, JK_ENUM, JK_INTERFACE,$/;"	e	enum:__anon14	file:
JK_INTERFACE	.\c.c	/^	JK_CLASS, JK_ENUM_CONSTANT, JK_FIELD, JK_ENUM, JK_INTERFACE,$/;"	e	enum:__anon14	file:
JK_LOCAL	.\c.c	/^	JK_LOCAL, JK_METHOD, JK_PACKAGE, JK_ACCESS, JK_CLASS_PREFIX$/;"	e	enum:__anon14	file:
JK_METHOD	.\c.c	/^	JK_LOCAL, JK_METHOD, JK_PACKAGE, JK_ACCESS, JK_CLASS_PREFIX$/;"	e	enum:__anon14	file:
JK_PACKAGE	.\c.c	/^	JK_LOCAL, JK_METHOD, JK_PACKAGE, JK_ACCESS, JK_CLASS_PREFIX$/;"	e	enum:__anon14	file:
JK_UNDEFINED	.\c.c	/^	JK_UNDEFINED = -1,$/;"	e	enum:__anon14	file:
JSTAG_CLASS	.\jscript.c	/^	JSTAG_CLASS,$/;"	e	enum:__anon24	file:
JSTAG_COUNT	.\jscript.c	/^	JSTAG_COUNT$/;"	e	enum:__anon24	file:
JSTAG_FUNCTION	.\jscript.c	/^	JSTAG_FUNCTION,$/;"	e	enum:__anon24	file:
JSTAG_METHOD	.\jscript.c	/^	JSTAG_METHOD,$/;"	e	enum:__anon24	file:
JSTAG_VARIABLE	.\jscript.c	/^	JSTAG_VARIABLE,$/;"	e	enum:__anon24	file:
JUMP_BACK	.\readtags.c	561;"	d	file:
JavaKinds	.\c.c	/^static kindOption JavaKinds [] = {$/;"	v	file:
JavaParser	.\c.c	/^extern parserDefinition* JavaParser (void)$/;"	f
JavaScriptParser	.\jscript.c	/^extern parserDefinition* JavaScriptParser (void)$/;"	f
JsKeywordTable	.\jscript.c	/^static const keywordDesc JsKeywordTable [] = {$/;"	v	file:
JsKinds	.\jscript.c	/^static kindOption JsKinds [] = {$/;"	v	file:
JumpBack	.\ctags_plugin.py	/^class JumpBack(sublimeplugin.TextCommand):$/;"	c
KEYWORD_ABSTRACT	.\c.c	/^	KEYWORD_ATTRIBUTE, KEYWORD_ABSTRACT,$/;"	e	enum:eKeywordId	file:
KEYWORD_ATTRIBUTE	.\c.c	/^	KEYWORD_ATTRIBUTE, KEYWORD_ABSTRACT,$/;"	e	enum:eKeywordId	file:
KEYWORD_BAD_STATE	.\c.c	/^	KEYWORD_BOOLEAN, KEYWORD_BYTE, KEYWORD_BAD_STATE, KEYWORD_BAD_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_BAD_TRANS	.\c.c	/^	KEYWORD_BOOLEAN, KEYWORD_BYTE, KEYWORD_BAD_STATE, KEYWORD_BAD_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_BIND	.\c.c	/^	KEYWORD_BIND, KEYWORD_BIND_VAR, KEYWORD_BIT,$/;"	e	enum:eKeywordId	file:
KEYWORD_BIND_VAR	.\c.c	/^	KEYWORD_BIND, KEYWORD_BIND_VAR, KEYWORD_BIT,$/;"	e	enum:eKeywordId	file:
KEYWORD_BIT	.\c.c	/^	KEYWORD_BIND, KEYWORD_BIND_VAR, KEYWORD_BIT,$/;"	e	enum:eKeywordId	file:
KEYWORD_BOOLEAN	.\c.c	/^	KEYWORD_BOOLEAN, KEYWORD_BYTE, KEYWORD_BAD_STATE, KEYWORD_BAD_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_BYTE	.\c.c	/^	KEYWORD_BOOLEAN, KEYWORD_BYTE, KEYWORD_BAD_STATE, KEYWORD_BAD_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_CASE	.\c.c	/^	KEYWORD_CASE, KEYWORD_CATCH, KEYWORD_CHAR, KEYWORD_CLASS, KEYWORD_CONST,$/;"	e	enum:eKeywordId	file:
KEYWORD_CATCH	.\c.c	/^	KEYWORD_CASE, KEYWORD_CATCH, KEYWORD_CHAR, KEYWORD_CLASS, KEYWORD_CONST,$/;"	e	enum:eKeywordId	file:
KEYWORD_CHAR	.\c.c	/^	KEYWORD_CASE, KEYWORD_CATCH, KEYWORD_CHAR, KEYWORD_CLASS, KEYWORD_CONST,$/;"	e	enum:eKeywordId	file:
KEYWORD_CLASS	.\c.c	/^	KEYWORD_CASE, KEYWORD_CATCH, KEYWORD_CHAR, KEYWORD_CLASS, KEYWORD_CONST,$/;"	e	enum:eKeywordId	file:
KEYWORD_CONST	.\c.c	/^	KEYWORD_CASE, KEYWORD_CATCH, KEYWORD_CHAR, KEYWORD_CLASS, KEYWORD_CONST,$/;"	e	enum:eKeywordId	file:
KEYWORD_CONSTRAINT	.\c.c	/^	KEYWORD_CONSTRAINT, KEYWORD_COVERAGE_BLOCK, KEYWORD_COVERAGE_DEF,$/;"	e	enum:eKeywordId	file:
KEYWORD_COVERAGE_BLOCK	.\c.c	/^	KEYWORD_CONSTRAINT, KEYWORD_COVERAGE_BLOCK, KEYWORD_COVERAGE_DEF,$/;"	e	enum:eKeywordId	file:
KEYWORD_COVERAGE_DEF	.\c.c	/^	KEYWORD_CONSTRAINT, KEYWORD_COVERAGE_BLOCK, KEYWORD_COVERAGE_DEF,$/;"	e	enum:eKeywordId	file:
KEYWORD_Current	.\eiffel.c	/^	KEYWORD_class, KEYWORD_convert, KEYWORD_create, KEYWORD_creation, KEYWORD_Current,$/;"	e	enum:eKeywordId	file:
KEYWORD_DEFAULT	.\c.c	/^	KEYWORD_DEFAULT, KEYWORD_DELEGATE, KEYWORD_DELETE, KEYWORD_DO,$/;"	e	enum:eKeywordId	file:
KEYWORD_DELEGATE	.\c.c	/^	KEYWORD_DEFAULT, KEYWORD_DELEGATE, KEYWORD_DELETE, KEYWORD_DO,$/;"	e	enum:eKeywordId	file:
KEYWORD_DELETE	.\c.c	/^	KEYWORD_DEFAULT, KEYWORD_DELEGATE, KEYWORD_DELETE, KEYWORD_DO,$/;"	e	enum:eKeywordId	file:
KEYWORD_DO	.\c.c	/^	KEYWORD_DEFAULT, KEYWORD_DELEGATE, KEYWORD_DELETE, KEYWORD_DO,$/;"	e	enum:eKeywordId	file:
KEYWORD_DOUBLE	.\c.c	/^	KEYWORD_DOUBLE,$/;"	e	enum:eKeywordId	file:
KEYWORD_ELSE	.\c.c	/^	KEYWORD_ELSE, KEYWORD_ENUM, KEYWORD_EXPLICIT, KEYWORD_EXTERN,$/;"	e	enum:eKeywordId	file:
KEYWORD_ENUM	.\c.c	/^	KEYWORD_ELSE, KEYWORD_ENUM, KEYWORD_EXPLICIT, KEYWORD_EXTERN,$/;"	e	enum:eKeywordId	file:
KEYWORD_EVENT	.\c.c	/^	KEYWORD_EXTENDS, KEYWORD_EVENT,$/;"	e	enum:eKeywordId	file:
KEYWORD_EXPLICIT	.\c.c	/^	KEYWORD_ELSE, KEYWORD_ENUM, KEYWORD_EXPLICIT, KEYWORD_EXTERN,$/;"	e	enum:eKeywordId	file:
KEYWORD_EXTENDS	.\c.c	/^	KEYWORD_EXTENDS, KEYWORD_EVENT,$/;"	e	enum:eKeywordId	file:
KEYWORD_EXTERN	.\c.c	/^	KEYWORD_ELSE, KEYWORD_ENUM, KEYWORD_EXPLICIT, KEYWORD_EXTERN,$/;"	e	enum:eKeywordId	file:
KEYWORD_FINAL	.\c.c	/^	KEYWORD_FINAL, KEYWORD_FLOAT, KEYWORD_FOR, KEYWORD_FRIEND, KEYWORD_FUNCTION,$/;"	e	enum:eKeywordId	file:
KEYWORD_FLOAT	.\c.c	/^	KEYWORD_FINAL, KEYWORD_FLOAT, KEYWORD_FOR, KEYWORD_FRIEND, KEYWORD_FUNCTION,$/;"	e	enum:eKeywordId	file:
KEYWORD_FOR	.\c.c	/^	KEYWORD_FINAL, KEYWORD_FLOAT, KEYWORD_FOR, KEYWORD_FRIEND, KEYWORD_FUNCTION,$/;"	e	enum:eKeywordId	file:
KEYWORD_FRIEND	.\c.c	/^	KEYWORD_FINAL, KEYWORD_FLOAT, KEYWORD_FOR, KEYWORD_FRIEND, KEYWORD_FUNCTION,$/;"	e	enum:eKeywordId	file:
KEYWORD_FUNCTION	.\c.c	/^	KEYWORD_FINAL, KEYWORD_FLOAT, KEYWORD_FOR, KEYWORD_FRIEND, KEYWORD_FUNCTION,$/;"	e	enum:eKeywordId	file:
KEYWORD_GOTO	.\c.c	/^	KEYWORD_GOTO,$/;"	e	enum:eKeywordId	file:
KEYWORD_IF	.\c.c	/^	KEYWORD_IF, KEYWORD_IMPLEMENTS, KEYWORD_IMPORT, KEYWORD_INLINE, KEYWORD_INT,$/;"	e	enum:eKeywordId	file:
KEYWORD_IMPLEMENTS	.\c.c	/^	KEYWORD_IF, KEYWORD_IMPLEMENTS, KEYWORD_IMPORT, KEYWORD_INLINE, KEYWORD_INT,$/;"	e	enum:eKeywordId	file:
KEYWORD_IMPORT	.\c.c	/^	KEYWORD_IF, KEYWORD_IMPLEMENTS, KEYWORD_IMPORT, KEYWORD_INLINE, KEYWORD_INT,$/;"	e	enum:eKeywordId	file:
KEYWORD_INLINE	.\c.c	/^	KEYWORD_IF, KEYWORD_IMPLEMENTS, KEYWORD_IMPORT, KEYWORD_INLINE, KEYWORD_INT,$/;"	e	enum:eKeywordId	file:
KEYWORD_INOUT	.\c.c	/^	KEYWORD_INOUT, KEYWORD_INPUT, KEYWORD_INTEGER, KEYWORD_INTERFACE,$/;"	e	enum:eKeywordId	file:
KEYWORD_INPUT	.\c.c	/^	KEYWORD_INOUT, KEYWORD_INPUT, KEYWORD_INTEGER, KEYWORD_INTERFACE,$/;"	e	enum:eKeywordId	file:
KEYWORD_INT	.\c.c	/^	KEYWORD_IF, KEYWORD_IMPLEMENTS, KEYWORD_IMPORT, KEYWORD_INLINE, KEYWORD_INT,$/;"	e	enum:eKeywordId	file:
KEYWORD_INTEGER	.\c.c	/^	KEYWORD_INOUT, KEYWORD_INPUT, KEYWORD_INTEGER, KEYWORD_INTERFACE,$/;"	e	enum:eKeywordId	file:
KEYWORD_INTERFACE	.\c.c	/^	KEYWORD_INOUT, KEYWORD_INPUT, KEYWORD_INTEGER, KEYWORD_INTERFACE,$/;"	e	enum:eKeywordId	file:
KEYWORD_INTERNAL	.\c.c	/^	KEYWORD_INTERNAL,$/;"	e	enum:eKeywordId	file:
KEYWORD_LOCAL	.\c.c	/^	KEYWORD_LOCAL, KEYWORD_LONG,$/;"	e	enum:eKeywordId	file:
KEYWORD_LONG	.\c.c	/^	KEYWORD_LOCAL, KEYWORD_LONG,$/;"	e	enum:eKeywordId	file:
KEYWORD_MUTABLE	.\c.c	/^	KEYWORD_MUTABLE,$/;"	e	enum:eKeywordId	file:
KEYWORD_M_BAD_STATE	.\c.c	/^	KEYWORD_M_BAD_STATE, KEYWORD_M_BAD_TRANS, KEYWORD_M_STATE, KEYWORD_M_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_M_BAD_TRANS	.\c.c	/^	KEYWORD_M_BAD_STATE, KEYWORD_M_BAD_TRANS, KEYWORD_M_STATE, KEYWORD_M_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_M_STATE	.\c.c	/^	KEYWORD_M_BAD_STATE, KEYWORD_M_BAD_TRANS, KEYWORD_M_STATE, KEYWORD_M_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_M_TRANS	.\c.c	/^	KEYWORD_M_BAD_STATE, KEYWORD_M_BAD_TRANS, KEYWORD_M_STATE, KEYWORD_M_TRANS,$/;"	e	enum:eKeywordId	file:
KEYWORD_NAMESPACE	.\c.c	/^	KEYWORD_NAMESPACE, KEYWORD_NEW, KEYWORD_NEWCOV, KEYWORD_NATIVE,$/;"	e	enum:eKeywordId	file:
KEYWORD_NATIVE	.\c.c	/^	KEYWORD_NAMESPACE, KEYWORD_NEW, KEYWORD_NEWCOV, KEYWORD_NATIVE,$/;"	e	enum:eKeywordId	file:
KEYWORD_NEW	.\c.c	/^	KEYWORD_NAMESPACE, KEYWORD_NEW, KEYWORD_NEWCOV, KEYWORD_NATIVE,$/;"	e	enum:eKeywordId	file:
KEYWORD_NEWCOV	.\c.c	/^	KEYWORD_NAMESPACE, KEYWORD_NEW, KEYWORD_NEWCOV, KEYWORD_NATIVE,$/;"	e	enum:eKeywordId	file:
KEYWORD_NONE	.\c.c	/^	KEYWORD_NONE = -1,$/;"	e	enum:eKeywordId	file:
KEYWORD_NONE	.\eiffel.c	/^	KEYWORD_NONE = -1,$/;"	e	enum:eKeywordId	file:
KEYWORD_NONE	.\fortran.c	/^	KEYWORD_NONE = -1,$/;"	e	enum:eKeywordId	file:
KEYWORD_NONE	.\jscript.c	/^	KEYWORD_NONE = -1,$/;"	e	enum:eKeywordId	file:
KEYWORD_NONE	.\sql.c	/^	KEYWORD_NONE = -1,$/;"	e	enum:eKeywordId	file:
KEYWORD_OPERATOR	.\c.c	/^	KEYWORD_OPERATOR, KEYWORD_OUTPUT, KEYWORD_OVERLOAD, KEYWORD_OVERRIDE,$/;"	e	enum:eKeywordId	file:
KEYWORD_OUTPUT	.\c.c	/^	KEYWORD_OPERATOR, KEYWORD_OUTPUT, KEYWORD_OVERLOAD, KEYWORD_OVERRIDE,$/;"	e	enum:eKeywordId	file:
KEYWORD_OVERLOAD	.\c.c	/^	KEYWORD_OPERATOR, KEYWORD_OUTPUT, KEYWORD_OVERLOAD, KEYWORD_OVERRIDE,$/;"	e	enum:eKeywordId	file:
KEYWORD_OVERRIDE	.\c.c	/^	KEYWORD_OPERATOR, KEYWORD_OUTPUT, KEYWORD_OVERLOAD, KEYWORD_OVERRIDE,$/;"	e	enum:eKeywordId	file:
KEYWORD_PACKAGE	.\c.c	/^	KEYWORD_PACKED, KEYWORD_PORT, KEYWORD_PACKAGE, KEYWORD_PRIVATE,$/;"	e	enum:eKeywordId	file:
KEYWORD_PACKED	.\c.c	/^	KEYWORD_PACKED, KEYWORD_PORT, KEYWORD_PACKAGE, KEYWORD_PRIVATE,$/;"	e	enum:eKeywordId	file:
KEYWORD_PORT	.\c.c	/^	KEYWORD_PACKED, KEYWORD_PORT, KEYWORD_PACKAGE, KEYWORD_PRIVATE,$/;"	e	enum:eKeywordId	file:
KEYWORD_PRIVATE	.\c.c	/^	KEYWORD_PACKED, KEYWORD_PORT, KEYWORD_PACKAGE, KEYWORD_PRIVATE,$/;"	e	enum:eKeywordId	file:
KEYWORD_PROGRAM	.\c.c	/^	KEYWORD_PROGRAM, KEYWORD_PROTECTED, KEYWORD_PUBLIC,$/;"	e	enum:eKeywordId	file:
KEYWORD_PROTECTED	.\c.c	/^	KEYWORD_PROGRAM, KEYWORD_PROTECTED, KEYWORD_PUBLIC,$/;"	e	enum:eKeywordId	file:
KEYWORD_PUBLIC	.\c.c	/^	KEYWORD_PROGRAM, KEYWORD_PROTECTED, KEYWORD_PUBLIC,$/;"	e	enum:eKeywordId	file:
KEYWORD_REGISTER	.\c.c	/^	KEYWORD_REGISTER, KEYWORD_RETURN,$/;"	e	enum:eKeywordId	file:
KEYWORD_RETURN	.\c.c	/^	KEYWORD_REGISTER, KEYWORD_RETURN,$/;"	e	enum:eKeywordId	file:
KEYWORD_Result	.\eiffel.c	/^	KEYWORD_require, KEYWORD_rescue, KEYWORD_Result, KEYWORD_retry,$/;"	e	enum:eKeywordId	file:
KEYWORD_SHADOW	.\c.c	/^	KEYWORD_SHADOW, KEYWORD_STATE,$/;"	e	enum:eKeywordId	file:
KEYWORD_SHORT	.\c.c	/^	KEYWORD_SHORT, KEYWORD_SIGNED, KEYWORD_STATIC, KEYWORD_STRING,$/;"	e	enum:eKeywordId	file:
KEYWORD_SIGNED	.\c.c	/^	KEYWORD_SHORT, KEYWORD_SIGNED, KEYWORD_STATIC, KEYWORD_STRING,$/;"	e	enum:eKeywordId	file:
KEYWORD_STATE	.\c.c	/^	KEYWORD_SHADOW, KEYWORD_STATE,$/;"	e	enum:eKeywordId	file:
KEYWORD_STATIC	.\c.c	/^	KEYWORD_SHORT, KEYWORD_SIGNED, KEYWORD_STATIC, KEYWORD_STRING,$/;"	e	enum:eKeywordId	file:
KEYWORD_STRING	.\c.c	/^	KEYWORD_SHORT, KEYWORD_SIGNED, KEYWORD_STATIC, KEYWORD_STRING,$/;"	e	enum:eKeywordId	file:
KEYWORD_STRUCT	.\c.c	/^	KEYWORD_STRUCT, KEYWORD_SWITCH, KEYWORD_SYNCHRONIZED,$/;"	e	enum:eKeywordId	file:
KEYWORD_SWITCH	.\c.c	/^	KEYWORD_STRUCT, KEYWORD_SWITCH, KEYWORD_SYNCHRONIZED,$/;"	e	enum:eKeywordId	file:
KEYWORD_SYNCHRONIZED	.\c.c	/^	KEYWORD_STRUCT, KEYWORD_SWITCH, KEYWORD_SYNCHRONIZED,$/;"	e	enum:eKeywordId	file:
KEYWORD_TASK	.\c.c	/^	KEYWORD_TASK, KEYWORD_TEMPLATE, KEYWORD_THIS, KEYWORD_THROW,$/;"	e	enum:eKeywordId	file:
KEYWORD_TEMPLATE	.\c.c	/^	KEYWORD_TASK, KEYWORD_TEMPLATE, KEYWORD_THIS, KEYWORD_THROW,$/;"	e	enum:eKeywordId	file:
KEYWORD_THIS	.\c.c	/^	KEYWORD_TASK, KEYWORD_TEMPLATE, KEYWORD_THIS, KEYWORD_THROW,$/;"	e	enum:eKeywordId	file:
KEYWORD_THROW	.\c.c	/^	KEYWORD_TASK, KEYWORD_TEMPLATE, KEYWORD_THIS, KEYWORD_THROW,$/;"	e	enum:eKeywordId	file:
KEYWORD_THROWS	.\c.c	/^	KEYWORD_THROWS, KEYWORD_TRANSIENT, KEYWORD_TRANS, KEYWORD_TRANSITION,$/;"	e	enum:eKeywordId	file:
KEYWORD_TRANS	.\c.c	/^	KEYWORD_THROWS, KEYWORD_TRANSIENT, KEYWORD_TRANS, KEYWORD_TRANSITION,$/;"	e	enum:eKeywordId	file:
KEYWORD_TRANSIENT	.\c.c	/^	KEYWORD_THROWS, KEYWORD_TRANSIENT, KEYWORD_TRANS, KEYWORD_TRANSITION,$/;"	e	enum:eKeywordId	file:
KEYWORD_TRANSITION	.\c.c	/^	KEYWORD_THROWS, KEYWORD_TRANSIENT, KEYWORD_TRANS, KEYWORD_TRANSITION,$/;"	e	enum:eKeywordId	file:
KEYWORD_TRY	.\c.c	/^	KEYWORD_TRY, KEYWORD_TYPEDEF, KEYWORD_TYPENAME,$/;"	e	enum:eKeywordId	file:
KEYWORD_TYPEDEF	.\c.c	/^	KEYWORD_TRY, KEYWORD_TYPEDEF, KEYWORD_TYPENAME,$/;"	e	enum:eKeywordId	file:
KEYWORD_TYPENAME	.\c.c	/^	KEYWORD_TRY, KEYWORD_TYPEDEF, KEYWORD_TYPENAME,$/;"	e	enum:eKeywordId	file:
KEYWORD_UINT	.\c.c	/^	KEYWORD_UINT, KEYWORD_ULONG, KEYWORD_UNION, KEYWORD_UNSIGNED, KEYWORD_USHORT,$/;"	e	enum:eKeywordId	file:
KEYWORD_ULONG	.\c.c	/^	KEYWORD_UINT, KEYWORD_ULONG, KEYWORD_UNION, KEYWORD_UNSIGNED, KEYWORD_USHORT,$/;"	e	enum:eKeywordId	file:
KEYWORD_UNION	.\c.c	/^	KEYWORD_UINT, KEYWORD_ULONG, KEYWORD_UNION, KEYWORD_UNSIGNED, KEYWORD_USHORT,$/;"	e	enum:eKeywordId	file:
KEYWORD_UNSIGNED	.\c.c	/^	KEYWORD_UINT, KEYWORD_ULONG, KEYWORD_UNION, KEYWORD_UNSIGNED, KEYWORD_USHORT,$/;"	e	enum:eKeywordId	file:
KEYWORD_USHORT	.\c.c	/^	KEYWORD_UINT, KEYWORD_ULONG, KEYWORD_UNION, KEYWORD_UNSIGNED, KEYWORD_USHORT,$/;"	e	enum:eKeywordId	file:
KEYWORD_USING	.\c.c	/^	KEYWORD_USING,$/;"	e	enum:eKeywordId	file:
KEYWORD_VIRTUAL	.\c.c	/^	KEYWORD_VIRTUAL, KEYWORD_VOID, KEYWORD_VOLATILE,$/;"	e	enum:eKeywordId	file:
KEYWORD_VOID	.\c.c	/^	KEYWORD_VIRTUAL, KEYWORD_VOID, KEYWORD_VOLATILE,$/;"	e	enum:eKeywordId	file:
KEYWORD_VOLATILE	.\c.c	/^	KEYWORD_VIRTUAL, KEYWORD_VOID, KEYWORD_VOLATILE,$/;"	e	enum:eKeywordId	file:
KEYWORD_WCHAR_T	.\c.c	/^	KEYWORD_WCHAR_T, KEYWORD_WHILE$/;"	e	enum:eKeywordId	file:
KEYWORD_WHILE	.\c.c	/^	KEYWORD_WCHAR_T, KEYWORD_WHILE$/;"	e	enum:eKeywordId	file:
KEYWORD_alias	.\eiffel.c	/^	KEYWORD_alias, KEYWORD_all, KEYWORD_and, KEYWORD_as, KEYWORD_check,$/;"	e	enum:eKeywordId	file:
KEYWORD_all	.\eiffel.c	/^	KEYWORD_alias, KEYWORD_all, KEYWORD_and, KEYWORD_as, KEYWORD_check,$/;"	e	enum:eKeywordId	file:
KEYWORD_allocatable	.\fortran.c	/^	KEYWORD_allocatable,$/;"	e	enum:eKeywordId	file:
KEYWORD_and	.\eiffel.c	/^	KEYWORD_alias, KEYWORD_all, KEYWORD_and, KEYWORD_as, KEYWORD_check,$/;"	e	enum:eKeywordId	file:
KEYWORD_as	.\eiffel.c	/^	KEYWORD_alias, KEYWORD_all, KEYWORD_and, KEYWORD_as, KEYWORD_check,$/;"	e	enum:eKeywordId	file:
KEYWORD_assignment	.\fortran.c	/^	KEYWORD_assignment,$/;"	e	enum:eKeywordId	file:
KEYWORD_at	.\sql.c	/^	KEYWORD_at,$/;"	e	enum:eKeywordId	file:
KEYWORD_automatic	.\fortran.c	/^	KEYWORD_automatic,$/;"	e	enum:eKeywordId	file:
KEYWORD_begin	.\sql.c	/^	KEYWORD_begin,$/;"	e	enum:eKeywordId	file:
KEYWORD_block	.\fortran.c	/^	KEYWORD_block,$/;"	e	enum:eKeywordId	file:
KEYWORD_body	.\sql.c	/^	KEYWORD_body,$/;"	e	enum:eKeywordId	file:
KEYWORD_byte	.\fortran.c	/^	KEYWORD_byte,$/;"	e	enum:eKeywordId	file:
KEYWORD_call	.\sql.c	/^	KEYWORD_call,$/;"	e	enum:eKeywordId	file:
KEYWORD_capital_function	.\jscript.c	/^	KEYWORD_capital_function,$/;"	e	enum:eKeywordId	file:
KEYWORD_capital_object	.\jscript.c	/^	KEYWORD_capital_object,$/;"	e	enum:eKeywordId	file:
KEYWORD_case	.\sql.c	/^	KEYWORD_case,$/;"	e	enum:eKeywordId	file:
KEYWORD_catch	.\jscript.c	/^	KEYWORD_catch,$/;"	e	enum:eKeywordId	file:
KEYWORD_cexternal	.\fortran.c	/^	KEYWORD_cexternal,$/;"	e	enum:eKeywordId	file:
KEYWORD_cglobal	.\fortran.c	/^	KEYWORD_cglobal,$/;"	e	enum:eKeywordId	file:
KEYWORD_character	.\fortran.c	/^	KEYWORD_character,$/;"	e	enum:eKeywordId	file:
KEYWORD_check	.\eiffel.c	/^	KEYWORD_alias, KEYWORD_all, KEYWORD_and, KEYWORD_as, KEYWORD_check,$/;"	e	enum:eKeywordId	file:
KEYWORD_check	.\sql.c	/^	KEYWORD_check,$/;"	e	enum:eKeywordId	file:
KEYWORD_class	.\eiffel.c	/^	KEYWORD_class, KEYWORD_convert, KEYWORD_create, KEYWORD_creation, KEYWORD_Current,$/;"	e	enum:eKeywordId	file:
KEYWORD_comment	.\sql.c	/^	KEYWORD_comment,$/;"	e	enum:eKeywordId	file:
KEYWORD_common	.\fortran.c	/^	KEYWORD_common,$/;"	e	enum:eKeywordId	file:
KEYWORD_complex	.\fortran.c	/^	KEYWORD_complex,$/;"	e	enum:eKeywordId	file:
KEYWORD_constraint	.\sql.c	/^	KEYWORD_constraint,$/;"	e	enum:eKeywordId	file:
KEYWORD_contains	.\fortran.c	/^	KEYWORD_contains,$/;"	e	enum:eKeywordId	file:
KEYWORD_convert	.\eiffel.c	/^	KEYWORD_class, KEYWORD_convert, KEYWORD_create, KEYWORD_creation, KEYWORD_Current,$/;"	e	enum:eKeywordId	file:
KEYWORD_create	.\eiffel.c	/^	KEYWORD_class, KEYWORD_convert, KEYWORD_create, KEYWORD_creation, KEYWORD_Current,$/;"	e	enum:eKeywordId	file:
KEYWORD_creation	.\eiffel.c	/^	KEYWORD_class, KEYWORD_convert, KEYWORD_create, KEYWORD_creation, KEYWORD_Current,$/;"	e	enum:eKeywordId	file:
KEYWORD_cursor	.\sql.c	/^	KEYWORD_cursor,$/;"	e	enum:eKeywordId	file:
KEYWORD_data	.\fortran.c	/^	KEYWORD_data,$/;"	e	enum:eKeywordId	file:
KEYWORD_datatype	.\sql.c	/^	KEYWORD_datatype,$/;"	e	enum:eKeywordId	file:
KEYWORD_debug	.\eiffel.c	/^	KEYWORD_debug, KEYWORD_deferred, KEYWORD_do, KEYWORD_else,$/;"	e	enum:eKeywordId	file:
KEYWORD_declare	.\sql.c	/^	KEYWORD_declare,$/;"	e	enum:eKeywordId	file:
KEYWORD_deferred	.\eiffel.c	/^	KEYWORD_debug, KEYWORD_deferred, KEYWORD_do, KEYWORD_else,$/;"	e	enum:eKeywordId	file:
KEYWORD_dimension	.\fortran.c	/^	KEYWORD_dimension,$/;"	e	enum:eKeywordId	file:
KEYWORD_dllexport	.\fortran.c	/^	KEYWORD_dllexport,$/;"	e	enum:eKeywordId	file:
KEYWORD_dllimport	.\fortran.c	/^	KEYWORD_dllimport,$/;"	e	enum:eKeywordId	file:
KEYWORD_do	.\eiffel.c	/^	KEYWORD_debug, KEYWORD_deferred, KEYWORD_do, KEYWORD_else,$/;"	e	enum:eKeywordId	file:
KEYWORD_do	.\fortran.c	/^	KEYWORD_do,$/;"	e	enum:eKeywordId	file:
KEYWORD_do	.\jscript.c	/^	KEYWORD_do,$/;"	e	enum:eKeywordId	file:
KEYWORD_domain	.\sql.c	/^	KEYWORD_domain,$/;"	e	enum:eKeywordId	file:
KEYWORD_double	.\fortran.c	/^	KEYWORD_double,$/;"	e	enum:eKeywordId	file:
KEYWORD_drop	.\sql.c	/^	KEYWORD_drop,$/;"	e	enum:eKeywordId	file:
KEYWORD_elemental	.\fortran.c	/^	KEYWORD_elemental,$/;"	e	enum:eKeywordId	file:
KEYWORD_else	.\eiffel.c	/^	KEYWORD_debug, KEYWORD_deferred, KEYWORD_do, KEYWORD_else,$/;"	e	enum:eKeywordId	file:
KEYWORD_else	.\jscript.c	/^	KEYWORD_else,$/;"	e	enum:eKeywordId	file:
KEYWORD_elseif	.\eiffel.c	/^	KEYWORD_elseif, KEYWORD_end, KEYWORD_ensure, KEYWORD_expanded,$/;"	e	enum:eKeywordId	file:
KEYWORD_end	.\eiffel.c	/^	KEYWORD_elseif, KEYWORD_end, KEYWORD_ensure, KEYWORD_expanded,$/;"	e	enum:eKeywordId	file:
KEYWORD_end	.\fortran.c	/^	KEYWORD_end,$/;"	e	enum:eKeywordId	file:
KEYWORD_end	.\sql.c	/^	KEYWORD_end,$/;"	e	enum:eKeywordId	file:
KEYWORD_ensure	.\eiffel.c	/^	KEYWORD_elseif, KEYWORD_end, KEYWORD_ensure, KEYWORD_expanded,$/;"	e	enum:eKeywordId	file:
KEYWORD_entry	.\fortran.c	/^	KEYWORD_entry,$/;"	e	enum:eKeywordId	file:
KEYWORD_equivalence	.\fortran.c	/^	KEYWORD_equivalence,$/;"	e	enum:eKeywordId	file:
KEYWORD_event	.\sql.c	/^	KEYWORD_event,$/;"	e	enum:eKeywordId	file:
KEYWORD_exception	.\sql.c	/^	KEYWORD_exception,$/;"	e	enum:eKeywordId	file:
KEYWORD_expanded	.\eiffel.c	/^	KEYWORD_elseif, KEYWORD_end, KEYWORD_ensure, KEYWORD_expanded,$/;"	e	enum:eKeywordId	file:
KEYWORD_export	.\eiffel.c	/^	KEYWORD_export, KEYWORD_external, KEYWORD_false, KEYWORD_feature,$/;"	e	enum:eKeywordId	file:
KEYWORD_external	.\eiffel.c	/^	KEYWORD_export, KEYWORD_external, KEYWORD_false, KEYWORD_feature,$/;"	e	enum:eKeywordId	file:
KEYWORD_external	.\fortran.c	/^	KEYWORD_external,$/;"	e	enum:eKeywordId	file:
KEYWORD_false	.\eiffel.c	/^	KEYWORD_export, KEYWORD_external, KEYWORD_false, KEYWORD_feature,$/;"	e	enum:eKeywordId	file:
KEYWORD_feature	.\eiffel.c	/^	KEYWORD_export, KEYWORD_external, KEYWORD_false, KEYWORD_feature,$/;"	e	enum:eKeywordId	file:
KEYWORD_finally	.\jscript.c	/^	KEYWORD_finally$/;"	e	enum:eKeywordId	file:
KEYWORD_for	.\jscript.c	/^	KEYWORD_for,$/;"	e	enum:eKeywordId	file:
KEYWORD_for	.\sql.c	/^	KEYWORD_for,$/;"	e	enum:eKeywordId	file:
KEYWORD_foreign	.\sql.c	/^	KEYWORD_foreign,$/;"	e	enum:eKeywordId	file:
KEYWORD_format	.\fortran.c	/^	KEYWORD_format,$/;"	e	enum:eKeywordId	file:
KEYWORD_from	.\eiffel.c	/^	KEYWORD_from, KEYWORD_frozen, KEYWORD_if, KEYWORD_implies,$/;"	e	enum:eKeywordId	file:
KEYWORD_frozen	.\eiffel.c	/^	KEYWORD_from, KEYWORD_frozen, KEYWORD_if, KEYWORD_implies,$/;"	e	enum:eKeywordId	file:
KEYWORD_function	.\fortran.c	/^	KEYWORD_function,$/;"	e	enum:eKeywordId	file:
KEYWORD_function	.\jscript.c	/^	KEYWORD_function,$/;"	e	enum:eKeywordId	file:
KEYWORD_function	.\sql.c	/^	KEYWORD_function,$/;"	e	enum:eKeywordId	file:
KEYWORD_go	.\sql.c	/^	KEYWORD_go$/;"	e	enum:eKeywordId	file:
KEYWORD_handler	.\sql.c	/^	KEYWORD_handler,$/;"	e	enum:eKeywordId	file:
KEYWORD_if	.\eiffel.c	/^	KEYWORD_from, KEYWORD_frozen, KEYWORD_if, KEYWORD_implies,$/;"	e	enum:eKeywordId	file:
KEYWORD_if	.\fortran.c	/^	KEYWORD_if,$/;"	e	enum:eKeywordId	file:
KEYWORD_if	.\jscript.c	/^	KEYWORD_if,$/;"	e	enum:eKeywordId	file:
KEYWORD_if	.\sql.c	/^	KEYWORD_if,$/;"	e	enum:eKeywordId	file:
KEYWORD_implicit	.\fortran.c	/^	KEYWORD_implicit,$/;"	e	enum:eKeywordId	file:
KEYWORD_implies	.\eiffel.c	/^	KEYWORD_from, KEYWORD_frozen, KEYWORD_if, KEYWORD_implies,$/;"	e	enum:eKeywordId	file:
KEYWORD_include	.\fortran.c	/^	KEYWORD_include,$/;"	e	enum:eKeywordId	file:
KEYWORD_index	.\sql.c	/^	KEYWORD_index,$/;"	e	enum:eKeywordId	file:
KEYWORD_indexing	.\eiffel.c	/^	KEYWORD_indexing, KEYWORD_infix, KEYWORD_inherit, KEYWORD_inspect,$/;"	e	enum:eKeywordId	file:
KEYWORD_infix	.\eiffel.c	/^	KEYWORD_indexing, KEYWORD_infix, KEYWORD_inherit, KEYWORD_inspect,$/;"	e	enum:eKeywordId	file:
KEYWORD_inherit	.\eiffel.c	/^	KEYWORD_indexing, KEYWORD_infix, KEYWORD_inherit, KEYWORD_inspect,$/;"	e	enum:eKeywordId	file:
KEYWORD_inline	.\fortran.c	/^	KEYWORD_inline,$/;"	e	enum:eKeywordId	file:
KEYWORD_inspect	.\eiffel.c	/^	KEYWORD_indexing, KEYWORD_infix, KEYWORD_inherit, KEYWORD_inspect,$/;"	e	enum:eKeywordId	file:
KEYWORD_integer	.\fortran.c	/^	KEYWORD_integer,$/;"	e	enum:eKeywordId	file:
KEYWORD_intent	.\fortran.c	/^	KEYWORD_intent,$/;"	e	enum:eKeywordId	file:
KEYWORD_interface	.\fortran.c	/^	KEYWORD_interface,$/;"	e	enum:eKeywordId	file:
KEYWORD_intrinsic	.\fortran.c	/^	KEYWORD_intrinsic,$/;"	e	enum:eKeywordId	file:
KEYWORD_invariant	.\eiffel.c	/^	KEYWORD_invariant, KEYWORD_is, KEYWORD_like, KEYWORD_local,$/;"	e	enum:eKeywordId	file:
KEYWORD_is	.\eiffel.c	/^	KEYWORD_invariant, KEYWORD_is, KEYWORD_like, KEYWORD_local,$/;"	e	enum:eKeywordId	file:
KEYWORD_is	.\sql.c	/^	KEYWORD_is,$/;"	e	enum:eKeywordId	file:
KEYWORD_like	.\eiffel.c	/^	KEYWORD_invariant, KEYWORD_is, KEYWORD_like, KEYWORD_local,$/;"	e	enum:eKeywordId	file:
KEYWORD_local	.\eiffel.c	/^	KEYWORD_invariant, KEYWORD_is, KEYWORD_like, KEYWORD_local,$/;"	e	enum:eKeywordId	file:
KEYWORD_local	.\sql.c	/^	KEYWORD_local,$/;"	e	enum:eKeywordId	file:
KEYWORD_logical	.\fortran.c	/^	KEYWORD_logical,$/;"	e	enum:eKeywordId	file:
KEYWORD_loop	.\eiffel.c	/^	KEYWORD_loop, KEYWORD_not, KEYWORD_obsolete, KEYWORD_old, KEYWORD_once,$/;"	e	enum:eKeywordId	file:
KEYWORD_loop	.\sql.c	/^	KEYWORD_loop,$/;"	e	enum:eKeywordId	file:
KEYWORD_map	.\fortran.c	/^	KEYWORD_map,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_conn	.\sql.c	/^	KEYWORD_ml_conn,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_conn_chk	.\sql.c	/^	KEYWORD_ml_conn_chk,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_conn_dnet	.\sql.c	/^	KEYWORD_ml_conn_dnet,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_conn_java	.\sql.c	/^	KEYWORD_ml_conn_java,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_conn_lang	.\sql.c	/^	KEYWORD_ml_conn_lang,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_table	.\sql.c	/^	KEYWORD_ml_table,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_table_chk	.\sql.c	/^	KEYWORD_ml_table_chk,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_table_dnet	.\sql.c	/^	KEYWORD_ml_table_dnet,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_table_java	.\sql.c	/^	KEYWORD_ml_table_java,$/;"	e	enum:eKeywordId	file:
KEYWORD_ml_table_lang	.\sql.c	/^	KEYWORD_ml_table_lang,$/;"	e	enum:eKeywordId	file:
KEYWORD_module	.\fortran.c	/^	KEYWORD_module,$/;"	e	enum:eKeywordId	file:
KEYWORD_namelist	.\fortran.c	/^	KEYWORD_namelist,$/;"	e	enum:eKeywordId	file:
KEYWORD_new	.\jscript.c	/^	KEYWORD_new,$/;"	e	enum:eKeywordId	file:
KEYWORD_not	.\eiffel.c	/^	KEYWORD_loop, KEYWORD_not, KEYWORD_obsolete, KEYWORD_old, KEYWORD_once,$/;"	e	enum:eKeywordId	file:
KEYWORD_object	.\jscript.c	/^	KEYWORD_object,$/;"	e	enum:eKeywordId	file:
KEYWORD_object	.\sql.c	/^	KEYWORD_object,$/;"	e	enum:eKeywordId	file:
KEYWORD_obsolete	.\eiffel.c	/^	KEYWORD_loop, KEYWORD_not, KEYWORD_obsolete, KEYWORD_old, KEYWORD_once,$/;"	e	enum:eKeywordId	file:
KEYWORD_old	.\eiffel.c	/^	KEYWORD_loop, KEYWORD_not, KEYWORD_obsolete, KEYWORD_old, KEYWORD_once,$/;"	e	enum:eKeywordId	file:
KEYWORD_on	.\sql.c	/^	KEYWORD_on,$/;"	e	enum:eKeywordId	file:
KEYWORD_once	.\eiffel.c	/^	KEYWORD_loop, KEYWORD_not, KEYWORD_obsolete, KEYWORD_old, KEYWORD_once,$/;"	e	enum:eKeywordId	file:
KEYWORD_operator	.\fortran.c	/^	KEYWORD_operator,$/;"	e	enum:eKeywordId	file:
KEYWORD_optional	.\fortran.c	/^	KEYWORD_optional,$/;"	e	enum:eKeywordId	file:
KEYWORD_or	.\eiffel.c	/^	KEYWORD_or, KEYWORD_prefix, KEYWORD_redefine, KEYWORD_rename,$/;"	e	enum:eKeywordId	file:
KEYWORD_package	.\sql.c	/^	KEYWORD_package,$/;"	e	enum:eKeywordId	file:
KEYWORD_parameter	.\fortran.c	/^	KEYWORD_parameter,$/;"	e	enum:eKeywordId	file:
KEYWORD_pascal	.\fortran.c	/^	KEYWORD_pascal,$/;"	e	enum:eKeywordId	file:
KEYWORD_pexternal	.\fortran.c	/^	KEYWORD_pexternal,$/;"	e	enum:eKeywordId	file:
KEYWORD_pglobal	.\fortran.c	/^	KEYWORD_pglobal,$/;"	e	enum:eKeywordId	file:
KEYWORD_pointer	.\fortran.c	/^	KEYWORD_pointer,$/;"	e	enum:eKeywordId	file:
KEYWORD_pragma	.\sql.c	/^	KEYWORD_pragma,$/;"	e	enum:eKeywordId	file:
KEYWORD_precision	.\fortran.c	/^	KEYWORD_precision,$/;"	e	enum:eKeywordId	file:
KEYWORD_prefix	.\eiffel.c	/^	KEYWORD_or, KEYWORD_prefix, KEYWORD_redefine, KEYWORD_rename,$/;"	e	enum:eKeywordId	file:
KEYWORD_primary	.\sql.c	/^	KEYWORD_primary,$/;"	e	enum:eKeywordId	file:
KEYWORD_private	.\fortran.c	/^	KEYWORD_private,$/;"	e	enum:eKeywordId	file:
KEYWORD_procedure	.\sql.c	/^	KEYWORD_procedure,$/;"	e	enum:eKeywordId	file:
KEYWORD_program	.\fortran.c	/^	KEYWORD_program,$/;"	e	enum:eKeywordId	file:
KEYWORD_prototype	.\jscript.c	/^	KEYWORD_prototype,$/;"	e	enum:eKeywordId	file:
KEYWORD_public	.\fortran.c	/^	KEYWORD_public,$/;"	e	enum:eKeywordId	file:
KEYWORD_publication	.\sql.c	/^	KEYWORD_publication,$/;"	e	enum:eKeywordId	file:
KEYWORD_pure	.\fortran.c	/^	KEYWORD_pure,$/;"	e	enum:eKeywordId	file:
KEYWORD_real	.\fortran.c	/^	KEYWORD_real,$/;"	e	enum:eKeywordId	file:
KEYWORD_record	.\fortran.c	/^	KEYWORD_record,$/;"	e	enum:eKeywordId	file:
KEYWORD_record	.\sql.c	/^	KEYWORD_record,$/;"	e	enum:eKeywordId	file:
KEYWORD_recursive	.\fortran.c	/^	KEYWORD_recursive,$/;"	e	enum:eKeywordId	file:
KEYWORD_redefine	.\eiffel.c	/^	KEYWORD_or, KEYWORD_prefix, KEYWORD_redefine, KEYWORD_rename,$/;"	e	enum:eKeywordId	file:
KEYWORD_ref	.\sql.c	/^	KEYWORD_ref,$/;"	e	enum:eKeywordId	file:
KEYWORD_references	.\sql.c	/^	KEYWORD_references,$/;"	e	enum:eKeywordId	file:
KEYWORD_rem	.\sql.c	/^	KEYWORD_rem,$/;"	e	enum:eKeywordId	file:
KEYWORD_rename	.\eiffel.c	/^	KEYWORD_or, KEYWORD_prefix, KEYWORD_redefine, KEYWORD_rename,$/;"	e	enum:eKeywordId	file:
KEYWORD_require	.\eiffel.c	/^	KEYWORD_require, KEYWORD_rescue, KEYWORD_Result, KEYWORD_retry,$/;"	e	enum:eKeywordId	file:
KEYWORD_rescue	.\eiffel.c	/^	KEYWORD_require, KEYWORD_rescue, KEYWORD_Result, KEYWORD_retry,$/;"	e	enum:eKeywordId	file:
KEYWORD_result	.\sql.c	/^	KEYWORD_result,$/;"	e	enum:eKeywordId	file:
KEYWORD_retry	.\eiffel.c	/^	KEYWORD_require, KEYWORD_rescue, KEYWORD_Result, KEYWORD_retry,$/;"	e	enum:eKeywordId	file:
KEYWORD_return	.\sql.c	/^	KEYWORD_return,$/;"	e	enum:eKeywordId	file:
KEYWORD_returns	.\sql.c	/^	KEYWORD_returns,$/;"	e	enum:eKeywordId	file:
KEYWORD_save	.\fortran.c	/^	KEYWORD_save,$/;"	e	enum:eKeywordId	file:
KEYWORD_select	.\eiffel.c	/^	KEYWORD_select, KEYWORD_separate, KEYWORD_strip, KEYWORD_then,$/;"	e	enum:eKeywordId	file:
KEYWORD_select	.\fortran.c	/^	KEYWORD_select,$/;"	e	enum:eKeywordId	file:
KEYWORD_separate	.\eiffel.c	/^	KEYWORD_select, KEYWORD_separate, KEYWORD_strip, KEYWORD_then,$/;"	e	enum:eKeywordId	file:
KEYWORD_sequence	.\fortran.c	/^	KEYWORD_sequence,$/;"	e	enum:eKeywordId	file:
KEYWORD_service	.\sql.c	/^	KEYWORD_service,$/;"	e	enum:eKeywordId	file:
KEYWORD_static	.\fortran.c	/^	KEYWORD_static,$/;"	e	enum:eKeywordId	file:
KEYWORD_stdcall	.\fortran.c	/^	KEYWORD_stdcall,$/;"	e	enum:eKeywordId	file:
KEYWORD_strip	.\eiffel.c	/^	KEYWORD_select, KEYWORD_separate, KEYWORD_strip, KEYWORD_then,$/;"	e	enum:eKeywordId	file:
KEYWORD_structure	.\fortran.c	/^	KEYWORD_structure,$/;"	e	enum:eKeywordId	file:
KEYWORD_subroutine	.\fortran.c	/^	KEYWORD_subroutine,$/;"	e	enum:eKeywordId	file:
KEYWORD_subtype	.\sql.c	/^	KEYWORD_subtype,$/;"	e	enum:eKeywordId	file:
KEYWORD_switch	.\jscript.c	/^	KEYWORD_switch,$/;"	e	enum:eKeywordId	file:
KEYWORD_synonym	.\sql.c	/^	KEYWORD_synonym,$/;"	e	enum:eKeywordId	file:
KEYWORD_table	.\sql.c	/^	KEYWORD_table,$/;"	e	enum:eKeywordId	file:
KEYWORD_target	.\fortran.c	/^	KEYWORD_target,$/;"	e	enum:eKeywordId	file:
KEYWORD_temporary	.\sql.c	/^	KEYWORD_temporary,$/;"	e	enum:eKeywordId	file:
KEYWORD_then	.\eiffel.c	/^	KEYWORD_select, KEYWORD_separate, KEYWORD_strip, KEYWORD_then,$/;"	e	enum:eKeywordId	file:
KEYWORD_then	.\fortran.c	/^	KEYWORD_then,$/;"	e	enum:eKeywordId	file:
KEYWORD_then	.\sql.c	/^	KEYWORD_then,$/;"	e	enum:eKeywordId	file:
KEYWORD_this	.\jscript.c	/^	KEYWORD_this,$/;"	e	enum:eKeywordId	file:
KEYWORD_trigger	.\sql.c	/^	KEYWORD_trigger,$/;"	e	enum:eKeywordId	file:
KEYWORD_true	.\eiffel.c	/^	KEYWORD_true, KEYWORD_undefine, KEYWORD_unique, KEYWORD_until,$/;"	e	enum:eKeywordId	file:
KEYWORD_try	.\jscript.c	/^	KEYWORD_try,$/;"	e	enum:eKeywordId	file:
KEYWORD_type	.\fortran.c	/^	KEYWORD_type,$/;"	e	enum:eKeywordId	file:
KEYWORD_type	.\sql.c	/^	KEYWORD_type,$/;"	e	enum:eKeywordId	file:
KEYWORD_undefine	.\eiffel.c	/^	KEYWORD_true, KEYWORD_undefine, KEYWORD_unique, KEYWORD_until,$/;"	e	enum:eKeywordId	file:
KEYWORD_union	.\fortran.c	/^	KEYWORD_union,$/;"	e	enum:eKeywordId	file:
KEYWORD_unique	.\eiffel.c	/^	KEYWORD_true, KEYWORD_undefine, KEYWORD_unique, KEYWORD_until,$/;"	e	enum:eKeywordId	file:
KEYWORD_unique	.\sql.c	/^	KEYWORD_unique,$/;"	e	enum:eKeywordId	file:
KEYWORD_until	.\eiffel.c	/^	KEYWORD_true, KEYWORD_undefine, KEYWORD_unique, KEYWORD_until,$/;"	e	enum:eKeywordId	file:
KEYWORD_use	.\fortran.c	/^	KEYWORD_use,$/;"	e	enum:eKeywordId	file:
KEYWORD_value	.\fortran.c	/^	KEYWORD_value,$/;"	e	enum:eKeywordId	file:
KEYWORD_var	.\jscript.c	/^	KEYWORD_var,$/;"	e	enum:eKeywordId	file:
KEYWORD_variable	.\sql.c	/^	KEYWORD_variable,$/;"	e	enum:eKeywordId	file:
KEYWORD_variant	.\eiffel.c	/^	KEYWORD_variant, KEYWORD_when, KEYWORD_xor$/;"	e	enum:eKeywordId	file:
KEYWORD_view	.\sql.c	/^	KEYWORD_view,$/;"	e	enum:eKeywordId	file:
KEYWORD_virtual	.\fortran.c	/^	KEYWORD_virtual,$/;"	e	enum:eKeywordId	file:
KEYWORD_volatile	.\fortran.c	/^	KEYWORD_volatile,$/;"	e	enum:eKeywordId	file:
KEYWORD_when	.\eiffel.c	/^	KEYWORD_variant, KEYWORD_when, KEYWORD_xor$/;"	e	enum:eKeywordId	file:
KEYWORD_when	.\sql.c	/^	KEYWORD_when,$/;"	e	enum:eKeywordId	file:
KEYWORD_where	.\fortran.c	/^	KEYWORD_where,$/;"	e	enum:eKeywordId	file:
KEYWORD_while	.\fortran.c	/^	KEYWORD_while$/;"	e	enum:eKeywordId	file:
KEYWORD_while	.\jscript.c	/^	KEYWORD_while,$/;"	e	enum:eKeywordId	file:
KEYWORD_xor	.\eiffel.c	/^	KEYWORD_variant, KEYWORD_when, KEYWORD_xor$/;"	e	enum:eKeywordId	file:
KIND_COUNT	.\parse.h	24;"	d
K_AND	.\sml.c	/^	K_AND = -2,$/;"	e	enum:__anon69	file:
K_AUGROUP	.\vim.c	/^	K_AUGROUP,$/;"	e	enum:__anon75	file:
K_CLASS	.\php.c	/^	K_CLASS, K_DEFINE, K_FUNCTION, K_VARIABLE$/;"	e	enum:__anon41	file:
K_CLASS	.\python.c	/^	K_CLASS, K_FUNCTION, K_MEMBER$/;"	e	enum:__anon42	file:
K_CLASS	.\ruby.c	/^	K_UNDEFINED = -1, K_CLASS, K_METHOD, K_MODULE, K_SINGLETON$/;"	e	enum:__anon66	file:
K_CLASS	.\tcl.c	/^	K_CLASS, K_METHOD, K_PROCEDURE$/;"	e	enum:__anon72	file:
K_COMMAND	.\vim.c	/^	K_COMMAND,$/;"	e	enum:__anon75	file:
K_CONST	.\asp.c	/^	K_CONST, K_FUNCTION, K_SUB, K_DIM$/;"	e	enum:__anon7	file:
K_CONST	.\basic.c	/^	K_CONST,$/;"	e	enum:__anon8	file:
K_CONSTANT	.\perl.c	/^	K_CONSTANT,$/;"	e	enum:__anon40	file:
K_CONSTANT	.\verilog.c	/^	K_CONSTANT,$/;"	e	enum:__anon73	file:
K_DEFINE	.\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon3	file:
K_DEFINE	.\php.c	/^	K_CLASS, K_DEFINE, K_FUNCTION, K_VARIABLE$/;"	e	enum:__anon41	file:
K_DEFINE	.\whatever\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon76	file:
K_DIM	.\asp.c	/^	K_CONST, K_FUNCTION, K_SUB, K_DIM$/;"	e	enum:__anon7	file:
K_ENUM	.\basic.c	/^	K_ENUM$/;"	e	enum:__anon8	file:
K_EVENT	.\verilog.c	/^	K_EVENT,$/;"	e	enum:__anon73	file:
K_EXCEPTION	.\sml.c	/^	K_EXCEPTION,$/;"	e	enum:__anon69	file:
K_FORMAT	.\perl.c	/^	K_FORMAT,$/;"	e	enum:__anon40	file:
K_FRAGMENT	.\beta.c	/^	K_FRAGMENT, K_PATTERN, K_SLOT, K_VIRTUAL$/;"	e	enum:__anon10	file:
K_FUNCTION	.\asp.c	/^	K_CONST, K_FUNCTION, K_SUB, K_DIM$/;"	e	enum:__anon7	file:
K_FUNCTION	.\awk.c	/^	K_FUNCTION$/;"	e	enum:eAwkKinds	file:
K_FUNCTION	.\basic.c	/^	K_FUNCTION,$/;"	e	enum:__anon8	file:
K_FUNCTION	.\erlang.c	/^	K_MACRO, K_FUNCTION, K_MODULE, K_RECORD$/;"	e	enum:__anon18	file:
K_FUNCTION	.\lisp.c	/^	K_FUNCTION$/;"	e	enum:__anon25	file:
K_FUNCTION	.\lua.c	/^	K_FUNCTION$/;"	e	enum:__anon31	file:
K_FUNCTION	.\pascal.c	/^	K_FUNCTION, K_PROCEDURE$/;"	e	enum:__anon39	file:
K_FUNCTION	.\php.c	/^	K_CLASS, K_DEFINE, K_FUNCTION, K_VARIABLE$/;"	e	enum:__anon41	file:
K_FUNCTION	.\python.c	/^	K_CLASS, K_FUNCTION, K_MEMBER$/;"	e	enum:__anon42	file:
K_FUNCTION	.\scheme.c	/^	K_FUNCTION, K_SET$/;"	e	enum:__anon67	file:
K_FUNCTION	.\sh.c	/^	K_FUNCTION$/;"	e	enum:__anon68	file:
K_FUNCTION	.\sml.c	/^	K_FUNCTION,$/;"	e	enum:__anon69	file:
K_FUNCTION	.\verilog.c	/^	K_FUNCTION,$/;"	e	enum:__anon73	file:
K_FUNCTION	.\vim.c	/^	K_FUNCTION,$/;"	e	enum:__anon75	file:
K_FUNCTOR	.\sml.c	/^	K_FUNCTOR,$/;"	e	enum:__anon69	file:
K_LABEL	.\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon3	file:
K_LABEL	.\basic.c	/^	K_LABEL,$/;"	e	enum:__anon8	file:
K_LABEL	.\perl.c	/^	K_LABEL,$/;"	e	enum:__anon40	file:
K_LABEL	.\whatever\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon76	file:
K_MACRO	.\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon3	file:
K_MACRO	.\erlang.c	/^	K_MACRO, K_FUNCTION, K_MODULE, K_RECORD$/;"	e	enum:__anon18	file:
K_MACRO	.\make.c	/^	K_MACRO$/;"	e	enum:__anon33	file:
K_MACRO	.\whatever\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon76	file:
K_MAP	.\vim.c	/^	K_MAP,$/;"	e	enum:__anon75	file:
K_MEMBER	.\python.c	/^	K_CLASS, K_FUNCTION, K_MEMBER$/;"	e	enum:__anon42	file:
K_METHOD	.\ruby.c	/^	K_UNDEFINED = -1, K_CLASS, K_METHOD, K_MODULE, K_SINGLETON$/;"	e	enum:__anon66	file:
K_METHOD	.\tcl.c	/^	K_CLASS, K_METHOD, K_PROCEDURE$/;"	e	enum:__anon72	file:
K_MODULE	.\erlang.c	/^	K_MACRO, K_FUNCTION, K_MODULE, K_RECORD$/;"	e	enum:__anon18	file:
K_MODULE	.\ruby.c	/^	K_UNDEFINED = -1, K_CLASS, K_METHOD, K_MODULE, K_SINGLETON$/;"	e	enum:__anon66	file:
K_MODULE	.\verilog.c	/^	K_MODULE,$/;"	e	enum:__anon73	file:
K_NET	.\verilog.c	/^	K_NET,$/;"	e	enum:__anon73	file:
K_NONE	.\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon3	file:
K_NONE	.\perl.c	/^	K_NONE = -1,$/;"	e	enum:__anon40	file:
K_NONE	.\sml.c	/^	K_NONE = -1,$/;"	e	enum:__anon69	file:
K_NONE	.\whatever\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon76	file:
K_PACKAGE	.\perl.c	/^	K_PACKAGE,$/;"	e	enum:__anon40	file:
K_PATTERN	.\beta.c	/^	K_FRAGMENT, K_PATTERN, K_SLOT, K_VIRTUAL$/;"	e	enum:__anon10	file:
K_PORT	.\verilog.c	/^	K_PORT,$/;"	e	enum:__anon73	file:
K_PROCEDURE	.\pascal.c	/^	K_FUNCTION, K_PROCEDURE$/;"	e	enum:__anon39	file:
K_PROCEDURE	.\tcl.c	/^	K_CLASS, K_METHOD, K_PROCEDURE$/;"	e	enum:__anon72	file:
K_RECORD	.\erlang.c	/^	K_MACRO, K_FUNCTION, K_MODULE, K_RECORD$/;"	e	enum:__anon18	file:
K_REGISTER	.\verilog.c	/^	K_REGISTER,$/;"	e	enum:__anon73	file:
K_SET	.\scheme.c	/^	K_FUNCTION, K_SET$/;"	e	enum:__anon67	file:
K_SIGNATURE	.\sml.c	/^	K_SIGNATURE,$/;"	e	enum:__anon69	file:
K_SINGLETON	.\ruby.c	/^	K_UNDEFINED = -1, K_CLASS, K_METHOD, K_MODULE, K_SINGLETON$/;"	e	enum:__anon66	file:
K_SLOT	.\beta.c	/^	K_FRAGMENT, K_PATTERN, K_SLOT, K_VIRTUAL$/;"	e	enum:__anon10	file:
K_STRUCTURE	.\sml.c	/^	K_STRUCTURE,$/;"	e	enum:__anon69	file:
K_SUB	.\asp.c	/^	K_CONST, K_FUNCTION, K_SUB, K_DIM$/;"	e	enum:__anon7	file:
K_SUBROUTINE	.\perl.c	/^	K_SUBROUTINE,$/;"	e	enum:__anon40	file:
K_SUBROUTINE_DECLARATION	.\perl.c	/^	K_SUBROUTINE_DECLARATION$/;"	e	enum:__anon40	file:
K_TASK	.\verilog.c	/^	K_TASK$/;"	e	enum:__anon73	file:
K_TYPE	.\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon3	file:
K_TYPE	.\basic.c	/^	K_TYPE,$/;"	e	enum:__anon8	file:
K_TYPE	.\sml.c	/^	K_TYPE,$/;"	e	enum:__anon69	file:
K_TYPE	.\whatever\asm.c	/^	K_NONE = -1, K_DEFINE, K_LABEL, K_MACRO, K_TYPE$/;"	e	enum:__anon76	file:
K_UNDEFINED	.\ruby.c	/^	K_UNDEFINED = -1, K_CLASS, K_METHOD, K_MODULE, K_SINGLETON$/;"	e	enum:__anon66	file:
K_UNDEFINED	.\verilog.c	/^	K_UNDEFINED = -1,$/;"	e	enum:__anon73	file:
K_VAL	.\sml.c	/^	K_VAL$/;"	e	enum:__anon69	file:
K_VARIABLE	.\basic.c	/^	K_VARIABLE,$/;"	e	enum:__anon8	file:
K_VARIABLE	.\php.c	/^	K_CLASS, K_DEFINE, K_FUNCTION, K_VARIABLE$/;"	e	enum:__anon41	file:
K_VARIABLE	.\vim.c	/^	K_VARIABLE$/;"	e	enum:__anon75	file:
K_VIRTUAL	.\beta.c	/^	K_FRAGMENT, K_PATTERN, K_SLOT, K_VIRTUAL$/;"	e	enum:__anon10	file:
KeyWord	.\basic.c	/^} KeyWord;$/;"	t	typeref:struct:__anon9	file:
KeywordTable	.\c.c	/^static const keywordDesc KeywordTable [] = {$/;"	v	file:
LANG_AUTO	.\parse.h	26;"	d
LANG_IGNORE	.\parse.h	27;"	d
LD	.\mk_mpw.mak	/^LD			= mwlinkppc$/;"	m
LD	.\mk_qdos.mak	/^LD  = $(P)ld$/;"	m
LDFLAGS	.\mk_bc5.mak	/^LDFLAGS = -tWCR$/;"	m
LDFLAGS	.\mk_ming.mak	/^ctags.exe: LDFLAGS = -s$/;"	m
LDFLAGS	.\mk_qdos.mak	/^LDFLAGS  = -v -L$(P)lib_ -bufp150K\\$/;"	m
LFLAGS	.\mk_bc3.mak	/^LFLAGS	= $(LIB) $(EXTRA)$/;"	m
LIB	.\mk_bc3.mak	/^LIB	= -L$(BCCLOC)\\lib$/;"	m
LIBS	.\mk_mpw.mak	/^LIBS = ¶$/;"	m
LIBS	.\mk_qdos.mak	/^LIBS =$/;"	m
LN_DEBUG	.\mk_manx.mak	/^LN_DEBUG =$/;"	m
LOptions	.\mk_mpw.mak	/^LOptions	= -xm m -stacksize 128$/;"	m
LTYPE_COMMENT	.\fortran.c	/^	LTYPE_COMMENT,$/;"	e	enum:eFortranLineType	file:
LTYPE_CONTINUATION	.\fortran.c	/^	LTYPE_CONTINUATION,$/;"	e	enum:eFortranLineType	file:
LTYPE_EOF	.\fortran.c	/^	LTYPE_EOF,$/;"	e	enum:eFortranLineType	file:
LTYPE_INITIAL	.\fortran.c	/^	LTYPE_INITIAL,$/;"	e	enum:eFortranLineType	file:
LTYPE_INVALID	.\fortran.c	/^	LTYPE_INVALID,$/;"	e	enum:eFortranLineType	file:
LTYPE_SHORT	.\fortran.c	/^	LTYPE_SHORT$/;"	e	enum:eFortranLineType	file:
LTYPE_UNDETERMINED	.\fortran.c	/^	LTYPE_UNDETERMINED,$/;"	e	enum:eFortranLineType	file:
L_getit	.\lisp.c	/^static void L_getit (vString *const name, const unsigned char *dbp)$/;"	f	file:
L_isdef	.\lisp.c	/^static int L_isdef (const unsigned char *strp)$/;"	f	file:
L_isquote	.\lisp.c	/^static int L_isquote (const unsigned char *strp)$/;"	f	file:
Lang_asm	.\asm.c	/^static langType Lang_asm;$/;"	v	file:
Lang_asm	.\whatever\asm.c	/^static langType Lang_asm;$/;"	v	file:
Lang_c	.\c.c	/^static langType Lang_c;$/;"	v	file:
Lang_cpp	.\c.c	/^static langType Lang_cpp;$/;"	v	file:
Lang_csharp	.\c.c	/^static langType Lang_csharp;$/;"	v	file:
Lang_eiffel	.\eiffel.c	/^static langType Lang_eiffel;$/;"	v	file:
Lang_fortran	.\fortran.c	/^static langType Lang_fortran;$/;"	v	file:
Lang_java	.\c.c	/^static langType Lang_java;$/;"	v	file:
Lang_js	.\jscript.c	/^static langType Lang_js;$/;"	v	file:
Lang_sql	.\sql.c	/^static langType Lang_sql;$/;"	v	file:
Lang_vera	.\c.c	/^static langType Lang_vera;$/;"	v	file:
Lang_verilog	.\verilog.c	/^static int Lang_verilog;$/;"	v	file:
LanguageCount	.\parse.c	/^static unsigned int LanguageCount = 0;$/;"	v	file:
LanguageTable	.\parse.c	/^static parserDefinition** LanguageTable = NULL;$/;"	v	file:
License1	.\options.c	/^static const char* const License1 =$/;"	v	file:
License2	.\options.c	/^static const char* const License2 =$/;"	v	file:
LispKinds	.\lisp.c	/^static kindOption LispKinds [] = {$/;"	v	file:
LispParser	.\lisp.c	/^extern parserDefinition* LispParser (void)$/;"	f
LongOptionDescription	.\options.c	/^static optionDescription LongOptionDescription [] = {$/;"	v	file:
LuaKinds	.\lua.c	/^static kindOption LuaKinds [] = {$/;"	v	file:
LuaParser	.\lua.c	/^extern parserDefinition* LuaParser (void)$/;"	f
MACROS_USE_PATTERNS	.\e_mac.h	20;"	d
MACROS_USE_PATTERNS	.\e_riscos.h	20;"	d
MANUAL_GLOBBING	.\e_msoft.h	20;"	d
MATCHED_SOMETHING	.\regex.c	3027;"	d	file:
MATCHING_IN_FIRST_STRING	.\regex.c	3060;"	d	file:
MATCH_NULL_UNSET_VALUE	.\regex.c	3017;"	d	file:
MAX	.\regex.c	233;"	d	file:
MAX_BUF_SIZE	.\regex.c	934;"	d	file:
MAX_FAILURE_ITEMS	.\regex.c	2438;"	d	file:
MAX_REGNUM	.\regex.c	970;"	d	file:
MIN	.\regex.c	234;"	d	file:
MOTIVATION	.\ctags.html	/^<a name="MOTIVATION"><\/a>$/;"	a
MSDOS_STYLE_PATH	.\e_djgpp.h	15;"	d
MSDOS_STYLE_PATH	.\e_msoft.h	21;"	d
MakeKinds	.\make.c	/^static kindOption MakeKinds [] = {$/;"	v	file:
MakefileParser	.\make.c	/^extern parserDefinition* MakefileParser (void)$/;"	f
MaxCppNestingLevel	.\get.c	/^	MaxCppNestingLevel = 20,$/;"	e	enum:eCppLimits	file:
MaxDirectiveName	.\get.c	/^	MaxDirectiveName = 10$/;"	e	enum:eCppLimits	file:
MaxHeaderExtensions	.\options.c	/^	MaxHeaderExtensions	= 100,  \/* maximum number of extensions in -h option *\/$/;"	e	enum:eOptionLimits	file:
MaxSupportedTagFormat	.\options.c	/^	MaxSupportedTagFormat = 2$/;"	e	enum:eOptionLimits	file:
NAME	.\ctags.html	/^<a name="NAME"><\/a>$/;"	a
NDEBUG	.\debug.h	38;"	d
NEED_PROTO_FGETPOS	.\e_msoft.h	64;"	d
NEED_PROTO_LSTAT	.\e_djgpp.h	44;"	d
NEED_PROTO_TRUNCATE	.\e_mac.h	24;"	d
NEWLINE	.\read.h	/^	NEWLINE       = '\\n',$/;"	e	enum:eCharacters
NON_CONST_PUTENV_PROTOTYPE	.\e_qdos.h	32;"	d
NO_HIGHEST_ACTIVE_REG	.\regex.c	3127;"	d	file:
NO_LOWEST_ACTIVE_REG	.\regex.c	3128;"	d	file:
NULL	.\regex.c	157;"	d	file:
NULL	.\regex.c	45;"	d	file:
NUM_FAILURE_ITEMS	.\regex.c	2441;"	d	file:
NUM_NONREG_ITEMS	.\regex.c	2432;"	d	file:
NUM_NONREG_ITEMS	.\regex.c	2434;"	d	file:
NUM_REG_ITEMS	.\regex.c	2428;"	d	file:
NavigateToDefinition	.\ctags_plugin.py	/^class NavigateToDefinition(sublimeplugin.TextCommand):$/;"	c
NestingLevel	.\python.c	/^struct NestingLevel$/;"	s	file:
NestingLevel	.\python.c	/^typedef struct NestingLevel NestingLevel;$/;"	t	typeref:struct:NestingLevel	file:
NestingLevels	.\python.c	/^struct NestingLevels$/;"	s	file:
NestingLevels	.\python.c	/^typedef struct NestingLevels NestingLevels;$/;"	t	typeref:struct:NestingLevels	file:
NonOptionEncountered	.\options.c	/^static boolean NonOptionEncountered;$/;"	v	file:
NumTokens	.\c.c	/^enum { NumTokens = 3 };$/;"	e	enum:__anon11	file:
OBJ	.\mk_mpw.mak	/^OBJ = ¶$/;"	m
OBJECTS	.\mk_manx.mak	/^OBJECTS = \\$/;"	m
OBJECTS	.\mk_qdos.mak	/^OBJECTS = qdos.$(OBJEXT) \\$/;"	m
OBJECTS	.\mk_sas.mak	/^OBJECTS = \\$/;"	m
OBJECTS	.\source.mak	/^OBJECTS = \\$/;"	m
OBJEXT	.\mk_manx.mak	/^OBJEXT = o$/;"	m
OBJEXT	.\mk_qdos.mak	/^OBJEXT = o$/;"	m
OBJEXT	.\mk_sas.mak	/^OBJEXT = o$/;"	m
OPERATIONAL DETAILS	.\ctags.html	/^<a name="OPERATIONAL DETAILS"><\/a>$/;"	a
OPT	.\mk_bc5.mak	/^OPT = -O2 -OS -lGt$/;"	m
OPT	.\mk_ming.mak	/^ctags.exe: OPT = -O4$/;"	m
OPT	.\mk_ming.mak	/^dctags.exe: OPT = -g$/;"	m
OPT	.\mk_mvc.mak	/^OPT = \/O2$/;"	m
OPTIMIZE	.\mk_bc3.mak	/^OPTIMIZE= -1- -O1$/;"	m
OPTIONS	.\ctags.html	/^<a name="OPTIONS"><\/a>$/;"	a
OPTIONS	.\mk_manx.mak	/^OPTIONS = -so$/;"	m
OPTION_LONG	.\options.h	/^typedef enum { OPTION_NONE, OPTION_SHORT, OPTION_LONG } optionType;$/;"	e	enum:__anon36
OPTION_NONE	.\options.h	/^typedef enum { OPTION_NONE, OPTION_SHORT, OPTION_LONG } optionType;$/;"	e	enum:__anon36
OPTION_SHORT	.\options.h	/^typedef enum { OPTION_NONE, OPTION_SHORT, OPTION_LONG } optionType;$/;"	e	enum:__anon36
OPTION_WRITE	.\options.c	25;"	d	file:
OPTION_WRITE	.\parse.c	23;"	d	file:
OP_ALIGN	.\asm.c	/^	OP_ALIGN,$/;"	e	enum:__anon4	file:
OP_ALIGN	.\whatever\asm.c	/^	OP_ALIGN,$/;"	e	enum:__anon77	file:
OP_COLON_EQUAL	.\asm.c	/^	OP_COLON_EQUAL,$/;"	e	enum:__anon4	file:
OP_COLON_EQUAL	.\whatever\asm.c	/^	OP_COLON_EQUAL,$/;"	e	enum:__anon77	file:
OP_END	.\asm.c	/^	OP_END,$/;"	e	enum:__anon4	file:
OP_END	.\whatever\asm.c	/^	OP_END,$/;"	e	enum:__anon77	file:
OP_ENDM	.\asm.c	/^	OP_ENDM,$/;"	e	enum:__anon4	file:
OP_ENDM	.\whatever\asm.c	/^	OP_ENDM,$/;"	e	enum:__anon77	file:
OP_ENDMACRO	.\asm.c	/^	OP_ENDMACRO,$/;"	e	enum:__anon4	file:
OP_ENDMACRO	.\whatever\asm.c	/^	OP_ENDMACRO,$/;"	e	enum:__anon77	file:
OP_ENDP	.\asm.c	/^	OP_ENDP,$/;"	e	enum:__anon4	file:
OP_ENDP	.\whatever\asm.c	/^	OP_ENDP,$/;"	e	enum:__anon77	file:
OP_ENDS	.\asm.c	/^	OP_ENDS,$/;"	e	enum:__anon4	file:
OP_ENDS	.\whatever\asm.c	/^	OP_ENDS,$/;"	e	enum:__anon77	file:
OP_EQU	.\asm.c	/^	OP_EQU,$/;"	e	enum:__anon4	file:
OP_EQU	.\whatever\asm.c	/^	OP_EQU,$/;"	e	enum:__anon77	file:
OP_EQUAL	.\asm.c	/^	OP_EQUAL,$/;"	e	enum:__anon4	file:
OP_EQUAL	.\whatever\asm.c	/^	OP_EQUAL,$/;"	e	enum:__anon77	file:
OP_LABEL	.\asm.c	/^	OP_LABEL,$/;"	e	enum:__anon4	file:
OP_LABEL	.\whatever\asm.c	/^	OP_LABEL,$/;"	e	enum:__anon77	file:
OP_LAST	.\asm.c	/^	OP_LAST$/;"	e	enum:__anon4	file:
OP_LAST	.\whatever\asm.c	/^	OP_LAST$/;"	e	enum:__anon77	file:
OP_MACRO	.\asm.c	/^	OP_MACRO,$/;"	e	enum:__anon4	file:
OP_MACRO	.\whatever\asm.c	/^	OP_MACRO,$/;"	e	enum:__anon77	file:
OP_PROC	.\asm.c	/^	OP_PROC,$/;"	e	enum:__anon4	file:
OP_PROC	.\whatever\asm.c	/^	OP_PROC,$/;"	e	enum:__anon77	file:
OP_RECORD	.\asm.c	/^	OP_RECORD,$/;"	e	enum:__anon4	file:
OP_RECORD	.\whatever\asm.c	/^	OP_RECORD,$/;"	e	enum:__anon77	file:
OP_SECTIONS	.\asm.c	/^	OP_SECTIONS,$/;"	e	enum:__anon4	file:
OP_SECTIONS	.\whatever\asm.c	/^	OP_SECTIONS,$/;"	e	enum:__anon77	file:
OP_SET	.\asm.c	/^	OP_SET,$/;"	e	enum:__anon4	file:
OP_SET	.\whatever\asm.c	/^	OP_SET,$/;"	e	enum:__anon77	file:
OP_STRUCT	.\asm.c	/^	OP_STRUCT,$/;"	e	enum:__anon4	file:
OP_STRUCT	.\whatever\asm.c	/^	OP_STRUCT,$/;"	e	enum:__anon77	file:
OP_UNDEFINED	.\asm.c	/^	OP_UNDEFINED = -1,$/;"	e	enum:__anon4	file:
OP_UNDEFINED	.\whatever\asm.c	/^	OP_UNDEFINED = -1,$/;"	e	enum:__anon77	file:
OUTPUT_PATH_SEPARATOR	.\routines.h	40;"	d
OUTPUT_PATH_SEPARATOR	.\routines.h	42;"	d
O_RDWR	.\entry.c	71;"	d	file:
OpKinds	.\asm.c	/^static const opKind OpKinds [] = {$/;"	v	file:
OpKinds	.\whatever\asm.c	/^static const opKind OpKinds [] = {$/;"	v	file:
Option	.\options.c	/^optionValues Option = {$/;"	v
OptionFiles	.\options.c	/^static stringList *OptionFiles;$/;"	v	file:
P	.\mk_qdos.mak	/^P = drv1_C68_$/;"	m
PARSER_LIST	.\parsers.h	18;"	d
PATFETCH	.\regex.c	852;"	d	file:
PATFETCH_RAW	.\regex.c	860;"	d	file:
PATH_MAX	.\e_mac.h	104;"	d
PATH_MAX	.\routines.c	130;"	d	file:
PATH_MAX	.\routines.c	132;"	d	file:
PATH_MAX	.\routines.c	142;"	d	file:
PATH_SEPARATOR	.\routines.h	31;"	d
PATH_SEPARATOR	.\routines.h	33;"	d
PATH_SEPARATOR	.\routines.h	35;"	d
PATTERN_START	.\options.c	48;"	d	file:
PATTERN_STOP	.\options.c	49;"	d	file:
PATUNFETCH	.\regex.c	866;"	d	file:
PERROR	.\routines.h	/^enum eErrorTypes { FATAL = 1, WARNING = 2, PERROR = 4 };$/;"	e	enum:eErrorTypes
PE_CONST	.\sort.c	51;"	d	file:
PE_CONST	.\sort.c	53;"	d	file:
POINTER_TO_OFFSET	.\regex.c	3050;"	d	file:
POP_FAILURE_ITEM	.\regex.c	2331;"	d	file:
POP_FAILURE_POINT	.\regex.c	2461;"	d	file:
POSIX_REGEX	.\lregex.c	48;"	d	file:
POSSIBLE_ATTRIBUTES	.\html.c	25;"	d	file:
PREFETCH	.\regex.c	3064;"	d	file:
PROGRAM_COPYRIGHT	.\ctags.h	22;"	d
PROGRAM_NAME	.\ctags.h	20;"	d
PROGRAM_URL	.\ctags.h	21;"	d
PROGRAM_VERSION	.\ctags.h	18;"	d
PSEUDO_TAG_PREFIX	.\entry.c	54;"	d	file:
PTRN_CALLBACK	.\lregex.c	/^enum pType { PTRN_TAG, PTRN_CALLBACK };$/;"	e	enum:pType	file:
PTRN_TAG	.\lregex.c	/^enum pType { PTRN_TAG, PTRN_CALLBACK };$/;"	e	enum:pType	file:
PUSH_FAILURE_ITEM	.\regex.c	2327;"	d	file:
PUSH_FAILURE_POINT	.\regex.c	2352;"	d	file:
PUSH_PATTERN_OP	.\regex.c	2317;"	d	file:
ParametricOptions	.\options.c	/^static parametricOption ParametricOptions [] = {$/;"	v	file:
Parent	.\fortran.c	/^static tokenInfo *Parent;$/;"	v	file:
ParsingString	.\fortran.c	/^static boolean ParsingString;$/;"	v	file:
PascalKinds	.\pascal.c	/^static kindOption PascalKinds [] = {$/;"	v	file:
PascalParser	.\pascal.c	/^extern parserDefinition* PascalParser (void)$/;"	f
PathDelimiters	.\routines.c	/^const char *const PathDelimiters = ":\/\\\\";$/;"	v
PathDelimiters	.\routines.c	/^const char *const PathDelimiters = ":]>";$/;"	v
PerlKinds	.\perl.c	/^static kindOption PerlKinds [] = {$/;"	v	file:
PerlParser	.\perl.c	/^extern parserDefinition* PerlParser (void)$/;"	f
PhpParser	.\php.c	/^extern parserDefinition* PhpParser (void)$/;"	f
PrintClass	.\eiffel.c	/^static int PrintClass;$/;"	v	file:
PrintReferences	.\eiffel.c	/^static int PrintReferences;$/;"	v	file:
PrintStatus	.\debug.h	31;"	d
PrintStatus	.\debug.h	35;"	d
ProgramName	.\readtags.c	/^static const char *ProgramName;$/;"	v	file:
PseudoTagPrefix	.\readtags.c	/^const char *const PseudoTagPrefix = "!_";$/;"	v
PythonKinds	.\python.c	/^static kindOption PythonKinds[] = {$/;"	v	file:
PythonParser	.\python.c	/^extern parserDefinition *PythonParser (void)$/;"	f
READTAGS_H	.\readtags.h	22;"	d
RECURSE_SUPPORTED	.\options.c	57;"	d	file:
REGEX_ALLOCATE	.\regex.c	184;"	d	file:
REGEX_ALLOCATE	.\regex.c	207;"	d	file:
REGEX_DEFINE	.\mk_bc5.mak	/^REGEX_DEFINE = -DHAVE_REGCOMP -DREGEX_MALLOC -DSTDC_HEADERS=1$/;"	m
REGEX_DEFINE	.\mk_bc5.mak	/^REGEX_DEFINE = -DHAVE_REGCOMP$/;"	m
REGEX_DEFINE	.\mk_mvc.mak	/^REGEX_DEFINE = -DHAVE_REGCOMP -DREGEX_MALLOC -DSTDC_HEADERS=1$/;"	m
REGEX_NAME	.\lregex.c	51;"	d	file:
REGEX_REALLOCATE	.\regex.c	185;"	d	file:
REGEX_REALLOCATE	.\regex.c	210;"	d	file:
REGEX_TALLOC	.\regex.c	227;"	d	file:
REGS_FIXED	.\regex.h	322;"	d
REGS_REALLOCATE	.\regex.h	321;"	d
REGS_UNALLOCATED	.\regex.h	320;"	d
REG_BADBR	.\regex.h	/^  REG_BADBR,		\/* Invalid contents of \\{\\}.  *\/$/;"	e	enum:__anon63
REG_BADPAT	.\regex.h	/^  REG_BADPAT,		\/* Invalid pattern.  *\/$/;"	e	enum:__anon63
REG_BADRPT	.\regex.h	/^  REG_BADRPT,		\/* No preceding re for repetition op.  *\/$/;"	e	enum:__anon63
REG_EBRACE	.\regex.h	/^  REG_EBRACE,		\/* Unmatched \\{.  *\/$/;"	e	enum:__anon63
REG_EBRACK	.\regex.h	/^  REG_EBRACK,		\/* Unmatched left bracket.  *\/$/;"	e	enum:__anon63
REG_ECOLLATE	.\regex.h	/^  REG_ECOLLATE,		\/* Not implemented.  *\/$/;"	e	enum:__anon63
REG_ECTYPE	.\regex.h	/^  REG_ECTYPE,		\/* Invalid character class name.  *\/$/;"	e	enum:__anon63
REG_EEND	.\regex.h	/^  REG_EEND,		\/* Premature end.  *\/$/;"	e	enum:__anon63
REG_EESCAPE	.\regex.h	/^  REG_EESCAPE,		\/* Trailing backslash.  *\/$/;"	e	enum:__anon63
REG_EPAREN	.\regex.h	/^  REG_EPAREN,		\/* Parenthesis imbalance.  *\/ $/;"	e	enum:__anon63
REG_ERANGE	.\regex.h	/^  REG_ERANGE,		\/* Invalid range end.  *\/$/;"	e	enum:__anon63
REG_ERPAREN	.\regex.h	/^  REG_ERPAREN		\/* Unmatched ) or \\); not returned from regcomp.  *\/$/;"	e	enum:__anon63
REG_ESIZE	.\regex.h	/^  REG_ESIZE,		\/* Compiled pattern bigger than 2^16 bytes.  *\/$/;"	e	enum:__anon63
REG_ESPACE	.\regex.h	/^  REG_ESPACE,		\/* Ran out of memory.  *\/$/;"	e	enum:__anon63
REG_ESUBREG	.\regex.h	/^  REG_ESUBREG,		\/* Invalid back reference.  *\/$/;"	e	enum:__anon63
REG_EXTENDED	.\regex.h	215;"	d
REG_ICASE	.\regex.h	219;"	d
REG_MATCH_NULL_STRING_P	.\regex.c	3025;"	d	file:
REG_NEWLINE	.\regex.h	224;"	d
REG_NOERROR	.\regex.h	/^  REG_NOERROR = 0,	\/* Success.  *\/$/;"	e	enum:__anon63
REG_NOMATCH	.\regex.h	/^  REG_NOMATCH,		\/* Didn't find a match (for regexec).  *\/$/;"	e	enum:__anon63
REG_NOSUB	.\regex.h	228;"	d
REG_NOTBOL	.\regex.h	238;"	d
REG_NOTEOL	.\regex.h	241;"	d
REG_UNSET	.\regex.c	3055;"	d	file:
REG_UNSET_VALUE	.\regex.c	3054;"	d	file:
REMAINING_AVAIL_SLOTS	.\regex.c	2446;"	d	file:
RETALLOC	.\regex.c	226;"	d	file:
RE_BACKSLASH_ESCAPE_IN_LISTS	.\regex.h	42;"	d
RE_BK_PLUS_QM	.\regex.h	47;"	d
RE_CHAR_CLASSES	.\regex.h	53;"	d
RE_CONTEXT_INDEP_ANCHORS	.\regex.h	67;"	d
RE_CONTEXT_INDEP_OPS	.\regex.h	75;"	d
RE_CONTEXT_INVALID_OPS	.\regex.h	79;"	d
RE_DOT_NEWLINE	.\regex.h	83;"	d
RE_DOT_NOT_NULL	.\regex.h	87;"	d
RE_DUP_MAX	.\regex.h	206;"	d
RE_DUP_MAX	.\regex.h	208;"	d
RE_EXACTN_VALUE	.\regex.h	351;"	d
RE_HAT_LISTS_NOT_NEWLINE	.\regex.h	91;"	d
RE_INTERVALS	.\regex.h	96;"	d
RE_LIMITED_OPS	.\regex.h	100;"	d
RE_NEWLINE_ALT	.\regex.h	104;"	d
RE_NO_BK_BRACES	.\regex.h	109;"	d
RE_NO_BK_PARENS	.\regex.h	113;"	d
RE_NO_BK_REFS	.\regex.h	117;"	d
RE_NO_BK_VBAR	.\regex.h	121;"	d
RE_NO_EMPTY_RANGES	.\regex.h	127;"	d
RE_NREGS	.\regex.h	371;"	d
RE_SYNTAX_AWK	.\regex.h	145;"	d
RE_SYNTAX_ED	.\regex.h	169;"	d
RE_SYNTAX_EGREP	.\regex.h	159;"	d
RE_SYNTAX_EMACS	.\regex.h	143;"	d
RE_SYNTAX_GREP	.\regex.h	154;"	d
RE_SYNTAX_POSIX_AWK	.\regex.h	151;"	d
RE_SYNTAX_POSIX_BASIC	.\regex.h	178;"	d
RE_SYNTAX_POSIX_EGREP	.\regex.h	165;"	d
RE_SYNTAX_POSIX_EXTENDED	.\regex.h	187;"	d
RE_SYNTAX_POSIX_MINIMAL_BASIC	.\regex.h	184;"	d
RE_SYNTAX_POSIX_MINIMAL_EXTENDED	.\regex.h	195;"	d
RE_SYNTAX_SED	.\regex.h	171;"	d
RE_UNMATCHED_RIGHT_PAREN_ORD	.\regex.h	131;"	d
RebuildCTags	.\ctags_plugin.py	/^class RebuildCTags(sublimeplugin.TextCommand):$/;"	c
ReferencedTypes	.\eiffel.c	/^static stringList *ReferencedTypes;$/;"	v	file:
RexxParser	.\rexx.c	/^extern parserDefinition* RexxParser (void)$/;"	f
RubyKinds	.\ruby.c	/^static kindOption RubyKinds [] = {$/;"	v	file:
RubyParser	.\ruby.c	/^extern parserDefinition* RubyParser (void)$/;"	f
SCOPE_COUNT	.\c.c	/^	SCOPE_COUNT$/;"	e	enum:eTagScope	file:
SCOPE_EXTERN	.\c.c	/^	SCOPE_EXTERN,        \/* external storage class *\/$/;"	e	enum:eTagScope	file:
SCOPE_FRIEND	.\c.c	/^	SCOPE_FRIEND,        \/* declares access only *\/$/;"	e	enum:eTagScope	file:
SCOPE_GLOBAL	.\c.c	/^	SCOPE_GLOBAL,        \/* no storage class specified *\/$/;"	e	enum:eTagScope	file:
SCOPE_STATIC	.\c.c	/^	SCOPE_STATIC,        \/* static storage class *\/$/;"	e	enum:eTagScope	file:
SCOPE_TYPEDEF	.\c.c	/^	SCOPE_TYPEDEF,       \/* scoping depends upon context *\/$/;"	e	enum:eTagScope	file:
SEE ALSO	.\ctags.html	/^<a name="SEE ALSO"><\/a>$/;"	a
SET_LIST_BIT	.\regex.c	1011;"	d	file:
SET_REGS_MATCHED	.\regex.c	3034;"	d	file:
SIGN_EXTEND_CHAR	.\regex.c	164;"	d	file:
SIGN_EXTEND_CHAR	.\regex.c	166;"	d	file:
SIGN_EXTEND_CHAR	.\regex.c	169;"	d	file:
SINGLE_QUOTE	.\read.h	/^	SINGLE_QUOTE  = '\\'',$/;"	e	enum:eCharacters
SOURCE FILES	.\ctags.html	/^<a name="SOURCE FILES"><\/a>$/;"	a
SOURCES	.\mk_mpw.mak	/^SOURCES = ¶$/;"	m
SOURCES	.\source.mak	/^SOURCES = \\$/;"	m
SO_FOLDSORTED	.\options.h	/^	SO_FOLDSORTED$/;"	e	enum:sortType
SO_SORTED	.\options.h	/^	SO_SORTED,$/;"	e	enum:sortType
SO_UNSORTED	.\options.h	/^	SO_UNSORTED,$/;"	e	enum:sortType
SPACE	.\read.h	/^	SPACE         = ' ',$/;"	e	enum:eCharacters
SQLTAG_BLOCK_LABEL	.\sql.c	/^	SQLTAG_BLOCK_LABEL,$/;"	e	enum:__anon71	file:
SQLTAG_COUNT	.\sql.c	/^	SQLTAG_COUNT$/;"	e	enum:__anon71	file:
SQLTAG_CURSOR	.\sql.c	/^	SQLTAG_CURSOR,$/;"	e	enum:__anon71	file:
SQLTAG_DOMAIN	.\sql.c	/^	SQLTAG_DOMAIN,$/;"	e	enum:__anon71	file:
SQLTAG_EVENT	.\sql.c	/^	SQLTAG_EVENT,$/;"	e	enum:__anon71	file:
SQLTAG_FIELD	.\sql.c	/^	SQLTAG_FIELD,$/;"	e	enum:__anon71	file:
SQLTAG_FUNCTION	.\sql.c	/^	SQLTAG_FUNCTION,$/;"	e	enum:__anon71	file:
SQLTAG_INDEX	.\sql.c	/^	SQLTAG_INDEX,$/;"	e	enum:__anon71	file:
SQLTAG_LOCAL_VARIABLE	.\sql.c	/^	SQLTAG_LOCAL_VARIABLE,$/;"	e	enum:__anon71	file:
SQLTAG_MLCONN	.\sql.c	/^	SQLTAG_MLCONN,$/;"	e	enum:__anon71	file:
SQLTAG_MLTABLE	.\sql.c	/^	SQLTAG_MLTABLE,$/;"	e	enum:__anon71	file:
SQLTAG_PACKAGE	.\sql.c	/^	SQLTAG_PACKAGE,$/;"	e	enum:__anon71	file:
SQLTAG_PROCEDURE	.\sql.c	/^	SQLTAG_PROCEDURE,$/;"	e	enum:__anon71	file:
SQLTAG_PROTOTYPE	.\sql.c	/^	SQLTAG_PROTOTYPE,$/;"	e	enum:__anon71	file:
SQLTAG_PUBLICATION	.\sql.c	/^	SQLTAG_PUBLICATION,$/;"	e	enum:__anon71	file:
SQLTAG_RECORD	.\sql.c	/^	SQLTAG_RECORD,$/;"	e	enum:__anon71	file:
SQLTAG_SERVICE	.\sql.c	/^	SQLTAG_SERVICE,$/;"	e	enum:__anon71	file:
SQLTAG_SUBTYPE	.\sql.c	/^	SQLTAG_SUBTYPE,$/;"	e	enum:__anon71	file:
SQLTAG_SYNONYM	.\sql.c	/^	SQLTAG_SYNONYM,$/;"	e	enum:__anon71	file:
SQLTAG_TABLE	.\sql.c	/^	SQLTAG_TABLE,$/;"	e	enum:__anon71	file:
SQLTAG_TRIGGER	.\sql.c	/^	SQLTAG_TRIGGER,$/;"	e	enum:__anon71	file:
SQLTAG_VARIABLE	.\sql.c	/^	SQLTAG_VARIABLE,$/;"	e	enum:__anon71	file:
SQLTAG_VIEW	.\sql.c	/^	SQLTAG_VIEW,$/;"	e	enum:__anon71	file:
STDC_HEADERS	.\e_djgpp.h	45;"	d
STDC_HEADERS	.\e_mac.h	25;"	d
STDC_HEADERS	.\e_qdos.h	21;"	d
STDC_HEADERS	.\e_riscos.h	26;"	d
STORE_JUMP	.\regex.c	915;"	d	file:
STORE_JUMP2	.\regex.c	919;"	d	file:
STORE_NUMBER	.\regex.c	384;"	d	file:
STORE_NUMBER_AND_INCR	.\regex.c	394;"	d	file:
STREQ	.\regex.c	231;"	d	file:
STRING_SYMBOL	.\read.h	/^	STRING_SYMBOL = ('S' + 0x80),$/;"	e	enum:eCharacters
SYNOPSIS	.\ctags.html	/^<a name="SYNOPSIS"><\/a>$/;"	a
SYNTAX	.\regex.c	120;"	d	file:
S_IFBLK	.\e_mac.h	70;"	d
S_IFCHR	.\e_mac.h	69;"	d
S_IFDIR	.\e_mac.h	68;"	d
S_IFMT	.\e_mac.h	65;"	d
S_IFMT	.\routines.c	99;"	d	file:
S_IFREG	.\e_mac.h	71;"	d
S_IRUSR	.\routines.c	113;"	d	file:
S_ISBLK	.\e_mac.h	77;"	d
S_ISCHR	.\e_mac.h	76;"	d
S_ISDIR	.\e_mac.h	75;"	d
S_ISDIR	.\routines.c	92;"	d	file:
S_ISDIR	.\routines.c	94;"	d	file:
S_ISLNK	.\routines.c	84;"	d	file:
S_ISLNK	.\routines.c	86;"	d	file:
S_ISREG	.\e_mac.h	78;"	d
S_ISREG	.\routines.c	76;"	d	file:
S_ISREG	.\routines.c	78;"	d	file:
S_ISTYPE	.\e_mac.h	73;"	d
S_ISUID	.\routines.c	120;"	d	file:
S_IWUSR	.\routines.c	116;"	d	file:
S_IXGRP	.\routines.c	106;"	d	file:
S_IXOTH	.\routines.c	109;"	d	file:
S_IXUSR	.\routines.c	103;"	d	file:
SchemeKinds	.\scheme.c	/^static kindOption SchemeKinds [] = {$/;"	v	file:
SchemeParser	.\scheme.c	/^extern parserDefinition* SchemeParser (void)$/;"	f
SelfReferences	.\eiffel.c	/^static int SelfReferences;$/;"	v	file:
SetUpper	.\lregex.c	/^static int SetUpper = -1;  \/* upper language index in list *\/$/;"	v	file:
Sets	.\lregex.c	/^static patternSet* Sets = NULL;$/;"	v	file:
ShKinds	.\sh.c	/^static kindOption ShKinds [] = {$/;"	v	file:
ShParser	.\sh.c	/^extern parserDefinition* ShParser (void)$/;"	f
ShowSymbolsForCurrentFile	.\ctags_plugin.py	/^class ShowSymbolsForCurrentFile(sublimeplugin.TextCommand):$/;"	c
Signature	.\c.c	/^static vString *Signature;$/;"	v	file:
SkipConfiguration	.\options.c	/^static boolean SkipConfiguration;$/;"	v	file:
SlangParser	.\slang.c	/^extern parserDefinition* SlangParser (void)$/;"	f
SmlKeywordTypes	.\sml.c	/^} SmlKeywordTypes [] = {$/;"	v	typeref:struct:__anon70	file:
SmlKinds	.\sml.c	/^static kindOption SmlKinds[] = {$/;"	v	file:
SmlParser	.\sml.c	/^extern parserDefinition *SmlParser (void)$/;"	f
SortMethod	.\readtags.c	/^static sortType SortMethod;$/;"	v	file:
SortOverride	.\readtags.c	/^static int SortOverride;$/;"	v	file:
SqlKeywordTable	.\sql.c	/^static const keywordDesc SqlKeywordTable [] = {$/;"	v	file:
SqlKinds	.\sql.c	/^static kindOption SqlKinds [] = {$/;"	v	file:
SqlParser	.\sql.c	/^extern parserDefinition* SqlParser (void)$/;"	f
StartOfLine	.\read.c	/^static fpos_t StartOfLine;  \/* holds deferred position of start of line *\/$/;"	v	file:
Sword	.\regex.c	79;"	d	file:
T	.\mk_qdos.mak	/^T = ram1_$/;"	m
TAB	.\read.h	/^	TAB           = '\\t',$/;"	e	enum:eCharacters
TAB	.\readtags.c	26;"	d	file:
TAG FILE FORMAT	.\ctags.html	/^<a name="TAG FILE FORMAT"><\/a>$/;"	a
TAG_BLOCK_DATA	.\fortran.c	/^	TAG_BLOCK_DATA,$/;"	e	enum:eTagType	file:
TAG_CLASS	.\c.c	/^	TAG_CLASS,       \/* class name *\/$/;"	e	enum:eTagType	file:
TAG_COMMON_BLOCK	.\fortran.c	/^	TAG_COMMON_BLOCK,$/;"	e	enum:eTagType	file:
TAG_COMPONENT	.\fortran.c	/^	TAG_COMPONENT,$/;"	e	enum:eTagType	file:
TAG_COUNT	.\c.c	/^	TAG_COUNT        \/* must be last *\/$/;"	e	enum:eTagType	file:
TAG_COUNT	.\fortran.c	/^	TAG_COUNT  \/* must be last *\/$/;"	e	enum:eTagType	file:
TAG_DERIVED_TYPE	.\fortran.c	/^	TAG_DERIVED_TYPE,$/;"	e	enum:eTagType	file:
TAG_ENTRY_POINT	.\fortran.c	/^	TAG_ENTRY_POINT,$/;"	e	enum:eTagType	file:
TAG_ENUM	.\c.c	/^	TAG_ENUM,        \/* enumeration name *\/$/;"	e	enum:eTagType	file:
TAG_ENUMERATOR	.\c.c	/^	TAG_ENUMERATOR,  \/* enumerator (enumeration value) *\/$/;"	e	enum:eTagType	file:
TAG_EVENT	.\c.c	/^	TAG_EVENT,       \/* event *\/$/;"	e	enum:eTagType	file:
TAG_EXTERN_VAR	.\c.c	/^	TAG_EXTERN_VAR,  \/* external variable declaration *\/$/;"	e	enum:eTagType	file:
TAG_FIELD	.\c.c	/^	TAG_FIELD,       \/* field (Java) *\/$/;"	e	enum:eTagType	file:
TAG_FOLDSORTED	.\readtags.h	/^	TAG_UNSORTED, TAG_SORTED, TAG_FOLDSORTED$/;"	e	enum:__anon47
TAG_FULLMATCH	.\readtags.h	38;"	d
TAG_FUNCTION	.\c.c	/^	TAG_FUNCTION,    \/* function definition *\/$/;"	e	enum:eTagType	file:
TAG_FUNCTION	.\fortran.c	/^	TAG_FUNCTION,$/;"	e	enum:eTagType	file:
TAG_IGNORECASE	.\readtags.h	42;"	d
TAG_INTERFACE	.\c.c	/^	TAG_INTERFACE,   \/* interface declaration *\/$/;"	e	enum:eTagType	file:
TAG_INTERFACE	.\fortran.c	/^	TAG_INTERFACE,$/;"	e	enum:eTagType	file:
TAG_LABEL	.\fortran.c	/^	TAG_LABEL,$/;"	e	enum:eTagType	file:
TAG_LOCAL	.\c.c	/^	TAG_LOCAL,       \/* local variable definition *\/$/;"	e	enum:eTagType	file:
TAG_LOCAL	.\fortran.c	/^	TAG_LOCAL,$/;"	e	enum:eTagType	file:
TAG_MEMBER	.\c.c	/^	TAG_MEMBER,      \/* structure, class or interface member *\/$/;"	e	enum:eTagType	file:
TAG_METHOD	.\c.c	/^	TAG_METHOD,      \/* method declaration *\/$/;"	e	enum:eTagType	file:
TAG_MODULE	.\fortran.c	/^	TAG_MODULE,$/;"	e	enum:eTagType	file:
TAG_NAMELIST	.\fortran.c	/^	TAG_NAMELIST,$/;"	e	enum:eTagType	file:
TAG_NAMESPACE	.\c.c	/^	TAG_NAMESPACE,   \/* namespace name *\/$/;"	e	enum:eTagType	file:
TAG_OBSERVECASE	.\readtags.h	41;"	d
TAG_PACKAGE	.\c.c	/^	TAG_PACKAGE,     \/* package name *\/$/;"	e	enum:eTagType	file:
TAG_PARTIALMATCH	.\readtags.h	39;"	d
TAG_PROGRAM	.\c.c	/^	TAG_PROGRAM,     \/* program name *\/$/;"	e	enum:eTagType	file:
TAG_PROGRAM	.\fortran.c	/^	TAG_PROGRAM,$/;"	e	enum:eTagType	file:
TAG_PROPERTY	.\c.c	/^	TAG_PROPERTY,    \/* property name *\/$/;"	e	enum:eTagType	file:
TAG_PROTOTYPE	.\c.c	/^	TAG_PROTOTYPE,   \/* function prototype or declaration *\/$/;"	e	enum:eTagType	file:
TAG_SORTED	.\readtags.h	/^	TAG_UNSORTED, TAG_SORTED, TAG_FOLDSORTED$/;"	e	enum:__anon47
TAG_STRUCT	.\c.c	/^	TAG_STRUCT,      \/* structure name *\/$/;"	e	enum:eTagType	file:
TAG_SUBROUTINE	.\fortran.c	/^	TAG_SUBROUTINE,$/;"	e	enum:eTagType	file:
TAG_TASK	.\c.c	/^	TAG_TASK,        \/* task name *\/$/;"	e	enum:eTagType	file:
TAG_TYPEDEF	.\c.c	/^	TAG_TYPEDEF,     \/* typedef name *\/$/;"	e	enum:eTagType	file:
TAG_UNDEFINED	.\c.c	/^	TAG_UNDEFINED,$/;"	e	enum:eTagType	file:
TAG_UNDEFINED	.\fortran.c	/^	TAG_UNDEFINED = -1,$/;"	e	enum:eTagType	file:
TAG_UNION	.\c.c	/^	TAG_UNION,       \/* union name *\/$/;"	e	enum:eTagType	file:
TAG_UNSORTED	.\readtags.h	/^	TAG_UNSORTED, TAG_SORTED, TAG_FOLDSORTED$/;"	e	enum:__anon47
TAG_VARIABLE	.\c.c	/^	TAG_VARIABLE,    \/* variable definition *\/$/;"	e	enum:eTagType	file:
TAG_VARIABLE	.\fortran.c	/^	TAG_VARIABLE,$/;"	e	enum:eTagType	file:
TALLOC	.\regex.c	225;"	d	file:
TMPDIR	.\e_mac.h	23;"	d
TMPDIR	.\e_msoft.h	39;"	d
TMPDIR	.\e_riscos.h	23;"	d
TMPDIR	.\routines.c	69;"	d	file:
TOKEN_ARGS	.\c.c	/^	TOKEN_ARGS,          \/* a parenthetical pair and its contents *\/$/;"	e	enum:eTokenType	file:
TOKEN_BANG	.\eiffel.c	/^	TOKEN_BANG,$/;"	e	enum:eTokenType	file:
TOKEN_BLOCK_LABEL_BEGIN	.\sql.c	/^	TOKEN_BLOCK_LABEL_BEGIN,$/;"	e	enum:eTokenType	file:
TOKEN_BLOCK_LABEL_END	.\sql.c	/^	TOKEN_BLOCK_LABEL_END,$/;"	e	enum:eTokenType	file:
TOKEN_BRACE_CLOSE	.\c.c	/^	TOKEN_BRACE_CLOSE,$/;"	e	enum:eTokenType	file:
TOKEN_BRACE_OPEN	.\c.c	/^	TOKEN_BRACE_OPEN,$/;"	e	enum:eTokenType	file:
TOKEN_CHARACTER	.\eiffel.c	/^	TOKEN_CHARACTER,$/;"	e	enum:eTokenType	file:
TOKEN_CHARACTER	.\jscript.c	/^	TOKEN_CHARACTER,$/;"	e	enum:eTokenType	file:
TOKEN_CHARACTER	.\sql.c	/^	TOKEN_CHARACTER,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_BRACE	.\eiffel.c	/^	TOKEN_CLOSE_BRACE,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_BRACKET	.\eiffel.c	/^	TOKEN_CLOSE_BRACKET,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_CURLY	.\jscript.c	/^	TOKEN_CLOSE_CURLY,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_CURLY	.\sql.c	/^	TOKEN_CLOSE_CURLY,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_PAREN	.\eiffel.c	/^	TOKEN_CLOSE_PAREN,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_PAREN	.\jscript.c	/^	TOKEN_CLOSE_PAREN,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_PAREN	.\sql.c	/^	TOKEN_CLOSE_PAREN,$/;"	e	enum:eTokenType	file:
TOKEN_CLOSE_SQUARE	.\jscript.c	/^	TOKEN_CLOSE_SQUARE$/;"	e	enum:eTokenType	file:
TOKEN_COLON	.\c.c	/^	TOKEN_COLON,         \/* the colon character *\/$/;"	e	enum:eTokenType	file:
TOKEN_COLON	.\eiffel.c	/^	TOKEN_COLON,$/;"	e	enum:eTokenType	file:
TOKEN_COLON	.\jscript.c	/^	TOKEN_COLON,$/;"	e	enum:eTokenType	file:
TOKEN_COMMA	.\c.c	/^	TOKEN_COMMA,         \/* the comma character *\/$/;"	e	enum:eTokenType	file:
TOKEN_COMMA	.\eiffel.c	/^	TOKEN_COMMA,$/;"	e	enum:eTokenType	file:
TOKEN_COMMA	.\fortran.c	/^	TOKEN_COMMA,$/;"	e	enum:eTokenType	file:
TOKEN_COMMA	.\jscript.c	/^	TOKEN_COMMA,$/;"	e	enum:eTokenType	file:
TOKEN_COMMA	.\sql.c	/^	TOKEN_COMMA,$/;"	e	enum:eTokenType	file:
TOKEN_CONSTRAINT	.\eiffel.c	/^	TOKEN_CONSTRAINT,$/;"	e	enum:eTokenType	file:
TOKEN_COUNT	.\c.c	/^	TOKEN_COUNT$/;"	e	enum:eTokenType	file:
TOKEN_DOLLAR	.\eiffel.c	/^	TOKEN_DOLLAR,$/;"	e	enum:eTokenType	file:
TOKEN_DOT	.\eiffel.c	/^	TOKEN_DOT,$/;"	e	enum:eTokenType	file:
TOKEN_DOUBLE_COLON	.\c.c	/^	TOKEN_DOUBLE_COLON,  \/* double colon indicates nested-name-specifier *\/$/;"	e	enum:eTokenType	file:
TOKEN_DOUBLE_COLON	.\fortran.c	/^	TOKEN_DOUBLE_COLON,$/;"	e	enum:eTokenType	file:
TOKEN_EQUAL_SIGN	.\jscript.c	/^	TOKEN_EQUAL_SIGN,$/;"	e	enum:eTokenType	file:
TOKEN_FORWARD_SLASH	.\jscript.c	/^	TOKEN_FORWARD_SLASH,$/;"	e	enum:eTokenType	file:
TOKEN_FORWARD_SLASH	.\sql.c	/^	TOKEN_FORWARD_SLASH$/;"	e	enum:eTokenType	file:
TOKEN_IDENTIFIER	.\eiffel.c	/^	TOKEN_IDENTIFIER,$/;"	e	enum:eTokenType	file:
TOKEN_IDENTIFIER	.\fortran.c	/^	TOKEN_IDENTIFIER,$/;"	e	enum:eTokenType	file:
TOKEN_IDENTIFIER	.\jscript.c	/^	TOKEN_IDENTIFIER,$/;"	e	enum:eTokenType	file:
TOKEN_IDENTIFIER	.\sql.c	/^	TOKEN_IDENTIFIER,$/;"	e	enum:eTokenType	file:
TOKEN_KEYWORD	.\c.c	/^	TOKEN_KEYWORD,$/;"	e	enum:eTokenType	file:
TOKEN_KEYWORD	.\eiffel.c	/^	TOKEN_KEYWORD,$/;"	e	enum:eTokenType	file:
TOKEN_KEYWORD	.\fortran.c	/^	TOKEN_KEYWORD,$/;"	e	enum:eTokenType	file:
TOKEN_KEYWORD	.\jscript.c	/^	TOKEN_KEYWORD,$/;"	e	enum:eTokenType	file:
TOKEN_KEYWORD	.\sql.c	/^	TOKEN_KEYWORD,$/;"	e	enum:eTokenType	file:
TOKEN_LABEL	.\fortran.c	/^	TOKEN_LABEL,$/;"	e	enum:eTokenType	file:
TOKEN_NAME	.\c.c	/^	TOKEN_NAME,          \/* an unknown name *\/$/;"	e	enum:eTokenType	file:
TOKEN_NONE	.\c.c	/^	TOKEN_NONE,          \/* none *\/$/;"	e	enum:eTokenType	file:
TOKEN_NUMERIC	.\eiffel.c	/^	TOKEN_NUMERIC,$/;"	e	enum:eTokenType	file:
TOKEN_NUMERIC	.\fortran.c	/^	TOKEN_NUMERIC,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_BRACE	.\eiffel.c	/^	TOKEN_OPEN_BRACE,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_BRACKET	.\eiffel.c	/^	TOKEN_OPEN_BRACKET,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_CURLY	.\jscript.c	/^	TOKEN_OPEN_CURLY,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_CURLY	.\sql.c	/^	TOKEN_OPEN_CURLY,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_PAREN	.\eiffel.c	/^	TOKEN_OPEN_PAREN,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_PAREN	.\jscript.c	/^	TOKEN_OPEN_PAREN,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_PAREN	.\sql.c	/^	TOKEN_OPEN_PAREN,$/;"	e	enum:eTokenType	file:
TOKEN_OPEN_SQUARE	.\jscript.c	/^	TOKEN_OPEN_SQUARE,$/;"	e	enum:eTokenType	file:
TOKEN_OPERATOR	.\eiffel.c	/^	TOKEN_OPERATOR,$/;"	e	enum:eTokenType	file:
TOKEN_OPERATOR	.\fortran.c	/^	TOKEN_OPERATOR,$/;"	e	enum:eTokenType	file:
TOKEN_OPERATOR	.\jscript.c	/^	TOKEN_OPERATOR,$/;"	e	enum:eTokenType	file:
TOKEN_OPERATOR	.\sql.c	/^	TOKEN_OPERATOR,$/;"	e	enum:eTokenType	file:
TOKEN_OTHER	.\eiffel.c	/^	TOKEN_OTHER,$/;"	e	enum:eTokenType	file:
TOKEN_OTHER	.\sql.c	/^	TOKEN_OTHER,$/;"	e	enum:eTokenType	file:
TOKEN_PACKAGE	.\c.c	/^	TOKEN_PACKAGE,       \/* a Java package name *\/$/;"	e	enum:eTokenType	file:
TOKEN_PAREN_CLOSE	.\fortran.c	/^	TOKEN_PAREN_CLOSE,$/;"	e	enum:eTokenType	file:
TOKEN_PAREN_NAME	.\c.c	/^	TOKEN_PAREN_NAME,    \/* a single name in parentheses *\/$/;"	e	enum:eTokenType	file:
TOKEN_PAREN_OPEN	.\fortran.c	/^	TOKEN_PAREN_OPEN,$/;"	e	enum:eTokenType	file:
TOKEN_PERCENT	.\fortran.c	/^	TOKEN_PERCENT,$/;"	e	enum:eTokenType	file:
TOKEN_PERIOD	.\jscript.c	/^	TOKEN_PERIOD,$/;"	e	enum:eTokenType	file:
TOKEN_PERIOD	.\sql.c	/^	TOKEN_PERIOD,$/;"	e	enum:eTokenType	file:
TOKEN_SEMICOLON	.\c.c	/^	TOKEN_SEMICOLON,     \/* the semicolon character *\/$/;"	e	enum:eTokenType	file:
TOKEN_SEMICOLON	.\jscript.c	/^	TOKEN_SEMICOLON,$/;"	e	enum:eTokenType	file:
TOKEN_SEMICOLON	.\sql.c	/^	TOKEN_SEMICOLON,$/;"	e	enum:eTokenType	file:
TOKEN_SEPARATOR	.\eiffel.c	/^	TOKEN_SEPARATOR,$/;"	e	enum:eTokenType	file:
TOKEN_SPEC	.\c.c	/^	TOKEN_SPEC,          \/* a storage class specifier, qualifier, type, etc. *\/$/;"	e	enum:eTokenType	file:
TOKEN_STATEMENT_END	.\fortran.c	/^	TOKEN_STATEMENT_END,$/;"	e	enum:eTokenType	file:
TOKEN_STRING	.\eiffel.c	/^	TOKEN_STRING,$/;"	e	enum:eTokenType	file:
TOKEN_STRING	.\fortran.c	/^	TOKEN_STRING$/;"	e	enum:eTokenType	file:
TOKEN_STRING	.\jscript.c	/^	TOKEN_STRING,$/;"	e	enum:eTokenType	file:
TOKEN_STRING	.\sql.c	/^	TOKEN_STRING,$/;"	e	enum:eTokenType	file:
TOKEN_TILDE	.\eiffel.c	/^	TOKEN_TILDE$/;"	e	enum:eTokenType	file:
TOKEN_TILDE	.\sql.c	/^	TOKEN_TILDE,$/;"	e	enum:eTokenType	file:
TOKEN_UNDEFINED	.\eiffel.c	/^	TOKEN_UNDEFINED,$/;"	e	enum:eTokenType	file:
TOKEN_UNDEFINED	.\fortran.c	/^	TOKEN_UNDEFINED,$/;"	e	enum:eTokenType	file:
TOKEN_UNDEFINED	.\jscript.c	/^	TOKEN_UNDEFINED,$/;"	e	enum:eTokenType	file:
TOKEN_UNDEFINED	.\sql.c	/^	TOKEN_UNDEFINED,$/;"	e	enum:eTokenType	file:
TRACE	.\perl.c	27;"	d	file:
TRACE_PERL_C	.\perl.c	26;"	d	file:
TRANSLATE	.\regex.c	873;"	d	file:
TRUE	.\general.h	/^typedef enum { FALSE, TRUE } boolean;$/;"	e	enum:__anon22
TRUE	.\general.h	/^typedef enum { FALSE, TRUE } booleanType;$/;"	e	enum:__anon21
TRUE	.\general.h	91;"	d
TRUE	.\general.h	99;"	d
TableSize	.\keyword.c	/^static const unsigned int TableSize = 1 << HASH_EXPONENT;$/;"	v	file:
Tag	.\ctags.py	/^class Tag(object):$/;"	c
TagFailure	.\readtags.h	/^typedef enum { TagFailure = 0, TagSuccess = 1 } tagResult;$/;"	e	enum:__anon48
TagFile	.\entry.c	/^tagFile TagFile = {$/;"	v
TagFileName	.\readtags.c	/^static const char *TagFileName = "tags";$/;"	v	file:
TagSuccess	.\readtags.h	/^typedef enum { TagFailure = 0, TagSuccess = 1 } tagResult;$/;"	e	enum:__anon48
TagsToStdout	.\entry.c	/^static boolean TagsToStdout = FALSE;$/;"	v	file:
TclKinds	.\tcl.c	/^static kindOption TclKinds [] = {$/;"	v	file:
TclParser	.\tcl.c	/^extern parserDefinition* TclParser (void)$/;"	f
Totals	.\main.c	/^static struct { long files, lines, bytes; } Totals = { 0, 0, 0 };$/;"	v	typeref:struct:__anon32	file:
UNIX_PATH_SEPARATOR	.\e_os2.h	14;"	d
USE_REPLACEMENT_TRUNCATE	.\entry.c	62;"	d	file:
Ungetc	.\fortran.c	/^static int Ungetc;$/;"	v	file:
Ungetc	.\verilog.c	/^static int Ungetc;$/;"	v	file:
Usage	.\eiffel.c	/^static const char *const Usage =$/;"	v	file:
Usage	.\readtags.c	/^const char *const Usage =$/;"	v
VERsion	.\main.c	/^  static const char *VERsion = "$VER: "PROGRAM_NAME" "PROGRAM_VERSION" "$/;"	v	file:
VK_CLASS	.\c.c	/^	VK_CLASS, VK_DEFINE, VK_ENUMERATOR, VK_FUNCTION,$/;"	e	enum:__anon15	file:
VK_DEFINE	.\c.c	/^	VK_CLASS, VK_DEFINE, VK_ENUMERATOR, VK_FUNCTION,$/;"	e	enum:__anon15	file:
VK_ENUMERATION	.\c.c	/^	VK_ENUMERATION, VK_LOCAL, VK_MEMBER, VK_PROGRAM, VK_PROTOTYPE,$/;"	e	enum:__anon15	file:
VK_ENUMERATOR	.\c.c	/^	VK_CLASS, VK_DEFINE, VK_ENUMERATOR, VK_FUNCTION,$/;"	e	enum:__anon15	file:
VK_EXTERN_VARIABLE	.\c.c	/^	VK_EXTERN_VARIABLE$/;"	e	enum:__anon15	file:
VK_FUNCTION	.\c.c	/^	VK_CLASS, VK_DEFINE, VK_ENUMERATOR, VK_FUNCTION,$/;"	e	enum:__anon15	file:
VK_LOCAL	.\c.c	/^	VK_ENUMERATION, VK_LOCAL, VK_MEMBER, VK_PROGRAM, VK_PROTOTYPE,$/;"	e	enum:__anon15	file:
VK_MEMBER	.\c.c	/^	VK_ENUMERATION, VK_LOCAL, VK_MEMBER, VK_PROGRAM, VK_PROTOTYPE,$/;"	e	enum:__anon15	file:
VK_PROGRAM	.\c.c	/^	VK_ENUMERATION, VK_LOCAL, VK_MEMBER, VK_PROGRAM, VK_PROTOTYPE,$/;"	e	enum:__anon15	file:
VK_PROTOTYPE	.\c.c	/^	VK_ENUMERATION, VK_LOCAL, VK_MEMBER, VK_PROGRAM, VK_PROTOTYPE,$/;"	e	enum:__anon15	file:
VK_TASK	.\c.c	/^	VK_TASK, VK_TYPEDEF, VK_VARIABLE,$/;"	e	enum:__anon15	file:
VK_TYPEDEF	.\c.c	/^	VK_TASK, VK_TYPEDEF, VK_VARIABLE,$/;"	e	enum:__anon15	file:
VK_UNDEFINED	.\c.c	/^	VK_UNDEFINED = -1,$/;"	e	enum:__anon15	file:
VK_VARIABLE	.\c.c	/^	VK_TASK, VK_TYPEDEF, VK_VARIABLE,$/;"	e	enum:__anon15	file:
VMS	.\general.h	36;"	d
VSTRING_PUTC_MACRO	.\vstring.h	27;"	d
VTAB	.\read.h	/^	VTAB          = '\\v',$/;"	e	enum:eCharacters
VeraKinds	.\c.c	/^static kindOption VeraKinds [] = {$/;"	v	file:
VeraParser	.\c.c	/^extern parserDefinition* VeraParser (void)$/;"	f
VerilogKeywordTable	.\verilog.c	/^static keywordAssoc VerilogKeywordTable [] = {$/;"	v	file:
VerilogKinds	.\verilog.c	/^static kindOption VerilogKinds [] = {$/;"	v	file:
VerilogParser	.\verilog.c	/^extern parserDefinition* VerilogParser (void)$/;"	f
VimKinds	.\vim.c	/^static kindOption VimKinds [] = {$/;"	v	file:
VimParser	.\vim.c	/^extern parserDefinition* VimParser (void)$/;"	f
WARNING	.\routines.h	/^enum eErrorTypes { FATAL = 1, WARNING = 2, PERROR = 4 };$/;"	e	enum:eErrorTypes
WARNINGS	.\mk_bc5.mak	/^WARNINGS = -w-aus -w-par -w-pia -w-pro -w-sus$/;"	m
WHOLE_FILE	.\entry.h	26;"	d
WORDCHAR_P	.\regex.c	3086;"	d	file:
YaccParser	.\yacc.c	/^extern parserDefinition* YaccParser ()$/;"	f
_ARGS_H	.\args.h	12;"	d
_CTAGS_H	.\ctags.h	12;"	d
_DEBUG_H	.\debug.h	12;"	d
_ENTRY_H	.\entry.h	12;"	d
_GENERAL_H	.\general.h	12;"	d
_GET_H	.\get.h	12;"	d
_GNU_SOURCE	.\regex.c	27;"	d	file:
_KEYWORD_H	.\keyword.h	12;"	d
_MAIN_H	.\main.h	12;"	d
_OPTIONS_H	.\options.h	12;"	d
_Open	.\qdos.c	/^int (*_Open) (const char *, int, ...) = qopen;$/;"	v
_PARSERS_H	.\parsers.h	15;"	d
_PARSE_H	.\parse.h	12;"	d
_READ_H	.\read.h	12;"	d
_RE_ARGS	.\regex.h	394;"	d
_RE_ARGS	.\regex.h	398;"	d
_RE_SYNTAX_POSIX_COMMON	.\regex.h	174;"	d
_ROUTINES_H	.\routines.h	12;"	d
_SORT_H	.\sort.h	12;"	d
_STRLIST_H	.\strlist.h	12;"	d
_VSTRING_H	.\vstring.h	12;"	d
__REGEXP_LIBRARY_H__	.\regex.h	21;"	d
__call__	.\plugin_helpers.py	/^    def __call__(self, times=2, delay = 50):  $/;"	m	class:FocusRestorer	file:
__init__	.\ctags.py	/^    def __init__(self, status=None):$/;"	m	class:CTagsCache
__init__	.\ctags.py	/^    def __init__(self, tag_dict):$/;"	m	class:Tag
__init__	.\plugin_helpers.py	/^    def __init__(self):$/;"	m	class:FocusRestorer
__pad1	.\e_mac.h	/^	unsigned short int __pad1;$/;"	m	struct:stat
__printf__	.\general.h	61;"	d
__printf__	.\general.h	64;"	d
__repr__	.\ctags.py	/^    def __repr__(self):$/;"	m	class:Tag	file:
__unused__	.\general.h	60;"	d
__unused__	.\general.h	63;"	d
_cmdwildcard	.\qdos.c	/^int  (*_cmdwildcard) ()  = custom_expand;$/;"	v
_condetails	.\qdos.c	/^struct WINDOWDEF _condetails = { 208, 1, 0, 7, 512, 256, 0, 0};$/;"	v	typeref:struct:WINDOWDEF
_consetup	.\qdos.c	/^void (*_consetup) ()         = consetup_title;$/;"	v
_copyright	.\qdos.c	/^char _copyright [32] = __DATE__;$/;"	v
_endmsg	.\qdos.c	/^char *_endmsg        = "\\nPress a key to exit.";$/;"	v
_memincr	.\qdos.c	/^long _memincr        = 10240;  \/* Big increments to cut fragmentation *\/$/;"	v
_prog_name	.\qdos.c	/^char _prog_name []   = "ctags";$/;"	v
_stack	.\qdos.c	/^long _stack          = 24576;  \/* Plenty of stack space *\/$/;"	v
_version	.\qdos.c	/^char _version []     = PROGRAM_VERSION;$/;"	v
absoluteDirname	.\routines.c	/^extern char* absoluteDirname (char *file)$/;"	f
absoluteFilename	.\routines.c	/^extern char* absoluteFilename (const char *file)$/;"	f
accept	.\get.c	/^		boolean	accept;          \/* is a directive syntactically permitted? *\/$/;"	m	struct:sCppState::sDirective	file:
access	.\c.c	/^	accessType access;           \/* access of current statement *\/$/;"	m	struct:sMemberInfo	file:
access	.\entry.h	/^		const char* access;$/;"	m	struct:sTagEntryInfo::__anon17
access	.\options.h	/^	boolean access;$/;"	m	struct:sExtFields
accessDefault	.\c.c	/^	accessType accessDefault;    \/* access default for current statement *\/$/;"	m	struct:sMemberInfo	file:
accessField	.\c.c	/^static const char* accessField (const statementInfo *const st)$/;"	f	file:
accessString	.\c.c	/^static const char *accessString (const accessType access)$/;"	f	file:
accessType	.\c.c	/^} accessType;$/;"	t	typeref:enum:eVisibilityType	file:
activeToken	.\c.c	34;"	d	file:
addCallbackRegex	.\lregex.c	/^extern void addCallbackRegex ($/;"	f
addCompiledCallbackPattern	.\lregex.c	/^static void addCompiledCallbackPattern ($/;"	f	file:
addCompiledTagPattern	.\lregex.c	/^static void addCompiledTagPattern ($/;"	f	file:
addContext	.\c.c	/^static void addContext (statementInfo *const st, const tokenInfo* const token)$/;"	f	file:
addContext	.\jscript.c	/^static void addContext (tokenInfo* const parent, const tokenInfo* const child)$/;"	f	file:
addContextSeparator	.\c.c	/^static void addContextSeparator (vString *const scope)$/;"	f	file:
addExtensionFields	.\entry.c	/^static int addExtensionFields (const tagEntryInfo *const tag)$/;"	f	file:
addExtensionList	.\options.c	/^static void addExtensionList ($/;"	f	file:
addGenericName	.\eiffel.c	/^static void addGenericName (tokenInfo *const token)$/;"	f	file:
addIgnoreListFromFile	.\options.c	/^static void addIgnoreListFromFile (const char *const fileName)$/;"	f	file:
addKeyword	.\keyword.c	/^extern void addKeyword (const char *const string, langType language, int value)$/;"	f
addLanguageExtensionMap	.\parse.c	/^extern void addLanguageExtensionMap ($/;"	f
addLanguageMap	.\options.c	/^static char* addLanguageMap (const langType language, char* map)$/;"	f	file:
addLanguagePatternMap	.\parse.c	/^extern void addLanguagePatternMap (const langType language, const char* ptrn)$/;"	f
addLanguageRegex	.\lregex.c	/^extern void addLanguageRegex ($/;"	f
addNestingLevel	.\python.c	/^static void addNestingLevel(NestingLevels *nls, int indentation,$/;"	f	file:
addOtherFields	.\c.c	/^static void addOtherFields (tagEntryInfo* const tag, const tagType type,$/;"	f	file:
addParentClass	.\c.c	/^static void addParentClass (statementInfo *const st, tokenInfo *const token)$/;"	f	file:
addPseudoTags	.\entry.c	/^static void addPseudoTags (void)$/;"	f	file:
addTagRegex	.\lregex.c	/^extern void addTagRegex ($/;"	f
addToScope	.\jscript.c	/^static void addToScope (tokenInfo* const token, vString* const extra)$/;"	f	file:
addToScope	.\sql.c	/^static void addToScope (tokenInfo* const token, vString* const extra)$/;"	f	file:
addTotals	.\main.c	/^extern void addTotals ($/;"	f
add_item	.\argproc.c	/^static add_item (head, tail, value, count)$/;"	f	file:
added	.\entry.h	/^	struct sNumTags { unsigned long added, prev; } numTags;$/;"	m	struct:eTagFile::sNumTags
address	.\readtags.h	/^	} address;$/;"	m	struct:__anon54	typeref:struct:__anon54::__anon55
advanceToken	.\c.c	/^static void advanceToken (statementInfo* const st)$/;"	f	file:
after_dot	.\regex.c	/^  after_dot,	\/* Succeeds if after point.  *\/$/;"	e	enum:__anon57	file:
alloca	.\regex.c	194;"	d	file:
allocated	.\python.c	/^	int allocated;$/;"	m	struct:NestingLevels	file:
allocated	.\regex.h	/^  unsigned long allocated;$/;"	m	struct:re_pattern_buffer
alt_match_null_string_p	.\regex.c	/^alt_match_null_string_p (p, end, reg_info)$/;"	f	file:
analyzeIdentifier	.\c.c	/^static void analyzeIdentifier (tokenInfo *const token)$/;"	f	file:
analyzeKeyword	.\c.c	/^static keywordId analyzeKeyword (const char *const name)$/;"	f	file:
analyzeOperator	.\asm.c	/^static opKeyword analyzeOperator (const vString *const op)$/;"	f	file:
analyzeOperator	.\whatever\asm.c	/^static opKeyword analyzeOperator (const vString *const op)$/;"	f	file:
analyzeParens	.\c.c	/^static void analyzeParens (statementInfo *const st)$/;"	f	file:
analyzePostParens	.\c.c	/^static void analyzePostParens (statementInfo *const st, parenInfo *const info)$/;"	f	file:
analyzeToken	.\eiffel.c	/^static keywordId analyzeToken (vString *const name)$/;"	f	file:
analyzeToken	.\fortran.c	/^static keywordId analyzeToken (vString *const name)$/;"	f	file:
analyzeToken	.\jscript.c	/^static keywordId analyzeToken (vString *const name)$/;"	f	file:
analyzeToken	.\sql.c	/^static keywordId analyzeToken (vString *const name)$/;"	f	file:
ancestorClear	.\fortran.c	/^static void ancestorClear (void)$/;"	f	file:
ancestorCount	.\fortran.c	371;"	d	file:
ancestorPop	.\fortran.c	/^static void ancestorPop (void)$/;"	f	file:
ancestorPush	.\fortran.c	/^static void ancestorPush (tokenInfo *const token)$/;"	f	file:
ancestorScope	.\fortran.c	/^static const tokenInfo* ancestorScope (void)$/;"	f	file:
ancestorTop	.\fortran.c	/^static const tokenInfo* ancestorTop (void)$/;"	f	file:
and_then	.\ctags_plugin.py	/^                def and_then(view):$/;"	f	function:JumpBack.run
and_then	.\ctags_plugin.py	/^    def and_then(view):$/;"	f	function:scroll_to_tag
anychar	.\regex.c	/^  anychar,$/;"	e	enum:__anon57	file:
append	.\ctags_plugin.py	/^    def append(cls, view):$/;"	m	class:JumpBack
append	.\options.h	/^	boolean append;         \/* -a  append to "tags" file *\/$/;"	m	struct:sOptionValues
argDelete	.\args.c	/^extern void argDelete (Arguments* const current)$/;"	f
argForth	.\args.c	/^extern void argForth (Arguments* const current)$/;"	f
argItem	.\args.c	/^extern char *argItem (const Arguments* const current)$/;"	f
argNewFromArgv	.\args.c	/^extern Arguments* argNewFromArgv (char* const* const argv)$/;"	f
argNewFromFile	.\args.c	/^extern Arguments* argNewFromFile (FILE* const fp)$/;"	f
argNewFromLineFile	.\args.c	/^extern Arguments* argNewFromLineFile (FILE* const fp)$/;"	f
argNewFromString	.\args.c	/^extern Arguments* argNewFromString (const char* const string)$/;"	f
argOff	.\args.c	/^extern boolean argOff (const Arguments* const current)$/;"	f
argSetLineMode	.\args.c	/^extern void argSetLineMode (Arguments* const current)$/;"	f
argSetWordMode	.\args.c	/^extern void argSetWordMode (Arguments* const current)$/;"	f
argType	.\args.h	/^typedef enum { ARG_NONE, ARG_STRING, ARG_ARGV, ARG_FILE } argType;$/;"	t	typeref:enum:__anon1
arg_count	.\argproc.c	/^	int arg_count;$/;"	m	struct:exit_control_block	file:
argproc_version	.\argproc.c	/^char argproc_version [] = "@(#)argproc.c VMS uucp Version infopiz-1.0";$/;"	v
args	.\options.h	/^	Arguments* args;$/;"	m	struct:sCookedArgs
argv	.\args.h	/^			char* const* argv;$/;"	m	struct:sArgs::__anon2::sArgvArgs
argvArgs	.\args.h	/^		} argvArgs;$/;"	m	union:sArgs::__anon2	typeref:struct:sArgs::__anon2::sArgvArgs
asmKeyword	.\asm.c	/^} asmKeyword;$/;"	t	typeref:struct:__anon5	file:
asmKeyword	.\whatever\asm.c	/^} asmKeyword;$/;"	t	typeref:struct:__anon78	file:
aspKind	.\asp.c	/^} aspKind;$/;"	t	typeref:enum:__anon7	file:
assert	.\regex.c	781;"	d	file:
assert	.\regex.c	782;"	d	file:
assignment	.\c.c	/^	boolean		assignment;     \/* have we handled an '='? *\/$/;"	m	struct:sStatementInfo	file:
at_begline_loc_p	.\regex.c	/^at_begline_loc_p (pattern, p, syntax)$/;"	f	file:
at_dot	.\regex.c	/^  at_dot,	\/* Succeeds if at point.  *\/$/;"	e	enum:__anon57	file:
at_endline_loc_p	.\regex.c	/^at_endline_loc_p (p, pend, syntax)$/;"	f	file:
author	.\readtags.c	/^		char *author;$/;"	m	struct:sTagFile::__anon46	file:
author	.\readtags.h	/^		const char *author;$/;"	m	struct:__anon49::__anon52
avail	.\regex.c	/^  unsigned avail;			\/* Offset of next open position.  *\/$/;"	m	struct:__anon59	file:
avail	.\regex.c	/^  unsigned avail;			\/* Offset of next open position.  *\/$/;"	m	struct:__anon60	file:
awkKind	.\awk.c	/^} awkKind;$/;"	t	typeref:enum:eAwkKinds	file:
background_process	.\argproc.c	/^background_process (argc, argv)$/;"	f
backward	.\options.h	/^	boolean backward;       \/* -B  regexp patterns search backwards *\/$/;"	m	struct:sOptionValues
baseFilename	.\routines.c	/^extern const char *baseFilename (const char *const filePath)$/;"	f
bcmp	.\regex.c	54;"	d	file:
bcmp_translate	.\regex.c	/^bcmp_translate (s1, s2, len, translate)$/;"	f	file:
bcopy	.\regex.c	57;"	d	file:
before_dot	.\regex.c	/^  ,before_dot,	\/* Succeeds if before point.  *\/$/;"	e	enum:__anon57	file:
begalt_offset	.\regex.c	/^  pattern_offset_t begalt_offset;$/;"	m	struct:__anon58	file:
begbuf	.\regex.c	/^  begbuf,$/;"	e	enum:__anon57	file:
beginEtagsFile	.\entry.c	/^extern void beginEtagsFile (void)$/;"	f
begline	.\regex.c	/^  begline,$/;"	e	enum:__anon57	file:
betaKind	.\beta.c	/^} betaKind;$/;"	t	typeref:enum:__anon10	file:
bits	.\regex.c	/^  } bits;$/;"	m	union:__anon61	typeref:struct:__anon61::__anon62	file:
blitzbasic_keywords	.\basic.c	/^static KeyWord blitzbasic_keywords[] = {$/;"	v	file:
blockName	.\c.c	/^	tokenInfo*	blockName;      \/* name of current block *\/$/;"	m	struct:sStatementInfo	file:
boolString	.\c.c	568;"	d	file:
boolean	.\general.h	/^typedef bool boolean;$/;"	t
boolean	.\general.h	/^typedef enum { FALSE, TRUE } boolean;$/;"	t	typeref:enum:__anon22
boolean	.\general.h	/^typedef int boolean;$/;"	t
boolean	.\main.c	57;"	d	file:
boolean	.\main.c	63;"	d	file:
boolean	.\regex.c	/^typedef char boolean;$/;"	t	file:
booleanOption	.\options.c	/^} booleanOption;$/;"	t	typeref:struct:__anon35	file:
booleanType	.\general.h	/^typedef enum { FALSE, TRUE } booleanType;$/;"	t	typeref:enum:__anon21
branchChosen	.\get.c	/^	boolean branchChosen;       \/* branch already selected *\/$/;"	m	struct:sConditionalInfo	file:
breakLine	.\options.h	/^	unsigned long breakLine;\/* -b  source line at which to call lineBreak() *\/$/;"	m	struct:sOptionValues
buffer	.\readtags.c	/^	char *buffer;$/;"	m	struct:__anon43	file:
buffer	.\regex.h	/^  unsigned char *buffer;$/;"	m	struct:re_pattern_buffer
buffer	.\vstring.h	/^	char   *buffer;  \/* location of buffer *\/$/;"	m	struct:sVString
buildAsmKeywordHash	.\asm.c	/^static void buildAsmKeywordHash (void)$/;"	f	file:
buildAsmKeywordHash	.\whatever\asm.c	/^static void buildAsmKeywordHash (void)$/;"	f	file:
buildEiffelKeywordHash	.\eiffel.c	/^static void buildEiffelKeywordHash (void)$/;"	f	file:
buildFortranKeywordHash	.\fortran.c	/^static void buildFortranKeywordHash (void)$/;"	f	file:
buildJsKeywordHash	.\jscript.c	/^static void buildJsKeywordHash (void)$/;"	f	file:
buildKeywordHash	.\c.c	/^static void buildKeywordHash (const langType language, unsigned int idx)$/;"	f	file:
buildSqlKeywordHash	.\sql.c	/^static void buildSqlKeywordHash (void)$/;"	f	file:
build_ctags	.\ctags_plugin.py	/^    def build_ctags(self, tag_file, cmd, wd):$/;"	m	class:RebuildCTags
byteCount	.\entry.h	/^		size_t byteCount;$/;"	m	struct:eTagFile::sEtags
bytes	.\main.c	/^static struct { long files, lines, bytes; } Totals = { 0, 0, 0 };$/;"	m	struct:__anon32	file:
bzero	.\regex.c	60;"	d	file:
cArgDelete	.\options.c	/^extern void cArgDelete (cookedArgs* const current)$/;"	f
cArgForth	.\options.c	/^extern void cArgForth (cookedArgs* const current)$/;"	f
cArgIsOption	.\options.c	/^extern boolean cArgIsOption (cookedArgs* const current)$/;"	f
cArgItem	.\options.c	/^extern const char* cArgItem (cookedArgs* const current)$/;"	f
cArgNewFromArgv	.\options.c	/^extern cookedArgs* cArgNewFromArgv (char* const* const argv)$/;"	f
cArgNewFromFile	.\options.c	/^extern cookedArgs* cArgNewFromFile (FILE* const fp)$/;"	f
cArgNewFromLineFile	.\options.c	/^extern cookedArgs* cArgNewFromLineFile (FILE* const fp)$/;"	f
cArgNewFromString	.\options.c	/^extern cookedArgs* cArgNewFromString (const char* string)$/;"	f
cArgOff	.\options.c	/^extern boolean cArgOff (cookedArgs* const current)$/;"	f
cArgOptionPending	.\options.c	/^static boolean cArgOptionPending (cookedArgs* const current)$/;"	f	file:
cArgRead	.\options.c	/^static void cArgRead (cookedArgs *const current)$/;"	f	file:
cKind	.\c.c	/^} cKind;$/;"	t	typeref:enum:__anon12	file:
cTagKind	.\c.c	/^static cKind cTagKind (const tagType type)$/;"	f	file:
callback	.\lregex.c	/^		} callback;$/;"	m	union:__anon26::__anon27	typeref:struct:__anon26::__anon27::__anon29	file:
canMatch	.\ruby.c	/^static boolean canMatch (const unsigned char** s, const char* literal)$/;"	f	file:
can_be_null	.\regex.h	/^  unsigned can_be_null : 1;$/;"	m	struct:re_pattern_buffer
canonicalizePath	.\routines.c	/^static void canonicalizePath (char *const path __unused__)$/;"	f	file:
catFile	.\sort.c	/^extern void catFile (const char *const name)$/;"	f
charIsIn	.\ruby.c	/^static boolean charIsIn (char ch, const char* list)$/;"	f	file:
charset	.\regex.c	/^  charset,$/;"	e	enum:__anon57	file:
charset_not	.\regex.c	/^  charset_not,$/;"	e	enum:__anon57	file:
checkForLabel	.\fortran.c	/^static void checkForLabel (void)$/;"	f	file:
checkOptionOrder	.\options.c	/^static void checkOptionOrder (const char* const option)$/;"	f	file:
checkOptions	.\options.c	/^extern void checkOptions (void)$/;"	f
checkRegex	.\lregex.c	/^extern void checkRegex (void)$/;"	f
checkSameFile	.\options.c	/^static boolean checkSameFile (const char *const fileName)$/;"	f	file:
checkStatementEnd	.\c.c	/^static void checkStatementEnd (statementInfo *const st)$/;"	f	file:
child_chan	.\argproc.c	/^static short child_chan;\/* I\/O Channel for Pipe Mailbox					*\/$/;"	v	file:
child_st	.\argproc.c	/^static int child_st [2];		\/* Event Flag set when child process completes	*\/$/;"	v	file:
chooseBranch	.\get.c	/^static void chooseBranch (void)$/;"	f	file:
chsize	.\entry.c	68;"	d	file:
className	.\eiffel.c	/^	vString*  className;$/;"	m	struct:sTokenInfo	file:
clearLanguageMap	.\parse.c	/^extern void clearLanguageMap (const langType language)$/;"	f
clearPatternSet	.\lregex.c	/^static void clearPatternSet (const langType language)$/;"	f	file:
clear_cache	.\ctags_plugin.py	/^    def clear_cache(self, tag_file):$/;"	m	class:RebuildCTags
clock	.\main.c	/^static clock_t clock (void)$/;"	f	file:
clock	.\main.c	417;"	d	file:
close	.\entry.c	70;"	d	file:
closeTagFile	.\entry.c	/^extern void closeTagFile (const boolean resize)$/;"	f
closedir	.\mac.c	/^int closedir(DIR *dirp)$/;"	f
combinePathAndFile	.\routines.c	/^extern vString *combinePathAndFile ($/;"	f
common_op_match_null_string_p	.\regex.c	/^common_op_match_null_string_p (p, end, reg_info)$/;"	f	file:
compareString	.\strlist.c	/^static boolean compareString ($/;"	f	file:
compareStringInsensitive	.\strlist.c	/^static boolean compareStringInsensitive ($/;"	f	file:
compareTags	.\sort.c	/^static int compareTags (const void *const one, const void *const two)$/;"	f	file:
compareTagsFolded	.\sort.c	/^static int compareTagsFolded(const void *const one, const void *const two)$/;"	f	file:
compileRegex	.\lregex.c	/^static regex_t* compileRegex (const char* const regexp, const char* const flags)$/;"	f	file:
compile_range	.\regex.c	/^compile_range (p_ptr, pend, translate, syntax, b)$/;"	f	file:
compile_stack_elt_t	.\regex.c	/^} compile_stack_elt_t;$/;"	t	typeref:struct:__anon58	file:
compile_stack_type	.\regex.c	/^} compile_stack_type;$/;"	t	typeref:struct:__anon59	file:
concat	.\routines.c	/^static char* concat (const char *s1, const char *s2, const char *s3)$/;"	f	file:
conditionalInfo	.\get.c	/^} conditionalInfo;$/;"	t	typeref:struct:sConditionalInfo	file:
constructParentString	.\python.c	/^static boolean constructParentString(NestingLevels *nls, int indent,$/;"	f	file:
context	.\c.c	/^	tokenInfo*	context;        \/* accumulated scope of current statement *\/$/;"	m	struct:sStatementInfo	file:
cookedArgs	.\options.h	/^} cookedArgs;$/;"	t	typeref:struct:sCookedArgs
copyBytes	.\entry.c	/^extern void copyBytes (FILE* const fromFp, FILE* const toFp, const long size)$/;"	f
copyFile	.\entry.c	/^extern void copyFile (const char *const from, const char *const to, const long size)$/;"	f
copyName	.\readtags.c	/^static void copyName (tagFile *const file)$/;"	f	file:
copyToken	.\c.c	/^static void copyToken (tokenInfo *const dest, const tokenInfo *const src)$/;"	f	file:
copyToken	.\jscript.c	/^static void copyToken (tokenInfo *const dest, tokenInfo *const src)$/;"	f	file:
count	.\entry.h	/^	unsigned int count;        \/* number of additional extension flags *\/$/;"	m	struct:sTagFields
count	.\fortran.c	/^	unsigned int count;$/;"	m	struct:__anon20	file:
count	.\lregex.c	/^	unsigned int count;$/;"	m	struct:__anon30	file:
count	.\readtags.h	/^		unsigned short count;$/;"	m	struct:__anon54::__anon56
count	.\strlist.h	/^	unsigned int count;$/;"	m	struct:sStringList
cppBeginStatement	.\get.c	/^extern void cppBeginStatement (void)$/;"	f
cppEndStatement	.\get.c	/^extern void cppEndStatement (void)$/;"	f
cppGetc	.\get.c	/^extern int cppGetc (void)$/;"	f
cppInit	.\get.c	/^extern void cppInit (const boolean state, const boolean hasAtLiteralStrings)$/;"	f
cppState	.\get.c	/^} cppState;$/;"	t	typeref:struct:sCppState	file:
cppTerminate	.\get.c	/^extern void cppTerminate (void)$/;"	f
cppUngetc	.\get.c	/^extern void cppUngetc (const int c)$/;"	f
createPascalTag	.\pascal.c	/^static void createPascalTag ($/;"	f	file:
createRegexTag	.\parse.h	/^typedef void (*createRegexTag) (const vString* const name);$/;"	t
createTags	.\c.c	/^static void createTags (const unsigned int nestLevel,$/;"	f	file:
createTagsForAmigaWildcard	.\main.c	/^static boolean createTagsForAmigaWildcard (const char *const pattern)$/;"	f	file:
createTagsForArgs	.\main.c	/^static boolean createTagsForArgs (cookedArgs *const args)$/;"	f	file:
createTagsForEntry	.\main.c	/^static boolean createTagsForEntry (const char *const entryName)$/;"	f	file:
createTagsForFile	.\parse.c	/^static boolean createTagsForFile ($/;"	f	file:
createTagsForWildcardArg	.\main.c	/^static boolean createTagsForWildcardArg (const char *const arg)$/;"	f	file:
createTagsForWildcardEntry	.\main.c	/^static boolean createTagsForWildcardEntry ($/;"	f	file:
createTagsForWildcardUsingFindfirst	.\main.c	/^static boolean createTagsForWildcardUsingFindfirst (const char *const pattern)$/;"	f	file:
createTagsFromFileInput	.\main.c	/^static boolean createTagsFromFileInput (FILE *const fp, const boolean filter)$/;"	f	file:
createTagsFromListFile	.\main.c	/^static boolean createTagsFromListFile (const char *const fileName)$/;"	f	file:
createTagsWithFallback	.\parse.c	/^static boolean createTagsWithFallback ($/;"	f	file:
csharpKind	.\c.c	/^} csharpKind;$/;"	t	typeref:enum:__anon13	file:
csharpTagKind	.\c.c	/^static csharpKind csharpTagKind (const tagType type)$/;"	f	file:
currentConditional	.\get.c	/^static conditionalInfo *currentConditional (void)$/;"	f	file:
currentExtensions	.\parse.h	/^	stringList* currentExtensions; \/* current list of extensions *\/$/;"	m	struct:__anon37
currentLine	.\read.h	/^	const unsigned char* currentLine;  \/* current line being worked on *\/$/;"	m	struct:sInputFile
currentPatterns	.\parse.h	/^	stringList* currentPatterns;   \/* current list of file name patterns *\/$/;"	m	struct:__anon37
currentdrive	.\routines.c	129;"	d	file:
currentdrive	.\routines.c	133;"	d	file:
currentdrive	.\routines.c	135;"	d	file:
currentdrive	.\routines.c	137;"	d	file:
custom_expand	.\qdos.c	/^int custom_expand (char * param, char ***argvptr, int *argcptr)$/;"	f
d_name	.\e_mac.h	/^	char d_name[64];$/;"	m	struct:dirent
dbp	.\pascal.c	/^static const unsigned char* dbp;$/;"	v	file:
debug	.\debug.h	29;"	d
debug	.\regex.c	/^static int debug = 0;$/;"	v	file:
debugCppIgnore	.\debug.c	/^extern void debugCppIgnore (const boolean ignore)$/;"	f
debugCppNest	.\debug.c	/^extern void debugCppNest (const boolean begin, const unsigned int level)$/;"	f
debugEntry	.\debug.c	/^extern void debugEntry (const tagEntryInfo *const tag)$/;"	f
debugLevel	.\options.h	/^	long debugLevel;        \/* -D  debugging output *\/$/;"	m	struct:sOptionValues
debugParseNest	.\debug.c	/^extern void debugParseNest (const boolean increase, const unsigned int level)$/;"	f
debugPrintf	.\debug.c	/^extern void debugPrintf ($/;"	f
debugPutc	.\debug.c	/^extern void debugPutc (const int level, const int c)$/;"	f
declString	.\c.c	/^static const char *declString (const declType declaration)$/;"	f	file:
declToTagType	.\c.c	/^static tagType declToTagType (const declType declaration)$/;"	f	file:
declType	.\c.c	/^} declType;$/;"	t	typeref:enum:eDeclaration	file:
declaration	.\c.c	/^	declType	declaration;    \/* specifier associated with TOKEN_SPEC *\/$/;"	m	struct:sStatementInfo	file:
decorator	.\plugin_helpers.py	/^    def decorator(func):$/;"	f	function:threaded
deleteAllStatements	.\c.c	/^static void deleteAllStatements (void)$/;"	f	file:
deleteStatement	.\c.c	/^static void deleteStatement (void)$/;"	f	file:
deleteToken	.\c.c	/^static void deleteToken (tokenInfo *const token)$/;"	f	file:
deleteToken	.\eiffel.c	/^static void deleteToken (tokenInfo *const token)$/;"	f	file:
deleteToken	.\fortran.c	/^static void deleteToken (tokenInfo *const token)$/;"	f	file:
deleteToken	.\jscript.c	/^static void deleteToken (tokenInfo *const token)$/;"	f	file:
deleteToken	.\sql.c	/^static void deleteToken (tokenInfo *const token)$/;"	f	file:
description	.\lregex.c	/^	char* description;$/;"	m	struct:sKind	file:
description	.\options.c	/^	const char *description;$/;"	m	struct:sOptionDescription	file:
description	.\parse.h	/^	const char* description;  \/* displayed in --help output *\/$/;"	m	struct:sKindOption
determineInterpreter	.\parse.c	/^static vString* determineInterpreter (const char* const cmd)$/;"	f	file:
dev_t	.\e_mac.h	/^typedef unsigned long  dev_t;$/;"	t
directive	.\get.c	/^	} directive;$/;"	m	struct:sCppState	typeref:struct:sCppState::sDirective	file:
directiveDefine	.\get.c	/^static void directiveDefine (const int c)$/;"	f	file:
directiveHash	.\get.c	/^static boolean directiveHash (const int c)$/;"	f	file:
directiveIf	.\get.c	/^static boolean directiveIf (const int c)$/;"	f	file:
directivePragma	.\get.c	/^static void directivePragma (int c)$/;"	f	file:
directory	.\entry.h	/^	char *directory;$/;"	m	struct:eTagFile
dirent	.\e_mac.h	/^struct dirent {$/;"	s
disableLanguageKinds	.\parse.c	/^static void disableLanguageKinds (const langType language)$/;"	f	file:
disableRegexKinds	.\lregex.c	/^extern void disableRegexKinds (const langType language __unused__)$/;"	f
discardTypeList	.\c.c	/^static void discardTypeList (tokenInfo *const token)$/;"	f	file:
doesFileExist	.\routines.c	/^extern boolean doesFileExist (const char *const fileName)$/;"	f
done_in_main	.\plugin_helpers.py	/^    def done_in_main(*args, **kw):$/;"	f	function:in_main
dummy_failure_jump	.\regex.c	/^  dummy_failure_jump,$/;"	e	enum:__anon57	file:
duplicate	.\readtags.c	/^static char *duplicate (const char *str)$/;"	f	file:
duplicate	.\regex.c	/^  duplicate,$/;"	e	enum:__anon57	file:
eAwkKinds	.\awk.c	/^typedef enum eAwkKinds {$/;"	g	file:
eCalloc	.\routines.c	/^extern void *eCalloc (const size_t count, const size_t size)$/;"	f
eCharacters	.\read.h	/^enum eCharacters {$/;"	g
eCppLimits	.\get.c	/^enum eCppLimits {$/;"	g	file:
eDebugLevels	.\debug.h	/^enum eDebugLevels {$/;"	g
eDeclaration	.\c.c	/^typedef enum eDeclaration {$/;"	g	file:
eErrorTypes	.\routines.h	/^enum eErrorTypes { FATAL = 1, WARNING = 2, PERROR = 4 };$/;"	g
eException	.\c.c	/^typedef enum eException {$/;"	g	file:
eException	.\eiffel.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	g	file:
eException	.\fortran.c	/^typedef enum eException {$/;"	g	file:
eException	.\jscript.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	g	file:
eException	.\sql.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	g	file:
eException	.\verilog.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	g	file:
eFortranLineType	.\fortran.c	/^typedef enum eFortranLineType {$/;"	g	file:
eFree	.\routines.c	/^extern void eFree (void *const ptr)$/;"	f
eImplementation	.\c.c	/^typedef enum eImplementation {$/;"	g	file:
eKeywordId	.\c.c	/^typedef enum eKeywordId {$/;"	g	file:
eKeywordId	.\eiffel.c	/^typedef enum eKeywordId {$/;"	g	file:
eKeywordId	.\fortran.c	/^typedef enum eKeywordId {$/;"	g	file:
eKeywordId	.\jscript.c	/^typedef enum eKeywordId {$/;"	g	file:
eKeywordId	.\sql.c	/^typedef enum eKeywordId {$/;"	g	file:
eLocate	.\options.h	/^typedef enum eLocate {$/;"	g
eMalloc	.\routines.c	/^extern void *eMalloc (const size_t size)$/;"	f
eOptionLimits	.\options.c	/^enum eOptionLimits {$/;"	g	file:
eRealloc	.\routines.c	/^extern void *eRealloc (void *const ptr, const size_t size)$/;"	f
eStat	.\routines.c	/^extern fileStatus *eStat (const char *const fileName)$/;"	f
eStatFree	.\routines.c	/^extern void eStatFree (fileStatus *status)$/;"	f
eState	.\get.c	/^enum eState {$/;"	g	file:
eStrdup	.\routines.c	/^extern char* eStrdup (const char* str)$/;"	f
eTagFile	.\entry.h	/^typedef struct eTagFile {$/;"	s
eTagScope	.\c.c	/^typedef enum eTagScope {$/;"	g	file:
eTagType	.\c.c	/^typedef enum eTagType {$/;"	g	file:
eTagType	.\fortran.c	/^typedef enum eTagType {$/;"	g	file:
eTokenType	.\c.c	/^typedef enum eTokenType {$/;"	g	file:
eTokenType	.\eiffel.c	/^typedef enum eTokenType {$/;"	g	file:
eTokenType	.\fortran.c	/^typedef enum eTokenType {$/;"	g	file:
eTokenType	.\jscript.c	/^typedef enum eTokenType {$/;"	g	file:
eTokenType	.\sql.c	/^typedef enum eTokenType {$/;"	g	file:
eVisibilityType	.\c.c	/^typedef enum eVisibilityType {$/;"	g	file:
eiffelKind	.\eiffel.c	/^} eiffelKind;$/;"	t	typeref:enum:__anon16	file:
emitRubyTag	.\ruby.c	/^static void emitRubyTag (vString* name, rubyKind kind)$/;"	f	file:
enableLanguage	.\parse.c	/^extern void enableLanguage (const langType language, const boolean state)$/;"	f
enableLanguageKind	.\parse.c	/^static boolean enableLanguageKind ($/;"	f	file:
enableLanguages	.\parse.c	/^extern void enableLanguages (const boolean state)$/;"	f
enableRegexKind	.\lregex.c	/^extern boolean enableRegexKind ($/;"	f
enabled	.\lregex.c	/^	boolean enabled;$/;"	m	struct:sKind	file:
enabled	.\parse.h	/^	boolean enabled;               \/* currently enabled? *\/$/;"	m	struct:__anon37
enabled	.\parse.h	/^	boolean enabled;          \/* are tags for kind enabled? *\/$/;"	m	struct:sKindOption
end	.\regex.h	/^  regoff_t *end;$/;"	m	struct:re_registers
endEtagsFile	.\entry.c	/^extern void endEtagsFile (const char *const name)$/;"	f
endbuf	.\regex.c	/^  endbuf,$/;"	e	enum:__anon57	file:
endline	.\regex.c	/^  endline,$/;"	e	enum:__anon57	file:
endtoken	.\pascal.c	64;"	d	file:
ent	.\e_mac.h	/^	struct dirent ent;$/;"	m	struct:__anon19	typeref:struct:__anon19::dirent
enterUnnamedScope	.\ruby.c	/^static void enterUnnamedScope (void)$/;"	f	file:
eof	.\read.h	/^	boolean     eof;           \/* have we reached the end of file? *\/$/;"	m	struct:sInputFile
erlangKind	.\erlang.c	/^} erlangKind;$/;"	t	typeref:enum:__anon18	file:
error	.\routines.c	/^extern void error ($/;"	f
errorSelection	.\routines.h	/^typedef int errorSelection;$/;"	t
error_number	.\readtags.h	/^		int error_number;$/;"	m	struct:__anon49::__anon50
errout	.\e_msoft.h	17;"	d
errout	.\general.h	48;"	d
etags	.\entry.h	/^	} etags;$/;"	m	struct:eTagFile	typeref:struct:eTagFile::sEtags
etags	.\options.h	/^	boolean etags;          \/* -e  output Emacs style tags file *\/$/;"	m	struct:sOptionValues
etagsInclude	.\main.c	/^static boolean etagsInclude (void)$/;"	f	file:
etagsInclude	.\options.h	/^	stringList* etagsInclude;\/* --etags-include  list of TAGS files to include*\/$/;"	m	struct:sOptionValues
ever_matched_something	.\regex.c	/^    unsigned ever_matched_something : 1;$/;"	m	struct:__anon61::__anon62	file:
exCmd	.\options.h	/^} exCmd;$/;"	t	typeref:enum:eLocate
exactn	.\regex.c	/^  exactn = 1,$/;"	e	enum:__anon57	file:
exception_t	.\c.c	/^} exception_t;$/;"	t	typeref:enum:eException	file:
exception_t	.\eiffel.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	t	typeref:enum:eException	file:
exception_t	.\fortran.c	/^} exception_t;$/;"	t	typeref:enum:eException	file:
exception_t	.\jscript.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	t	typeref:enum:eException	file:
exception_t	.\sql.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	t	typeref:enum:eException	file:
exception_t	.\verilog.c	/^typedef enum eException { ExceptionNone, ExceptionEOF } exception_t;$/;"	t	typeref:enum:eException	file:
exists	.\routines.h	/^	boolean exists;$/;"	m	struct:__anon65
exit_block	.\argproc.c	/^	} exit_block =$/;"	v	typeref:struct:exit_control_block	file:
exit_control_block	.\argproc.c	/^static struct exit_control_block$/;"	s	file:
exit_handler	.\argproc.c	/^static exit_handler (status)$/;"	f	file:
exit_routine	.\argproc.c	/^	int	(*exit_routine) ();$/;"	m	struct:exit_control_block	file:
exit_status	.\argproc.c	/^	int exit_status;$/;"	m	struct:exit_control_block	file:
expand_wild_cards	.\argproc.c	/^static expand_wild_cards (item, head, tail, count)$/;"	f	file:
extensionFields	.\entry.h	/^	} extensionFields;  \/* list of extension fields*\/$/;"	m	struct:sTagEntryInfo	typeref:struct:sTagEntryInfo::__anon17
extensionFields	.\options.h	/^	struct sExtFields extensionFields;\/* --fields  extension field control *\/$/;"	m	struct:sOptionValues	typeref:struct:sOptionValues::sExtFields
extensionFields	.\readtags.c	/^static int extensionFields;$/;"	v	file:
extensions	.\parse.h	/^	const char *const *extensions; \/* list of default extensions *\/$/;"	m	struct:__anon37
externalSortTags	.\sort.c	/^extern void externalSortTags (const boolean toStdout)$/;"	f
extract_name	.\basic.c	/^static char const *extract_name (char const *pos, vString * name)$/;"	f	file:
extract_name	.\lua.c	/^static void extract_name (const char *begin, const char *end, vString *name)$/;"	f	file:
extract_number	.\regex.c	/^extract_number (dest, source)$/;"	f	file:
extract_number_and_incr	.\regex.c	/^extract_number_and_incr (destination, source)$/;"	f	file:
fail_stack_elt_t	.\regex.c	/^typedef const unsigned char *fail_stack_elt_t;$/;"	t	file:
fail_stack_type	.\regex.c	/^} fail_stack_type;$/;"	t	typeref:struct:__anon60	file:
failedSort	.\sort.c	/^static void failedSort (FILE *const fp, const char* msg)$/;"	f	file:
false	.\regex.c	237;"	d	file:
fastmap	.\regex.h	/^  char *fastmap;$/;"	m	struct:re_pattern_buffer
fastmap_accurate	.\regex.h	/^  unsigned fastmap_accurate : 1;$/;"	m	struct:re_pattern_buffer
featureName	.\eiffel.c	/^	vString*  featureName;$/;"	m	struct:sTokenInfo	file:
ff_name	.\e_msoft.h	72;"	d
ffblk	.\e_msoft.h	70;"	d
fgetpos	.\routines.c	/^extern int fgetpos (FILE *stream, fpos_t *pos)$/;"	f
field	.\entry.c	282;"	d	file:
fields	.\readtags.c	/^	} fields;$/;"	m	struct:sTagFile	typeref:struct:sTagFile::__anon45	file:
fields	.\readtags.h	/^	} fields;$/;"	m	struct:__anon54	typeref:struct:__anon54::__anon56
file	.\e_mac.h	/^	FSSpec file;$/;"	m	struct:__anon19
file	.\entry.h	/^	struct sMax { size_t line, tag, file; } max;$/;"	m	struct:eTagFile::sMax
file	.\readtags.h	/^	const char *file;$/;"	m	struct:__anon54
file	.\readtags.h	/^	} file;$/;"	m	struct:__anon49	typeref:struct:__anon49::__anon51
fileArgs	.\args.h	/^		} fileArgs;$/;"	m	union:sArgs::__anon2	typeref:struct:sArgs::__anon2::sFileArgs
fileClose	.\read.c	/^extern void fileClose (void)$/;"	f
fileEOF	.\read.c	/^extern boolean fileEOF (void)$/;"	f
fileExtension	.\routines.c	/^extern const char *fileExtension (const char *const fileName)$/;"	f
fileGetc	.\eiffel.c	/^static int fileGetc (void)$/;"	f	file:
fileGetc	.\read.c	/^extern int fileGetc (void)$/;"	f
fileList	.\options.h	/^	char *fileList;         \/* -L  name of file containing names of files *\/$/;"	m	struct:sOptionValues
fileNameMatched	.\strlist.c	/^static boolean fileNameMatched ($/;"	f	file:
fileNames	.\options.h	/^	boolean fileNames;      \/* include tags for source file names *\/$/;"	m	struct:sInclude
fileNewline	.\read.c	/^static void fileNewline (void)$/;"	f	file:
fileOpen	.\read.c	/^extern boolean fileOpen (const char *const fileName, const langType language)$/;"	f
filePosition	.\c.c	/^	fpos_t        filePosition;  \/* file position of line containing name *\/$/;"	m	struct:sTokenInfo	file:
filePosition	.\entry.h	/^	fpos_t      filePosition;     \/* file position of line containing tag *\/$/;"	m	struct:sTagEntryInfo
filePosition	.\fortran.c	/^	fpos_t filePosition;$/;"	m	struct:sTokenInfo	file:
filePosition	.\jscript.c	/^	fpos_t 			filePosition;$/;"	m	struct:sTokenInfo	file:
filePosition	.\read.h	/^	fpos_t      filePosition;  \/* file position of current line *\/$/;"	m	struct:sInputFile
filePosition	.\sql.c	/^	fpos_t filePosition;$/;"	m	struct:sTokenInfo	file:
fileReadLine	.\read.c	/^extern const unsigned char *fileReadLine (void)$/;"	f
fileScope	.\entry.h	/^		const char* fileScope;$/;"	m	struct:sTagEntryInfo::__anon17
fileScope	.\options.h	/^	boolean fileScope;      \/* include tags of file scope only *\/$/;"	m	struct:sInclude
fileScope	.\options.h	/^	boolean fileScope;$/;"	m	struct:sExtFields
fileScope	.\readtags.h	/^	short fileScope;$/;"	m	struct:__anon54
fileStatus	.\routines.h	/^} fileStatus; $/;"	t	typeref:struct:__anon65
fileUngetc	.\eiffel.c	/^static int fileUngetc (c)$/;"	f	file:
fileUngetc	.\read.c	/^extern void fileUngetc (int c)$/;"	f
files	.\main.c	/^static struct { long files, lines, bytes; } Totals = { 0, 0, 0 };$/;"	m	struct:__anon32	file:
filesRequired	.\options.c	/^extern boolean filesRequired (void)$/;"	f
filter	.\options.h	/^	boolean filter;         \/* --filter  behave as filter: files in, tags out *\/$/;"	m	struct:sOptionValues
filterTerminator	.\options.h	/^	char* filterTerminator; \/* --filter-terminator  string to output *\/$/;"	m	struct:sOptionValues
find	.\readtags.c	/^static tagResult find (tagFile *const file, tagEntry *const entry,$/;"	f	file:
findAsmTags	.\asm.c	/^static void findAsmTags (void)$/;"	f	file:
findAsmTags	.\whatever\asm.c	/^static void findAsmTags (void)$/;"	f	file:
findAspTags	.\asp.c	/^static void findAspTags (void)$/;"	f	file:
findAwkTags	.\awk.c	/^static void findAwkTags (void)$/;"	f	file:
findBasicTags	.\basic.c	/^static void findBasicTags (void)$/;"	f	file:
findBetaTags	.\beta.c	/^static void findBetaTags (void)$/;"	f	file:
findBinary	.\readtags.c	/^static tagResult findBinary (tagFile *const file)$/;"	f	file:
findCTags	.\c.c	/^static boolean findCTags (const unsigned int passCount)$/;"	f	file:
findCmdTerm	.\jscript.c	/^static void findCmdTerm (tokenInfo *const token)$/;"	f	file:
findCmdTerm	.\sql.c	/^static void findCmdTerm (tokenInfo *const token, const boolean check_first)$/;"	f	file:
findDefinitionOrClass	.\python.c	/^static const char *findDefinitionOrClass (const char *cp)$/;"	f	file:
findEiffelTags	.\eiffel.c	/^static void findEiffelTags (void)$/;"	f	file:
findErlangTags	.\erlang.c	/^static void findErlangTags (void)$/;"	f	file:
findFeatureEnd	.\eiffel.c	/^static void findFeatureEnd (tokenInfo *const token)$/;"	f	file:
findFirstMatchBefore	.\readtags.c	/^static tagResult findFirstMatchBefore (tagFile *const file)$/;"	f	file:
findFirstNonMatchBefore	.\readtags.c	/^static void findFirstNonMatchBefore (tagFile *const file)$/;"	f	file:
findFortranTags	.\fortran.c	/^static boolean findFortranTags (const unsigned int passCount)$/;"	f	file:
findJsTags	.\jscript.c	/^static void findJsTags (void)$/;"	f	file:
findKeyword	.\eiffel.c	/^static void findKeyword (tokenInfo *const token, const keywordId keyword)$/;"	f	file:
findLispTags	.\lisp.c	/^static void findLispTags (void)$/;"	f	file:
findLuaTags	.\lua.c	/^static void findLuaTags (void)$/;"	f	file:
findMakeTags	.\make.c	/^static void findMakeTags (void)$/;"	f	file:
findNext	.\readtags.c	/^static tagResult findNext (tagFile *const file, tagEntry *const entry)$/;"	f	file:
findNextIdentifier	.\sml.c	/^static smlKind findNextIdentifier (const unsigned char **cp)$/;"	f	file:
findPascalTags	.\pascal.c	/^static void findPascalTags (void)$/;"	f	file:
findPerlTags	.\perl.c	/^static void findPerlTags (void)$/;"	f	file:
findPythonTags	.\python.c	/^static void findPythonTags (void)$/;"	f	file:
findReferences	.\eiffel.c	/^static void findReferences (void)$/;"	f	file:
findRegexTags	.\lregex.c	/^extern void findRegexTags (void)$/;"	f
findRubyTags	.\ruby.c	/^static void findRubyTags (void)$/;"	f	file:
findSchemeTags	.\scheme.c	/^static void findSchemeTags (void)$/;"	f	file:
findScopeHierarchy	.\c.c	/^static void findScopeHierarchy (vString *const string,$/;"	f	file:
findSequential	.\readtags.c	/^static tagResult findSequential (tagFile *const file)$/;"	f	file:
findShTags	.\sh.c	/^static void findShTags (void)$/;"	f	file:
findSmlTags	.\sml.c	/^static void findSmlTags (void)$/;"	f	file:
findSqlTags	.\sql.c	/^static void findSqlTags (void)$/;"	f	file:
findTag	.\readtags.c	/^static void findTag (const char *const name, const int options)$/;"	f	file:
findTag	.\verilog.c	/^static void findTag (vString *const name)$/;"	f	file:
findTclTags	.\tcl.c	/^static void findTclTags (void)$/;"	f	file:
findToken	.\eiffel.c	/^static void findToken (tokenInfo *const token, const tokenType type)$/;"	f	file:
findToken	.\sql.c	/^static void findToken (tokenInfo *const token, const tokenType type)$/;"	f	file:
findVerilogTags	.\verilog.c	/^static void findVerilogTags (void)$/;"	f	file:
findVimTags	.\vim.c	/^static void findVimTags (void)$/;"	f	file:
find_tags_relative_to	.\ctags_plugin.py	/^def find_tags_relative_to(view):$/;"	f
findfirst_t	.\e_msoft.h	53;"	d
findfirst_t	.\e_msoft.h	55;"	d
findfirst_t	.\e_msoft.h	69;"	d
fixup_alt_jump	.\regex.c	/^  pattern_offset_t fixup_alt_jump;$/;"	m	struct:__anon58	file:
flink	.\argproc.c	/^	struct exit_control_block *flink;$/;"	m	struct:exit_control_block	typeref:struct:exit_control_block::exit_control_block	file:
followLinks	.\options.h	/^	boolean followLinks;    \/* --link  follow symbolic links? *\/$/;"	m	struct:sOptionValues
fopen	.\e_mac.h	137;"	d
fopen	.\mac.c	192;"	d	file:
format	.\readtags.c	/^	short format;$/;"	m	struct:sTagFile	file:
format	.\readtags.h	/^			short format;$/;"	m	struct:__anon49::__anon51
format_tag_for_quickopen	.\ctags_plugin.py	/^def format_tag_for_quickopen(tag):$/;"	f
fp	.\args.h	/^			FILE* fp;$/;"	m	struct:sArgs::__anon2::sFileArgs
fp	.\entry.h	/^		FILE *fp;$/;"	m	struct:eTagFile::sEtags
fp	.\entry.h	/^	FILE *fp;$/;"	m	struct:eTagFile
fp	.\read.h	/^	FILE       *fp;            \/* stream used for reading the file *\/$/;"	m	struct:sInputFile
fp	.\readtags.c	/^	FILE* fp;$/;"	m	struct:sTagFile	file:
fpos_t	.\general.h	106;"	d
freeKeywordTable	.\keyword.c	/^extern void freeKeywordTable (void)$/;"	f
freeList	.\options.c	/^extern void freeList (stringList** const pList)$/;"	f
freeNestingLevels	.\python.c	/^static void freeNestingLevels(NestingLevels *nls)$/;"	f	file:
freeOptionResources	.\options.c	/^extern void freeOptionResources (void)$/;"	f
freeParserResources	.\parse.c	/^extern void freeParserResources (void)$/;"	f
freeRegexResources	.\lregex.c	/^extern void freeRegexResources (void)$/;"	f
freeRoutineResources	.\routines.c	/^extern void freeRoutineResources (void)$/;"	f
freeSourceFileResources	.\read.c	/^extern void freeSourceFileResources (void)$/;"	f
freeString	.\options.c	/^static void freeString (char **const pString)$/;"	f	file:
freeTagFileResources	.\entry.c	/^extern void freeTagFileResources (void)$/;"	f
freebasic_keywords	.\basic.c	/^static KeyWord freebasic_keywords[] = {$/;"	v	file:
fsetpos	.\routines.c	/^extern int fsetpos (FILE *stream, fpos_t const *pos)$/;"	f
function	.\lregex.c	/^			regexCallback function;$/;"	m	struct:__anon26::__anon27::__anon29	file:
get	.\ctags.py	/^    def get(self, path):$/;"	m	class:CTagsCache
getBooleanOption	.\options.c	/^static boolean getBooleanOption ($/;"	f	file:
getChar	.\fortran.c	/^static int getChar (void)$/;"	f	file:
getDirectiveNestLevel	.\get.c	/^extern unsigned int getDirectiveNestLevel (void)$/;"	f
getExecutableName	.\routines.c	/^extern const char *getExecutableName (void)$/;"	f
getExecutablePath	.\routines.c	/^extern const char *getExecutablePath (void)$/;"	f
getExtensionLanguage	.\parse.c	/^static langType getExtensionLanguage (const char *const extension)$/;"	f	file:
getFileLanguage	.\parse.c	/^extern langType getFileLanguage (const char *const fileName)$/;"	f
getFixedFormChar	.\fortran.c	/^static int getFixedFormChar (void)$/;"	f	file:
getFreeFormChar	.\fortran.c	/^static int getFreeFormChar (void)$/;"	f	file:
getHashTable	.\keyword.c	/^static hashEntry **getHashTable (void)$/;"	f	file:
getHashTableEntry	.\keyword.c	/^static hashEntry *getHashTableEntry (unsigned long hashedValue)$/;"	f	file:
getInputFileName	.\read.h	35;"	d
getInputFilePosition	.\read.h	36;"	d
getInputLineNumber	.\read.h	34;"	d
getInterpreterLanguage	.\parse.c	/^static langType getInterpreterLanguage (const char *const fileName)$/;"	f	file:
getLanguageName	.\parse.c	/^extern const char *getLanguageName (const langType language)$/;"	f
getLineType	.\fortran.c	/^static lineType getLineType (void)$/;"	f	file:
getNamedLanguage	.\parse.c	/^extern langType getNamedLanguage (const char *const name)$/;"	f
getPatternLanguage	.\parse.c	/^static langType getPatternLanguage (const char *const fileName)$/;"	f	file:
getSourceFileName	.\read.h	37;"	d
getSourceFileTagPath	.\read.h	38;"	d
getSourceLanguage	.\read.h	39;"	d
getSourceLanguageName	.\read.h	40;"	d
getSourceLineNumber	.\read.h	41;"	d
get_path	.\mac.c	/^static int get_path(const char* in_unix_path, unsigned char* out_mac_path)$/;"	f	file:
get_tags_for_field	.\ctags.py	/^def get_tags_for_field(field, tag_file, index, column=0):$/;"	f
getcwd	.\mac.c	/^char* getcwd(char* out_path, int out_path_len)$/;"	f
getcwd	.\routines.c	128;"	d	file:
getredirection	.\argproc.c	/^getredirection (ac, av)$/;"	f
gid_t	.\e_mac.h	/^typedef unsigned long  gid_t;$/;"	t
gotArgs	.\c.c	/^	boolean		gotArgs;        \/* was a list of parameters parsed yet? *\/$/;"	m	struct:sStatementInfo	file:
gotName	.\c.c	/^	boolean		gotName;        \/* was a name parsed yet? *\/$/;"	m	struct:sStatementInfo	file:
gotParenName	.\c.c	/^	boolean		gotParenName;   \/* was a name inside parentheses parsed yet? *\/$/;"	m	struct:sStatementInfo	file:
gotoFirstLogicalTag	.\readtags.c	/^static void gotoFirstLogicalTag (tagFile *const file)$/;"	f	file:
group_in_compile_stack	.\regex.c	/^group_in_compile_stack (compile_stack, regnum)$/;"	f	file:
group_match_null_string_p	.\regex.c	/^group_match_null_string_p (p, end, reg_info)$/;"	f	file:
growFields	.\readtags.c	/^static tagResult growFields (tagFile *const file)$/;"	f	file:
growString	.\readtags.c	/^static int growString (vstring *s)$/;"	f	file:
hackReject	.\sh.c	/^static boolean hackReject (const vString* const tagName)$/;"	f	file:
handleDirective	.\get.c	/^static boolean handleDirective (const int c)$/;"	f	file:
handler	.\options.c	/^	parametricOptionHandler handler;  \/* routine to handle option *\/$/;"	m	struct:__anon34	file:
hasAtLiteralStrings	.\get.c	/^	boolean hasAtLiteralStrings; \/* supports @"c:\\" strings *\/$/;"	m	struct:sCppState	file:
hashEntry	.\keyword.c	/^} hashEntry;$/;"	t	typeref:struct:sHashEntry	file:
hashValue	.\keyword.c	/^static unsigned long hashValue (const char *const string)$/;"	f	file:
haveQualifyingName	.\c.c	/^	boolean		haveQualifyingName;  \/* do we have a name we are considering? *\/$/;"	m	struct:sStatementInfo	file:
headerExt	.\options.h	/^	stringList* headerExt;  \/* -h  header extensions *\/$/;"	m	struct:sOptionValues
iFileGetLine	.\read.c	/^static vString *iFileGetLine (void)$/;"	f	file:
iFileGetc	.\read.c	/^static int iFileGetc (void)$/;"	f	file:
id	.\c.c	/^	keywordId id;$/;"	m	struct:sKeywordDesc	file:
id	.\eiffel.c	/^	keywordId id;$/;"	m	struct:sKeywordDesc	file:
id	.\fortran.c	/^	keywordId id;$/;"	m	struct:sKeywordDesc	file:
id	.\jscript.c	/^	keywordId id;$/;"	m	struct:sKeywordDesc	file:
id	.\parse.h	/^	unsigned int id;               \/* id assigned to language *\/$/;"	m	struct:__anon37
id	.\sql.c	/^	keywordId id;$/;"	m	struct:sKeywordDesc	file:
identarray	.\beta.c	/^static const char identarray [256] = {$/;"	v	file:
if0	.\options.h	/^	boolean if0;            \/* --if0  examine code within "#if 0" branch *\/$/;"	m	struct:sOptionValues
ifdef	.\get.c	/^		conditionalInfo ifdef [MaxCppNestingLevel];$/;"	m	struct:sCppState::sDirective	file:
ignore	.\options.h	/^	stringList* ignore;     \/* -I  name of file containing tokens to ignore *\/$/;"	m	struct:sOptionValues
ignoreAllBranches	.\get.c	/^	boolean ignoreAllBranches;  \/* ignoring parent conditional branch *\/$/;"	m	struct:sConditionalInfo	file:
ignoreTag	.\jscript.c	/^	boolean			ignoreTag;$/;"	m	struct:sTokenInfo	file:
ignorecase	.\readtags.c	/^			short ignorecase;$/;"	m	struct:sTagFile::__anon44	file:
ignoring	.\get.c	/^	boolean ignoring;           \/* current ignore state *\/$/;"	m	struct:sConditionalInfo	file:
impType	.\c.c	/^} impType;$/;"	t	typeref:enum:eImplementation	file:
implementation	.\c.c	/^	impType		implementation; \/* abstract or concrete implementation? *\/$/;"	m	struct:sStatementInfo	file:
implementation	.\entry.h	/^		const char* implementation;$/;"	m	struct:sTagEntryInfo::__anon17
implementation	.\options.h	/^	boolean implementation;$/;"	m	struct:sExtFields
implementationString	.\c.c	/^static const char *implementationString (const impType imp)$/;"	f	file:
inFunction	.\c.c	/^	boolean     inFunction;     \/* are we inside of a function? *\/$/;"	m	struct:sStatementInfo	file:
in_main	.\plugin_helpers.py	/^def in_main(f):$/;"	f
include	.\options.h	/^	struct sInclude include;\/* --extra  extra tag inclusion *\/$/;"	m	struct:sOptionValues	typeref:struct:sOptionValues::sInclude
includeExtensionFlags	.\entry.c	56;"	d	file:
includeTag	.\c.c	/^static boolean includeTag (const tagType type, const boolean isFileScope)$/;"	f	file:
includeTag	.\fortran.c	/^static boolean includeTag (const tagType type)$/;"	f	file:
includingDefineTags	.\c.c	/^extern boolean includingDefineTags (void)$/;"	f
indentation	.\python.c	/^	int indentation;$/;"	m	struct:NestingLevel	file:
index	.\e_mac.h	/^	int index;$/;"	m	struct:__anon19
index_tag_file	.\ctags.py	/^def index_tag_file(tag_file, column=0):$/;"	f
inheritance	.\entry.h	/^		const char* inheritance;$/;"	m	struct:sTagEntryInfo::__anon17
inheritance	.\options.h	/^	boolean inheritance;$/;"	m	struct:sExtFields
inheritingDeclaration	.\c.c	/^static boolean inheritingDeclaration (declType decl)$/;"	f	file:
initMemberInfo	.\c.c	/^static void initMemberInfo (statementInfo *const st)$/;"	f	file:
initOnly	.\options.c	/^	boolean initOnly;   \/* option must be specified before any files *\/$/;"	m	struct:__anon34	file:
initOnly	.\options.c	/^	boolean initOnly;   \/* option must be specified before any files *\/$/;"	m	struct:__anon35	file:
initOptions	.\options.c	/^extern void initOptions (void)$/;"	f
initParenInfo	.\c.c	/^static void initParenInfo (parenInfo *const info)$/;"	f	file:
initStatement	.\c.c	/^static void initStatement (statementInfo *const st, statementInfo *const parent)$/;"	f	file:
initTagEntry	.\entry.c	/^extern void initTagEntry (tagEntryInfo *const e, const char *const name)$/;"	f
initToken	.\c.c	/^static void initToken (tokenInfo* const token)$/;"	f	file:
init_syntax_once	.\regex.c	/^init_syntax_once ()$/;"	f	file:
initialize	.\asm.c	/^static void initialize (const langType language)$/;"	f	file:
initialize	.\eiffel.c	/^static void initialize (const langType language)$/;"	f	file:
initialize	.\fortran.c	/^static void initialize (const langType language)$/;"	f	file:
initialize	.\jscript.c	/^static void initialize (const langType language)$/;"	f	file:
initialize	.\parse.h	/^	parserInitialize initialize;   \/* initialization routine, if needed *\/$/;"	m	struct:__anon37
initialize	.\readtags.c	/^static tagFile *initialize (const char *const filePath, tagFileInfo *const info)$/;"	f	file:
initialize	.\sql.c	/^static void initialize (const langType language)$/;"	f	file:
initialize	.\verilog.c	/^static void initialize (const langType language)$/;"	f	file:
initialize	.\whatever\asm.c	/^static void initialize (const langType language)$/;"	f	file:
initializeCParser	.\c.c	/^static void initializeCParser (const langType language)$/;"	f	file:
initializeCppParser	.\c.c	/^static void initializeCppParser (const langType language)$/;"	f	file:
initializeCsharpParser	.\c.c	/^static void initializeCsharpParser (const langType language)$/;"	f	file:
initializeJavaParser	.\c.c	/^static void initializeJavaParser (const langType language)$/;"	f	file:
initializeParsers	.\parse.c	/^static void initializeParsers (void)$/;"	f	file:
initializeParsing	.\parse.c	/^extern void initializeParsing (void)$/;"	f
initializeVeraParser	.\c.c	/^static void initializeVeraParser (const langType language)$/;"	f	file:
initialized	.\readtags.c	/^	short initialized;$/;"	m	struct:sTagFile	file:
inner_group_offset	.\regex.c	/^  pattern_offset_t inner_group_offset;$/;"	m	struct:__anon58	file:
ino_t	.\e_mac.h	/^typedef unsigned long  ino_t;$/;"	t
inputFile	.\read.h	/^} inputFile;$/;"	t	typeref:struct:sInputFile
insert_op1	.\regex.c	/^insert_op1 (op, loc, arg, end)$/;"	f	file:
insert_op2	.\regex.c	/^insert_op2 (op, loc, arg1, arg2, end)$/;"	f	file:
insideEnumBody	.\c.c	38;"	d	file:
insideInterface	.\fortran.c	/^static boolean insideInterface (void)$/;"	f	file:
installCobolRegex	.\cobol.c	/^static void installCobolRegex (const langType language)$/;"	f	file:
installHeaderListDefaults	.\options.c	/^static void installHeaderListDefaults (void)$/;"	f	file:
installHtmlRegex	.\html.c	/^static void installHtmlRegex (const langType language)$/;"	f	file:
installLanguageMapDefault	.\parse.c	/^extern void installLanguageMapDefault (const langType language)$/;"	f
installLanguageMapDefaults	.\parse.c	/^extern void installLanguageMapDefaults (void)$/;"	f
installPHPRegex	.\php.c	/^static void installPHPRegex (const langType language)$/;"	f	file:
installRexxRegex	.\rexx.c	/^static void installRexxRegex (const langType language)$/;"	f	file:
installSlangRegex	.\slang.c	/^static void installSlangRegex (const langType language)$/;"	f	file:
installYaccRegex	.\yacc.c	/^static void installYaccRegex (const langType language)$/;"	f	file:
internalSortTags	.\sort.c	/^extern void internalSortTags (const boolean toStdout)$/;"	f
intoken	.\pascal.c	63;"	d	file:
invalidContents	.\c.c	/^	boolean invalidContents;$/;"	m	struct:sParenInfo	file:
isAbsolutePath	.\routines.c	/^extern boolean isAbsolutePath (const char *const path)$/;"	f
isAmigaDirectory	.\routines.c	/^static boolean isAmigaDirectory (const char *const name)$/;"	f	file:
isBlank	.\fortran.c	36;"	d	file:
isBraceFormat	.\get.c	/^extern boolean isBraceFormat (void)$/;"	f
isCmdTerm	.\sql.c	/^static boolean isCmdTerm (tokenInfo *const token)$/;"	f	file:
isComment	.\get.c	/^static Comment isComment (void)$/;"	f	file:
isCompoundOption	.\options.c	60;"	d	file:
isContextualKeyword	.\c.c	/^static boolean isContextualKeyword (const tokenInfo *const token)$/;"	f	file:
isContextualStatement	.\c.c	/^static boolean isContextualStatement (const statementInfo *const st)$/;"	f	file:
isCtagsLine	.\entry.c	/^static boolean isCtagsLine (const char *const line)$/;"	f	file:
isDefineOperator	.\asm.c	/^static boolean isDefineOperator (const vString *const operator)$/;"	f	file:
isDefineOperator	.\whatever\asm.c	/^static boolean isDefineOperator (const vString *const operator)$/;"	f	file:
isDestinationStdout	.\main.c	/^extern boolean isDestinationStdout (void)$/;"	f
isDirectory	.\routines.h	/^	boolean isDirectory;$/;"	m	struct:__anon65
isEtagsLine	.\entry.c	/^static boolean isEtagsLine (const char *const line)$/;"	f	file:
isExcludedFile	.\options.c	/^extern boolean isExcludedFile (const char* const name)$/;"	f
isExecutable	.\routines.h	/^	boolean isExecutable;$/;"	m	struct:__anon65
isExported	.\eiffel.c	/^	boolean   isExported;$/;"	m	struct:sTokenInfo	file:
isExternCDecl	.\c.c	40;"	d	file:
isFalse	.\options.c	/^static boolean isFalse (const char *parameter)$/;"	f	file:
isFileEntry	.\entry.h	/^	boolean     isFileEntry;      \/* is this just an entry for a file name? *\/$/;"	m	struct:sTagEntryInfo
isFileScope	.\entry.h	/^	boolean     isFileScope;      \/* is tag visibile only within source file? *\/$/;"	m	struct:sTagEntryInfo
isFileScope	.\fortran.c	/^static boolean isFileScope (const tagType type)$/;"	f	file:
isFreeOperatorChar	.\eiffel.c	41;"	d	file:
isGeneric	.\eiffel.c	/^static boolean isGeneric (tokenInfo *const token)$/;"	f	file:
isHeader	.\read.h	/^		boolean  isHeader;       \/* is source file a header file? *\/$/;"	m	struct:sInputFile::sSource
isHeaderFile	.\read.h	43;"	d
isHighChar	.\c.c	45;"	d	file:
isIdentChar	.\jscript.c	/^static boolean isIdentChar (const int c)$/;"	f	file:
isIdentChar	.\sql.c	/^static boolean isIdentChar (const int c)$/;"	f	file:
isIdentChar1	.\jscript.c	/^static boolean isIdentChar1 (const int c)$/;"	f	file:
isIdentChar1	.\sql.c	/^static boolean isIdentChar1 (const int c)$/;"	f	file:
isIdentifier	.\make.c	/^static boolean isIdentifier (int c)$/;"	f	file:
isIdentifier	.\perl.c	/^static boolean isIdentifier (int c)$/;"	f	file:
isIdentifier	.\sml.c	/^static boolean isIdentifier (int c)$/;"	f	file:
isIdentifier1	.\perl.c	/^static boolean isIdentifier1 (int c)$/;"	f	file:
isIdentifierCharacter	.\erlang.c	/^static boolean isIdentifierCharacter (int c)$/;"	f	file:
isIdentifierCharacter	.\python.c	/^static boolean isIdentifierCharacter (int c)$/;"	f	file:
isIdentifierCharacter	.\verilog.c	/^static boolean isIdentifierCharacter (const int c)$/;"	f	file:
isIdentifierFirstCharacter	.\erlang.c	/^static boolean isIdentifierFirstCharacter (int c)$/;"	f	file:
isIdentifierFirstCharacter	.\python.c	/^static boolean isIdentifierFirstCharacter (int c)$/;"	f	file:
isIdentifierMatch	.\eiffel.c	/^static boolean isIdentifierMatch ($/;"	f	file:
isIgnore	.\get.c	/^static boolean isIgnore (void)$/;"	f	file:
isIgnoreBranch	.\get.c	/^static boolean isIgnoreBranch (void)$/;"	f	file:
isIgnoreToken	.\options.c	/^extern boolean isIgnoreToken ($/;"	f
isIgnoredDeclaration	.\fortran.c	/^static boolean isIgnoredDeclaration (tokenInfo *const token)$/;"	f	file:
isIncludeFile	.\options.c	/^extern boolean isIncludeFile (const char *const fileName)$/;"	f
isInitialSymbolCharacter	.\asm.c	/^static boolean isInitialSymbolCharacter (int c)$/;"	f	file:
isInitialSymbolCharacter	.\whatever\asm.c	/^static boolean isInitialSymbolCharacter (int c)$/;"	f	file:
isKeyword	.\eiffel.c	44;"	d	file:
isKeyword	.\fortran.c	38;"	d	file:
isKeyword	.\jscript.c	38;"	d	file:
isKeyword	.\sql.c	47;"	d	file:
isKnrParamList	.\c.c	/^	boolean isKnrParamList;$/;"	m	struct:sParenInfo	file:
isLanguage	.\read.h	42;"	d
isMap	.\vim.c	/^static boolean isMap (const unsigned char* line)$/;"	f	file:
isMember	.\c.c	/^static boolean isMember (const statementInfo *const st)$/;"	f	file:
isNameCandidate	.\c.c	/^	boolean isNameCandidate;$/;"	m	struct:sParenInfo	file:
isNormalFile	.\routines.h	/^	boolean isNormalFile;$/;"	m	struct:__anon65
isOneOf	.\c.c	43;"	d	file:
isOption	.\options.h	/^	boolean isOption;$/;"	m	struct:sCookedArgs
isParamList	.\c.c	/^	boolean isParamList;$/;"	m	struct:sParenInfo	file:
isPathSeparator	.\routines.c	/^static boolean isPathSeparator (const int c)$/;"	f	file:
isPodWord	.\perl.c	/^static boolean isPodWord (const char *word)$/;"	f	file:
isPointer	.\c.c	/^	boolean		isPointer;      \/* is 'name' a pointer? *\/$/;"	m	struct:sStatementInfo	file:
isPointer	.\c.c	/^	boolean isPointer;$/;"	m	struct:sParenInfo	file:
isRecursiveLink	.\routines.c	/^extern boolean isRecursiveLink (const char* const dirName)$/;"	f
isSameFile	.\routines.c	/^extern boolean isSameFile (const char *const name1, const char *const name2)$/;"	f
isSecondaryKeyword	.\fortran.c	39;"	d	file:
isSetuid	.\routines.h	/^	boolean isSetuid;$/;"	m	struct:__anon65
isStatementEnd	.\c.c	/^static boolean isStatementEnd (const statementInfo *const st)$/;"	f	file:
isSubprogramPrefix	.\fortran.c	/^static boolean isSubprogramPrefix (tokenInfo *const token)$/;"	f	file:
isSubroutineDeclaration	.\perl.c	/^static boolean isSubroutineDeclaration (const unsigned char *cp)$/;"	f	file:
isSymbolCharacter	.\asm.c	/^static boolean isSymbolCharacter (int c)$/;"	f	file:
isSymbolCharacter	.\whatever\asm.c	/^static boolean isSymbolCharacter (int c)$/;"	f	file:
isSymbolicLink	.\routines.h	/^	boolean isSymbolicLink;$/;"	m	struct:__anon65
isTagFile	.\entry.c	/^static boolean isTagFile (const char *const filename)$/;"	f	file:
isTrue	.\options.c	/^static boolean isTrue (const char *parameter)$/;"	f	file:
isType	.\c.c	37;"	d	file:
isType	.\eiffel.c	43;"	d	file:
isType	.\fortran.c	37;"	d	file:
isType	.\jscript.c	37;"	d	file:
isType	.\sql.c	46;"	d	file:
isTypeSpec	.\fortran.c	/^static boolean isTypeSpec (tokenInfo *const token)$/;"	f	file:
isValid	.\c.c	/^	short isValid [5]; \/* indicates languages for which kw is valid *\/$/;"	m	struct:sKeywordDesc	file:
isValidTagAddress	.\entry.c	/^static boolean isValidTagAddress (const char *const excmd)$/;"	f	file:
isValidTypeSpecifier	.\c.c	/^static boolean isValidTypeSpecifier (const declType declaration)$/;"	f	file:
is_a_code_line	.\lua.c	/^static boolean is_a_code_line (const unsigned char *line)$/;"	f	file:
is_active	.\regex.c	/^    unsigned is_active : 1;$/;"	m	struct:__anon61::__anon62	file:
is_class	.\python.c	/^	boolean is_class;$/;"	m	struct:NestingLevel	file:
isascii	.\regex.c	131;"	d	file:
isbident	.\beta.c	31;"	d	file:
isident	.\eiffel.c	40;"	d	file:
isident	.\fortran.c	35;"	d	file:
isident	.\get.h	27;"	d
isident1	.\get.h	33;"	d
isspacetab	.\get.c	31;"	d	file:
item	.\args.h	/^			char* const* item;$/;"	m	struct:sArgs::__anon2::sArgvArgs
item	.\args.h	/^			const char* item;$/;"	m	struct:sArgs::__anon2::sStringArgs
item	.\args.h	/^	char* item;$/;"	m	struct:sArgs
item	.\options.h	/^	char* item;$/;"	m	struct:sCookedArgs
javaKind	.\c.c	/^} javaKind;$/;"	t	typeref:enum:__anon14	file:
javaTagKind	.\c.c	/^static javaKind javaTagKind (const tagType type)$/;"	f	file:
jsKind	.\jscript.c	/^} jsKind;$/;"	t	typeref:enum:__anon24	file:
jump	.\ctags_plugin.py	/^    def jump(self, view, args):$/;"	m	class:NavigateToDefinition
jump	.\regex.c	/^  jump, $/;"	e	enum:__anon57	file:
jump_n	.\regex.c	/^  jump_n,$/;"	e	enum:__anon57	file:
jump_past_alt	.\regex.c	/^  jump_past_alt,$/;"	e	enum:__anon57	file:
key	.\readtags.h	/^	const char *key;$/;"	m	struct:__anon53
keyword	.\asm.c	/^	opKeyword keyword;$/;"	m	struct:__anon5	file:
keyword	.\asm.c	/^	opKeyword keyword;$/;"	m	struct:__anon6	file:
keyword	.\c.c	/^	keywordId     keyword;$/;"	m	struct:sTokenInfo	file:
keyword	.\eiffel.c	/^	keywordId keyword;$/;"	m	struct:sTokenInfo	file:
keyword	.\fortran.c	/^	keywordId keyword;$/;"	m	struct:sTokenInfo	file:
keyword	.\jscript.c	/^	keywordId		keyword;$/;"	m	struct:sTokenInfo	file:
keyword	.\sml.c	/^	const char *keyword;$/;"	m	struct:__anon70	file:
keyword	.\sql.c	/^	keywordId	keyword;$/;"	m	struct:sTokenInfo	file:
keyword	.\verilog.c	/^	const char *keyword;$/;"	m	struct:__anon74	file:
keyword	.\whatever\asm.c	/^	opKeyword keyword;$/;"	m	struct:__anon78	file:
keyword	.\whatever\asm.c	/^	opKeyword keyword;$/;"	m	struct:__anon79	file:
keywordAssoc	.\verilog.c	/^} keywordAssoc;$/;"	t	typeref:struct:__anon74	file:
keywordDesc	.\c.c	/^} keywordDesc;$/;"	t	typeref:struct:sKeywordDesc	file:
keywordDesc	.\eiffel.c	/^} keywordDesc;$/;"	t	typeref:struct:sKeywordDesc	file:
keywordDesc	.\fortran.c	/^} keywordDesc;$/;"	t	typeref:struct:sKeywordDesc	file:
keywordDesc	.\jscript.c	/^} keywordDesc;$/;"	t	typeref:struct:sKeywordDesc	file:
keywordDesc	.\sql.c	/^} keywordDesc;$/;"	t	typeref:struct:sKeywordDesc	file:
keywordId	.\c.c	/^} keywordId;$/;"	t	typeref:enum:eKeywordId	file:
keywordId	.\eiffel.c	/^} keywordId;$/;"	t	typeref:enum:eKeywordId	file:
keywordId	.\fortran.c	/^} keywordId;$/;"	t	typeref:enum:eKeywordId	file:
keywordId	.\jscript.c	/^} keywordId;$/;"	t	typeref:enum:eKeywordId	file:
keywordId	.\sql.c	/^} keywordId;$/;"	t	typeref:enum:eKeywordId	file:
keywordString	.\c.c	/^static const char *keywordString (const keywordId keyword)$/;"	f	file:
kind	.\asm.c	/^	AsmKind kind;$/;"	m	struct:__anon6	file:
kind	.\basic.c	/^	BasicKind kind;$/;"	m	struct:__anon9	file:
kind	.\entry.h	/^	char        kind;             \/* single character representation of kind *\/$/;"	m	struct:sTagEntryInfo
kind	.\lregex.c	/^			struct sKind kind;$/;"	m	struct:__anon26::__anon27::__anon28	typeref:struct:__anon26::__anon27::__anon28::sKind	file:
kind	.\options.h	/^	boolean kind;$/;"	m	struct:sExtFields
kind	.\readtags.h	/^	const char *kind;$/;"	m	struct:__anon54
kind	.\sml.c	/^	smlKind kind;$/;"	m	struct:__anon70	file:
kind	.\verilog.c	/^	verilogKind kind;$/;"	m	struct:__anon74	file:
kind	.\whatever\asm.c	/^	AsmKind kind;$/;"	m	struct:__anon79	file:
kindCount	.\parse.h	/^	unsigned int kindCount;        \/* size of `kinds' list *\/$/;"	m	struct:__anon37
kindKey	.\options.h	/^	boolean kindKey;$/;"	m	struct:sExtFields
kindLong	.\options.h	/^	boolean kindLong;       \/* --kind-long *\/$/;"	m	struct:sOptionValues
kindLong	.\options.h	/^	boolean kindLong;$/;"	m	struct:sExtFields
kindName	.\entry.h	/^	const char *kindName;         \/* kind of tag *\/$/;"	m	struct:sTagEntryInfo
kindOption	.\parse.h	/^} kindOption;$/;"	t	typeref:struct:sKindOption
kinds	.\parse.h	/^	kindOption* kinds;             \/* tag kinds handled by parser *\/$/;"	m	struct:__anon37
label	.\entry.h	/^	const char *const *label;  \/* list of labels for extension flags *\/$/;"	m	struct:sTagFields
langKindOption	.\parse.c	/^static kindOption *langKindOption (const langType language, const int flag)$/;"	f	file:
langType	.\parse.h	/^typedef int langType;$/;"	t
language	.\entry.h	/^	const char* language;         \/* language of source file *\/$/;"	m	struct:sTagEntryInfo
language	.\keyword.c	/^	langType language;$/;"	m	struct:sHashEntry	file:
language	.\options.h	/^	boolean language;$/;"	m	struct:sExtFields
language	.\options.h	/^	langType language;      \/* --lang specified language override *\/$/;"	m	struct:sOptionValues
language	.\read.h	/^		langType language;       \/* language of source file *\/$/;"	m	struct:sInputFile::sSource
language	.\read.h	/^	langType    language;      \/* language of input file *\/$/;"	m	struct:sInputFile
laststart_offset	.\regex.c	/^  pattern_offset_t laststart_offset;  $/;"	m	struct:__anon58	file:
length	.\parse.h	/^	size_t length;  \/* length of match *\/$/;"	m	struct:__anon38
length	.\vstring.h	/^	size_t  length;  \/* size of buffer used *\/$/;"	m	struct:sVString
letter	.\lregex.c	/^	char letter;$/;"	m	struct:sKind	file:
letter	.\parse.h	/^	int letter;               \/* kind letter *\/$/;"	m	struct:sKindOption
levels	.\python.c	/^	NestingLevel *levels;$/;"	m	struct:NestingLevels	file:
line	.\entry.h	/^	struct sMax { size_t line, tag, file; } max;$/;"	m	struct:eTagFile::sMax
line	.\read.h	/^	vString    *line;          \/* last line read from file *\/$/;"	m	struct:sInputFile
line	.\readtags.c	/^	vstring line;$/;"	m	struct:sTagFile	file:
lineBreak	.\debug.c	/^extern void lineBreak (void) {}  \/* provides a line-specified break point *\/$/;"	f
lineDirectives	.\options.h	/^	boolean lineDirectives; \/* --linedirectives  process #line directives *\/$/;"	m	struct:sOptionValues
lineMode	.\args.h	/^	boolean lineMode;$/;"	m	struct:sArgs
lineNumber	.\c.c	/^	unsigned long lineNumber;    \/* line number of tag *\/$/;"	m	struct:sTokenInfo	file:
lineNumber	.\entry.h	/^	unsigned long lineNumber;     \/* line number of tag *\/$/;"	m	struct:sTagEntryInfo
lineNumber	.\fortran.c	/^	unsigned long lineNumber;$/;"	m	struct:sTokenInfo	file:
lineNumber	.\jscript.c	/^	unsigned long 	lineNumber;$/;"	m	struct:sTokenInfo	file:
lineNumber	.\options.h	/^	boolean lineNumber;$/;"	m	struct:sExtFields
lineNumber	.\read.h	/^		unsigned long lineNumber;\/* line number in the source file *\/$/;"	m	struct:sInputFile::sSource
lineNumber	.\read.h	/^	unsigned long lineNumber;  \/* line number in the input file *\/$/;"	m	struct:sInputFile
lineNumber	.\readtags.h	/^		unsigned long lineNumber;$/;"	m	struct:__anon54::__anon55
lineNumber	.\sql.c	/^	unsigned long lineNumber;$/;"	m	struct:sTokenInfo	file:
lineNumberEntry	.\entry.h	/^	boolean     lineNumberEntry;  \/* pattern or line number entry *\/$/;"	m	struct:sTagEntryInfo
lineType	.\fortran.c	/^} lineType;$/;"	t	typeref:enum:eFortranLineType	file:
lines	.\main.c	/^static struct { long files, lines, bytes; } Totals = { 0, 0, 0 };$/;"	m	struct:__anon32	file:
lispKind	.\lisp.c	/^} lispKind;$/;"	t	typeref:enum:__anon25	file:
list	.\fortran.c	/^	tokenInfo* list;$/;"	m	struct:__anon20	file:
list	.\readtags.c	/^			tagExtensionField *list;$/;"	m	struct:sTagFile::__anon45	file:
list	.\readtags.h	/^		tagExtensionField *list;$/;"	m	struct:__anon54::__anon56
list	.\strlist.h	/^	vString    **list;$/;"	m	struct:sStringList
listTags	.\readtags.c	/^static void listTags (void)$/;"	f	file:
list_item	.\argproc.c	/^struct list_item$/;"	s	file:
locate	.\options.h	/^	exCmd locate;           \/* --excmd  EX command used to locate tag *\/$/;"	m	struct:sOptionValues
longOption	.\options.h	/^	boolean longOption;$/;"	m	struct:sCookedArgs
lookupKeyword	.\keyword.c	/^extern int lookupKeyword (const char *const string, langType language)$/;"	f
lstat	.\e_mac.h	139;"	d
lstat	.\routines.c	174;"	d	file:
luaKind	.\lua.c	/^} luaKind;$/;"	t	typeref:enum:__anon31	file:
main	.\eiffel.c	/^extern int main (int argc, char** argv)$/;"	f
main	.\main.c	/^extern int main (int __unused__ argc, char **argv)$/;"	f
main	.\readtags.c	/^extern int main (int argc, char **argv)$/;"	f
makeAsmTag	.\asm.c	/^static void makeAsmTag ($/;"	f	file:
makeAsmTag	.\whatever\asm.c	/^static void makeAsmTag ($/;"	f	file:
makeBetaTag	.\beta.c	/^static void makeBetaTag (const char* const name, const betaKind kind)$/;"	f	file:
makeClassTag	.\jscript.c	/^static void makeClassTag (tokenInfo *const token)$/;"	f	file:
makeClassTag	.\python.c	/^static void makeClassTag (vString *const class, vString *const inheritance,$/;"	f	file:
makeConstTag	.\jscript.c	/^static void makeConstTag (tokenInfo *const token, const jsKind kind)$/;"	f	file:
makeConstTag	.\sql.c	/^static void makeConstTag (tokenInfo *const token, const sqlKind kind)$/;"	f	file:
makeDefineTag	.\get.c	/^static void makeDefineTag (const char *const name)$/;"	f	file:
makeEiffelClassTag	.\eiffel.c	/^static void makeEiffelClassTag (tokenInfo *const token)$/;"	f	file:
makeEiffelFeatureTag	.\eiffel.c	/^static void makeEiffelFeatureTag (tokenInfo *const token)$/;"	f	file:
makeEiffelLocalTag	.\eiffel.c	/^static void makeEiffelLocalTag (tokenInfo *const token)$/;"	f	file:
makeExtraTagEntry	.\c.c	/^static void makeExtraTagEntry (const tagType type, tagEntryInfo *const e,$/;"	f	file:
makeFileTag	.\parse.c	/^static void makeFileTag (const char *const fileName)$/;"	f	file:
makeFortranTag	.\fortran.c	/^static void makeFortranTag (tokenInfo *const token, tagType tag)$/;"	f	file:
makeFunctionTag	.\jscript.c	/^static void makeFunctionTag (tokenInfo *const token)$/;"	f	file:
makeFunctionTag	.\python.c	/^static void makeFunctionTag (vString *const function,$/;"	f	file:
makeJsTag	.\jscript.c	/^static void makeJsTag (tokenInfo *const token, const jsKind kind)$/;"	f	file:
makeLabelTag	.\fortran.c	/^static void makeLabelTag (vString *const label)$/;"	f	file:
makeMemberTag	.\erlang.c	/^static void makeMemberTag ($/;"	f	file:
makePascalTag	.\pascal.c	/^static void makePascalTag (const tagEntryInfo* const tag)$/;"	f	file:
makeRegexTag	.\lregex.c	/^static void makeRegexTag ($/;"	f	file:
makeSimpleTag	.\parse.c	/^extern void makeSimpleTag ($/;"	f
makeSmlTag	.\sml.c	/^static void makeSmlTag (smlKind type, vString *name)$/;"	f	file:
makeSqlTag	.\sql.c	/^static void makeSqlTag (tokenInfo *const token, const sqlKind kind)$/;"	f	file:
makeTag	.\c.c	/^static void makeTag (const tokenInfo *const token,$/;"	f	file:
makeTagEntry	.\entry.c	/^extern void makeTagEntry (const tagEntryInfo *const tag)$/;"	f
makeTags	.\main.c	/^static void makeTags (cookedArgs *args)$/;"	f	file:
makeTclTag	.\tcl.c	/^static const unsigned char *makeTclTag ($/;"	f	file:
match	.\tcl.c	/^static boolean match (const unsigned char *line, const char *word)$/;"	f	file:
matchCallbackPattern	.\lregex.c	/^static void matchCallbackPattern ($/;"	f	file:
matchRegex	.\lregex.c	/^extern boolean matchRegex (const vString* const line, const langType language)$/;"	f
matchRegexPattern	.\lregex.c	/^static boolean matchRegexPattern (const vString* const line,$/;"	f	file:
matchTagPattern	.\lregex.c	/^static void matchTagPattern (const vString* const line,$/;"	f	file:
match_colon_label	.\basic.c	/^static void match_colon_label (char const *p)$/;"	f	file:
match_dot_label	.\basic.c	/^static void match_dot_label (char const *p)$/;"	f	file:
match_keyword	.\basic.c	/^static int match_keyword (const char *p, KeyWord const *kw)$/;"	f	file:
match_null_string_p	.\regex.c	/^    unsigned match_null_string_p : 2;$/;"	m	struct:__anon61::__anon62	file:
matched_something	.\regex.c	/^    unsigned matched_something : 1;$/;"	m	struct:__anon61::__anon62	file:
max	.\entry.h	/^	struct sMax { size_t line, tag, file; } max;$/;"	m	struct:eTagFile	typeref:struct:eTagFile::sMax
max	.\fortran.c	/^	unsigned int max;$/;"	m	struct:__anon20	file:
max	.\readtags.c	/^			unsigned short max;$/;"	m	struct:sTagFile::__anon45	file:
max	.\strlist.h	/^	unsigned int max;$/;"	m	struct:sStringList
maybe_pop_jump	.\regex.c	/^  maybe_pop_jump,$/;"	e	enum:__anon57	file:
member	.\c.c	/^	memberInfo	member;         \/* information regarding parent class\/struct *\/$/;"	m	struct:sStatementInfo	file:
memberInfo	.\c.c	/^} memberInfo;$/;"	t	typeref:struct:sMemberInfo	file:
method	.\ctags_plugin.py	/^    @classmethod$/;"	c	class:JumpBack
mfopen	.\mac.c	/^FILE* mfopen(const char* file, const char* mode)$/;"	f
mode_t	.\e_mac.h	/^typedef unsigned long  mode_t;$/;"	t
mstat	.\mac.c	/^int mstat(const char* file, struct stat* st)$/;"	f
n	.\python.c	/^	int n;$/;"	m	struct:NestingLevels	file:
name	.\c.c	/^	const char *name;$/;"	m	struct:sKeywordDesc	file:
name	.\c.c	/^	vString*      name;          \/* the name of the token *\/$/;"	m	struct:sTokenInfo	file:
name	.\eiffel.c	/^	const char *name;$/;"	m	struct:sKeywordDesc	file:
name	.\entry.h	/^		char *name;$/;"	m	struct:eTagFile::sEtags
name	.\entry.h	/^	char *name;$/;"	m	struct:eTagFile
name	.\entry.h	/^	const char *name;             \/* name of the tag *\/$/;"	m	struct:sTagEntryInfo
name	.\fortran.c	/^	const char *name;$/;"	m	struct:sKeywordDesc	file:
name	.\get.c	/^		vString * name;          \/* macro name *\/$/;"	m	struct:sCppState::sDirective	file:
name	.\jscript.c	/^	const char *name;$/;"	m	struct:sKeywordDesc	file:
name	.\lregex.c	/^	char* name;$/;"	m	struct:sKind	file:
name	.\options.c	/^	const char* name;   \/* name of option as specified by user *\/$/;"	m	struct:__anon34	file:
name	.\options.c	/^	const char* name;   \/* name of option as specified by user *\/$/;"	m	struct:__anon35	file:
name	.\parse.h	/^	char* name;                    \/* name of language *\/$/;"	m	struct:__anon37
name	.\parse.h	/^	const char* name;         \/* kind name *\/$/;"	m	struct:sKindOption
name	.\python.c	/^	vString *name;$/;"	m	struct:NestingLevel	file:
name	.\read.h	/^		vString *name;           \/* name to report for source file *\/$/;"	m	struct:sInputFile::sSource
name	.\read.h	/^	vString    *name;          \/* name of input file *\/$/;"	m	struct:sInputFile
name	.\readtags.c	/^			char *name;$/;"	m	struct:sTagFile::__anon44	file:
name	.\readtags.c	/^		char *name;$/;"	m	struct:sTagFile::__anon46	file:
name	.\readtags.c	/^	vstring name;$/;"	m	struct:sTagFile	file:
name	.\readtags.h	/^		const char *name;$/;"	m	struct:__anon49::__anon52
name	.\readtags.h	/^	const char *name;$/;"	m	struct:__anon54
name	.\routines.h	/^	char* name;$/;"	m	struct:__anon65
name	.\sql.c	/^	const char *name;$/;"	m	struct:sKeywordDesc	file:
nameComparison	.\readtags.c	/^static int nameComparison (tagFile *const file)$/;"	f	file:
nameLength	.\readtags.c	/^			size_t nameLength;$/;"	m	struct:sTagFile::__anon44	file:
name_pattern	.\lregex.c	/^			char *name_pattern;$/;"	m	struct:__anon26::__anon27::__anon28	file:
nest	.\c.c	/^static void nest (statementInfo *const st, const unsigned int nestLevel)$/;"	f	file:
nestLevel	.\get.c	/^		unsigned int nestLevel;  \/* level 0 is not used *\/$/;"	m	struct:sCppState::sDirective	file:
nestLevel	.\jscript.c	/^	int				nestLevel;$/;"	m	struct:sTokenInfo	file:
nestedArgs	.\c.c	/^	boolean nestedArgs;$/;"	m	struct:sParenInfo	file:
nesting	.\ruby.c	/^static stringList* nesting = 0;$/;"	v	file:
newEntry	.\keyword.c	/^static hashEntry *newEntry ($/;"	f	file:
newLine	.\read.h	/^	boolean     newLine;       \/* will the next character begin a new line? *\/$/;"	m	struct:sInputFile
newLowerString	.\routines.c	/^extern char* newLowerString (const char* str)$/;"	f
newNestingLevels	.\python.c	/^static NestingLevels *newNestingLevels(void)$/;"	f	file:
newStatement	.\c.c	/^static statementInfo *newStatement (statementInfo *const parent)$/;"	f	file:
newToken	.\c.c	/^static tokenInfo *newToken (void)$/;"	f	file:
newToken	.\eiffel.c	/^static tokenInfo *newToken (void)$/;"	f	file:
newToken	.\fortran.c	/^static tokenInfo *newToken (void)$/;"	f	file:
newToken	.\jscript.c	/^static tokenInfo *newToken (void)$/;"	f	file:
newToken	.\sql.c	/^static tokenInfo *newToken (void)$/;"	f	file:
newTokenFrom	.\fortran.c	/^static tokenInfo *newTokenFrom (tokenInfo *const token)$/;"	f	file:
newUpperString	.\routines.c	/^extern char* newUpperString (const char* str)$/;"	f
newline_anchor	.\regex.h	/^  unsigned newline_anchor : 1;$/;"	m	struct:re_pattern_buffer
next	.\argproc.c	/^	struct list_item *next;$/;"	m	struct:list_item	typeref:struct:list_item::list_item	file:
next	.\args.h	/^			const char* next;$/;"	m	struct:sArgs::__anon2::sStringArgs
next	.\keyword.c	/^	struct sHashEntry *next;$/;"	m	struct:sHashEntry	typeref:struct:sHashEntry::sHashEntry	file:
nextChar	.\make.c	/^static int nextChar (void)$/;"	f	file:
nextFileArg	.\args.c	/^static char* nextFileArg (FILE* const fp)$/;"	f	file:
nextFileLine	.\args.c	/^static char* nextFileLine (FILE* const fp)$/;"	f	file:
nextFileString	.\args.c	/^static char* nextFileString (const Arguments* const current, FILE* const fp)$/;"	f	file:
nextString	.\args.c	/^static char* nextString (const Arguments* const current, const char** const next)$/;"	f	file:
nextStringArg	.\args.c	/^static char *nextStringArg (const char** const next)$/;"	f	file:
nextStringLine	.\args.c	/^static char* nextStringLine (const char** const next)$/;"	f	file:
nextToken	.\c.c	/^static void nextToken (statementInfo *const st)$/;"	f	file:
nlink_t	.\e_mac.h	/^typedef short          nlink_t;$/;"	t
no_op	.\regex.c	/^  no_op = 0,$/;"	e	enum:__anon57	file:
no_sub	.\regex.h	/^  unsigned no_sub : 1;$/;"	m	struct:re_pattern_buffer
notVariable	.\c.c	/^	boolean		notVariable;    \/* has a variable declaration been disqualified ? *\/$/;"	m	struct:sStatementInfo	file:
not_bol	.\regex.h	/^  unsigned not_bol : 1;$/;"	m	struct:re_pattern_buffer
not_eol	.\regex.h	/^  unsigned not_eol : 1;$/;"	m	struct:re_pattern_buffer
notify_finished_parsing	.\ctags_plugin.py	/^def notify_finished_parsing(p):$/;"	f
notsyntaxspec	.\regex.c	/^  notsyntaxspec$/;"	e	enum:__anon57	file:
notwordbound	.\regex.c	/^  notwordbound	\/* Succeeds if not at a word boundary.  *\/$/;"	e	enum:__anon57	file:
notwordchar	.\regex.c	/^  notwordchar,	\/* Matches any char that is not a word-constituent.  *\/$/;"	e	enum:__anon57	file:
numTags	.\entry.h	/^	struct sNumTags { unsigned long added, prev; } numTags;$/;"	m	struct:eTagFile	typeref:struct:eTagFile::sNumTags
num_regs	.\regex.h	/^  unsigned num_regs;$/;"	m	struct:re_registers
onModified	.\ctags_plugin.py	/^    def onModified(self, view):$/;"	m	class:JumpBack
on_failure_jump	.\regex.c	/^  on_failure_jump,$/;"	e	enum:__anon57	file:
on_failure_keep_string_jump	.\regex.c	/^  on_failure_keep_string_jump,$/;"	e	enum:__anon57	file:
opKeyword	.\asm.c	/^} opKeyword;$/;"	t	typeref:enum:__anon4	file:
opKeyword	.\whatever\asm.c	/^} opKeyword;$/;"	t	typeref:enum:__anon77	file:
opKind	.\asm.c	/^} opKind;$/;"	t	typeref:struct:__anon6	file:
opKind	.\whatever\asm.c	/^} opKind;$/;"	t	typeref:struct:__anon79	file:
open	.\entry.c	69;"	d	file:
openTagFile	.\entry.c	/^extern void openTagFile (void)$/;"	f
opendir	.\mac.c	/^DIR *opendir(const char *dirname)$/;"	f
opened	.\readtags.h	/^		int opened;$/;"	m	struct:__anon49::__anon50
operator	.\asm.c	/^	const char *operator;$/;"	m	struct:__anon5	file:
operator	.\whatever\asm.c	/^	const char *operator;$/;"	m	struct:__anon78	file:
operatorKind	.\asm.c	/^static AsmKind operatorKind ($/;"	f	file:
operatorKind	.\whatever\asm.c	/^static AsmKind operatorKind ($/;"	f	file:
optionDescription	.\options.c	/^} optionDescription;$/;"	t	typeref:struct:sOptionDescription	file:
optionType	.\options.h	/^typedef enum { OPTION_NONE, OPTION_SHORT, OPTION_LONG } optionType;$/;"	t	typeref:enum:__anon36
optionValues	.\options.h	/^} optionValues;$/;"	t	typeref:struct:sOptionValues
pType	.\lregex.c	/^enum pType { PTRN_TAG, PTRN_CALLBACK };$/;"	g	file:
pValue	.\options.c	/^	boolean* pValue;    \/* pointer to option value *\/$/;"	m	struct:__anon35	file:
parameter	.\options.h	/^	const char* parameter;$/;"	m	struct:sCookedArgs
parameterCount	.\c.c	/^	unsigned int parameterCount;$/;"	m	struct:sParenInfo	file:
parametricOption	.\options.c	/^} parametricOption;$/;"	t	typeref:struct:__anon34	file:
parametricOptionHandler	.\options.c	/^typedef void (*parametricOptionHandler) (const char *const option, const char *const parameter);$/;"	t	file:
parenInfo	.\c.c	/^} parenInfo;$/;"	t	typeref:struct:sParenInfo	file:
parent	.\c.c	/^	struct sStatementInfo *parent;  \/* statement we are nested within *\/$/;"	m	struct:sStatementInfo	typeref:struct:sStatementInfo::sStatementInfo	file:
parentClasses	.\c.c	/^	vString*	parentClasses;  \/* parent classes *\/$/;"	m	struct:sStatementInfo	file:
parentDecl	.\c.c	35;"	d	file:
parseArguments	.\eiffel.c	/^static void parseArguments (tokenInfo *const token)$/;"	f	file:
parseAutogroup	.\vim.c	/^static void parseAutogroup (const unsigned char *line)$/;"	f	file:
parseBlock	.\jscript.c	/^static boolean parseBlock (tokenInfo *const token, tokenInfo *const parent)$/;"	f	file:
parseBlock	.\sql.c	/^static void parseBlock (tokenInfo *const token, const boolean local)$/;"	f	file:
parseBlockData	.\fortran.c	/^static void parseBlockData (tokenInfo *const token)$/;"	f	file:
parseCharacter	.\eiffel.c	/^static int parseCharacter (void)$/;"	f	file:
parseClass	.\eiffel.c	/^static void parseClass (tokenInfo *const token)$/;"	f	file:
parseClass	.\python.c	/^static void parseClass (const char *cp, vString *const class,$/;"	f	file:
parseCommand	.\vim.c	/^static boolean parseCommand (const unsigned char *line)$/;"	f	file:
parseComment	.\sql.c	/^static void parseComment (tokenInfo *const token)$/;"	f	file:
parseCommonNamelistStmt	.\fortran.c	/^static void parseCommonNamelistStmt (tokenInfo *const token, tagType type)$/;"	f	file:
parseComponentDefStmt	.\fortran.c	/^static void parseComponentDefStmt (tokenInfo *const token)$/;"	f	file:
parseConfigurationFileOptions	.\options.c	/^static void parseConfigurationFileOptions (void)$/;"	f	file:
parseConfigurationFileOptionsInDirectory	.\options.c	/^static void parseConfigurationFileOptionsInDirectory (const char* directory)$/;"	f	file:
parseConfigurationFileOptionsInDirectoryWithLeafname	.\options.c	/^static void parseConfigurationFileOptionsInDirectoryWithLeafname (const char* directory, const char* leafname)$/;"	f	file:
parseConvert	.\eiffel.c	/^static void parseConvert (tokenInfo *const token)$/;"	f	file:
parseDeclarationConstruct	.\fortran.c	/^static boolean parseDeclarationConstruct (tokenInfo *const token)$/;"	f	file:
parseDeclare	.\sql.c	/^static void parseDeclare (tokenInfo *const token, const boolean local)$/;"	f	file:
parseDeclareANSI	.\sql.c	/^static void parseDeclareANSI (tokenInfo *const token, const boolean local)$/;"	f	file:
parseDerivedTypeDef	.\fortran.c	/^static void parseDerivedTypeDef (tokenInfo *const token)$/;"	f	file:
parseDirective	.\erlang.c	/^static void parseDirective (const unsigned char *cp, vString *const module)$/;"	f	file:
parseDomain	.\sql.c	/^static void parseDomain (tokenInfo *const token)$/;"	f	file:
parseDrop	.\sql.c	/^static void parseDrop (tokenInfo *const token)$/;"	f	file:
parseEntityDecl	.\fortran.c	/^static void parseEntityDecl (tokenInfo *const token)$/;"	f	file:
parseEntityDeclList	.\fortran.c	/^static void parseEntityDeclList (tokenInfo *const token)$/;"	f	file:
parseEntityType	.\eiffel.c	/^static void parseEntityType (tokenInfo *const token)$/;"	f	file:
parseEntryStmt	.\fortran.c	/^static void parseEntryStmt (tokenInfo *const token)$/;"	f	file:
parseEnvironmentOptions	.\options.c	/^static void parseEnvironmentOptions (void)$/;"	f	file:
parseEscapedCharacter	.\eiffel.c	/^static int parseEscapedCharacter (void)$/;"	f	file:
parseEvent	.\sql.c	/^static void parseEvent (tokenInfo *const token)$/;"	f	file:
parseExecutionPart	.\fortran.c	/^static boolean parseExecutionPart (tokenInfo *const token)$/;"	f	file:
parseExport	.\eiffel.c	/^static void parseExport (tokenInfo *const token)$/;"	f	file:
parseExtensionFields	.\readtags.c	/^static void parseExtensionFields (tagFile *const file, tagEntry *const entry,$/;"	f	file:
parseFeature	.\eiffel.c	/^static boolean parseFeature (tokenInfo *const token)$/;"	f	file:
parseFeatureClauses	.\eiffel.c	/^static void parseFeatureClauses (tokenInfo *const token)$/;"	f	file:
parseFieldDefinition	.\fortran.c	/^static void parseFieldDefinition (tokenInfo *const token)$/;"	f	file:
parseFile	.\parse.c	/^extern boolean parseFile (const char *const fileName)$/;"	f
parseFileOptions	.\options.c	/^static boolean parseFileOptions (const char* const fileName)$/;"	f	file:
parseFreeOperator	.\eiffel.c	/^static void parseFreeOperator (vString *const string, const int firstChar)$/;"	f	file:
parseFunction	.\jscript.c	/^static void parseFunction (tokenInfo *const token)$/;"	f	file:
parseFunction	.\python.c	/^static void parseFunction (const char *cp, vString *const def,$/;"	f	file:
parseFunction	.\vim.c	/^static void parseFunction (const unsigned char *line)$/;"	f	file:
parseFunctionSubprogram	.\fortran.c	/^static void parseFunctionSubprogram (tokenInfo *const token)$/;"	f	file:
parseFunctionTag	.\erlang.c	/^static void parseFunctionTag (const unsigned char *cp, vString *const module)$/;"	f	file:
parseGeneralToken	.\c.c	/^static void parseGeneralToken (statementInfo *const st, const int c)$/;"	f	file:
parseGeneric	.\eiffel.c	/^static void parseGeneric (tokenInfo *const token, boolean declaration __unused__)$/;"	f	file:
parseIdentifier	.\c.c	/^static void parseIdentifier (statementInfo *const st, const int c)$/;"	f	file:
parseIdentifier	.\eiffel.c	/^static void parseIdentifier (vString *const string, const int firstChar)$/;"	f	file:
parseIdentifier	.\erlang.c	/^static const unsigned char *parseIdentifier ($/;"	f	file:
parseIdentifier	.\fortran.c	/^static void parseIdentifier (vString *const string, const int firstChar)$/;"	f	file:
parseIdentifier	.\jscript.c	/^static void parseIdentifier (vString *const string, const int firstChar)$/;"	f	file:
parseIdentifier	.\python.c	/^static const char *parseIdentifier (const char *cp, vString *const identifier)$/;"	f	file:
parseIdentifier	.\ruby.c	/^static rubyKind parseIdentifier ($/;"	f	file:
parseIdentifier	.\sml.c	/^static const unsigned char *parseIdentifier ($/;"	f	file:
parseIdentifier	.\sql.c	/^static void parseIdentifier (vString *const string, const int firstChar)$/;"	f	file:
parseIf	.\jscript.c	/^static void parseIf (tokenInfo *const token)$/;"	f	file:
parseImplicitPartStmt	.\fortran.c	/^static boolean parseImplicitPartStmt (tokenInfo *const token)$/;"	f	file:
parseIndex	.\sql.c	/^static void parseIndex (tokenInfo *const token)$/;"	f	file:
parseInherit	.\eiffel.c	/^static void parseInherit (tokenInfo *const token)$/;"	f	file:
parseInteger	.\eiffel.c	/^static vString *parseInteger (int c)$/;"	f	file:
parseInteger	.\fortran.c	/^static vString *parseInteger (int c)$/;"	f	file:
parseInterfaceBlock	.\fortran.c	/^static void parseInterfaceBlock (tokenInfo *const token)$/;"	f	file:
parseInternalSubprogramPart	.\fortran.c	/^static void parseInternalSubprogramPart (tokenInfo *const token)$/;"	f	file:
parseJavaAnnotation	.\c.c	/^static void parseJavaAnnotation (statementInfo *const st)$/;"	f	file:
parseJsFile	.\jscript.c	/^static void parseJsFile (tokenInfo *const token)$/;"	f	file:
parseKinds	.\lregex.c	/^static void parseKinds ($/;"	f	file:
parseLabel	.\sql.c	/^static void parseLabel (tokenInfo *const token)$/;"	f	file:
parseLet	.\vim.c	/^static void parseLet (const unsigned char *line)$/;"	f	file:
parseLine	.\jscript.c	/^static boolean parseLine (tokenInfo *const token, boolean is_inside_class)$/;"	f	file:
parseLineDirective	.\read.c	/^static boolean parseLineDirective (void)$/;"	f	file:
parseLocal	.\eiffel.c	/^static void parseLocal (tokenInfo *const token)$/;"	f	file:
parseLongOption	.\options.c	/^static void parseLongOption (cookedArgs *const args, const char *item)$/;"	f	file:
parseLoop	.\jscript.c	/^static void parseLoop (tokenInfo *const token)$/;"	f	file:
parseMLConn	.\sql.c	/^static void parseMLConn (tokenInfo *const token)$/;"	f	file:
parseMLTable	.\sql.c	/^static void parseMLTable (tokenInfo *const token)$/;"	f	file:
parseMainProgram	.\fortran.c	/^static void parseMainProgram (tokenInfo *const token)$/;"	f	file:
parseMap	.\fortran.c	/^static void parseMap (tokenInfo *const token)$/;"	f	file:
parseMap	.\vim.c	/^static boolean parseMap (const unsigned char *line)$/;"	f	file:
parseMethods	.\jscript.c	/^static void parseMethods (tokenInfo *const token, tokenInfo *const class)$/;"	f	file:
parseModule	.\fortran.c	/^static void parseModule (tokenInfo *const token)$/;"	f	file:
parseModuleTag	.\erlang.c	/^static void parseModuleTag (const unsigned char *cp, vString *const module)$/;"	f	file:
parseNumeric	.\eiffel.c	/^static vString *parseNumeric (int c)$/;"	f	file:
parseNumeric	.\fortran.c	/^static vString *parseNumeric (int c)$/;"	f	file:
parseOption	.\options.c	/^extern void parseOption (cookedArgs* const args)$/;"	f
parseOptions	.\options.c	/^extern void parseOptions (cookedArgs* const args)$/;"	f
parsePackage	.\sql.c	/^static void parsePackage (tokenInfo *const token)$/;"	f	file:
parseParens	.\c.c	/^static int parseParens (statementInfo *const st, parenInfo *const info)$/;"	f	file:
parseProgramUnit	.\fortran.c	/^static void parseProgramUnit (tokenInfo *const token)$/;"	f	file:
parsePublication	.\sql.c	/^static void parsePublication (tokenInfo *const token)$/;"	f	file:
parseQualifierSpecList	.\fortran.c	/^static void parseQualifierSpecList (tokenInfo *const token)$/;"	f	file:
parseRecord	.\sql.c	/^static void parseRecord (tokenInfo *const token)$/;"	f	file:
parseRename	.\eiffel.c	/^static void parseRename (tokenInfo *const token)$/;"	f	file:
parseRubyOperator	.\ruby.c	/^static boolean parseRubyOperator (vString* name, const unsigned char** cp)$/;"	f	file:
parseService	.\sql.c	/^static void parseService (tokenInfo *const token)$/;"	f	file:
parseShortOption	.\options.c	/^static void parseShortOption (cookedArgs *const args)$/;"	f	file:
parseSimple	.\sql.c	/^static void parseSimple (tokenInfo *const token, const sqlKind kind)$/;"	f	file:
parseSimpleTag	.\erlang.c	/^static void parseSimpleTag (const unsigned char *cp, erlangKind kind)$/;"	f	file:
parseSpecificationPart	.\fortran.c	/^static boolean parseSpecificationPart (tokenInfo *const token)$/;"	f	file:
parseSpecificationStmt	.\fortran.c	/^static boolean parseSpecificationStmt (tokenInfo *const token)$/;"	f	file:
parseSqlFile	.\sql.c	/^static void parseSqlFile (tokenInfo *const token)$/;"	f	file:
parseStatement	.\jscript.c	/^static boolean parseStatement (tokenInfo *const token, boolean is_inside_class)$/;"	f	file:
parseStatements	.\sql.c	/^static void parseStatements (tokenInfo *const token)$/;"	f	file:
parseStmtFunctionStmt	.\fortran.c	/^static boolean parseStmtFunctionStmt (tokenInfo *const token)$/;"	f	file:
parseString	.\eiffel.c	/^static void parseString (vString *const string)$/;"	f	file:
parseString	.\fortran.c	/^static void parseString (vString *const string, const int delimeter)$/;"	f	file:
parseString	.\jscript.c	/^static void parseString (vString *const string, const int delimiter)$/;"	f	file:
parseString	.\sql.c	/^static void parseString (vString *const string, const int delimiter)$/;"	f	file:
parseStructureStmt	.\fortran.c	/^static void parseStructureStmt (tokenInfo *const token)$/;"	f	file:
parseSubProgram	.\sql.c	/^static void parseSubProgram (tokenInfo *const token)$/;"	f	file:
parseSubprogram	.\fortran.c	/^static void parseSubprogram (tokenInfo *const token, const tagType tag)$/;"	f	file:
parseSubroutineSubprogram	.\fortran.c	/^static void parseSubroutineSubprogram (tokenInfo *const token)$/;"	f	file:
parseSwitch	.\jscript.c	/^static void parseSwitch (tokenInfo *const token)$/;"	f	file:
parseSynonym	.\sql.c	/^static void parseSynonym (tokenInfo *const token)$/;"	f	file:
parseTable	.\sql.c	/^static void parseTable (tokenInfo *const token)$/;"	f	file:
parseTagLine	.\readtags.c	/^static void parseTagLine (tagFile *file, tagEntry *const entry)$/;"	f	file:
parseTagRegex	.\lregex.c	/^static boolean parseTagRegex ($/;"	f	file:
parseTrigger	.\sql.c	/^static void parseTrigger (tokenInfo *const token)$/;"	f	file:
parseType	.\eiffel.c	/^static void parseType (tokenInfo *const token)$/;"	f	file:
parseType	.\sql.c	/^static void parseType (tokenInfo *const token)$/;"	f	file:
parseTypeDeclarationStmt	.\fortran.c	/^static void parseTypeDeclarationStmt (tokenInfo *const token)$/;"	f	file:
parseTypeSpec	.\fortran.c	/^static void parseTypeSpec (tokenInfo *const token)$/;"	f	file:
parseUnionStmt	.\fortran.c	/^static void parseUnionStmt (tokenInfo *const token)$/;"	f	file:
parseVariable	.\sql.c	/^static void parseVariable (tokenInfo *const token)$/;"	f	file:
parseView	.\sql.c	/^static void parseView (tokenInfo *const token)$/;"	f	file:
parseVimFile	.\vim.c	/^static void parseVimFile (const unsigned char *line)$/;"	f	file:
parseVimLine	.\vim.c	/^static boolean parseVimLine (const unsigned char *line)$/;"	f	file:
parse_tag_file	.\ctags.py	/^def parse_tag_file(tag_file):$/;"	f
parse_tag_lines	.\ctags.py	/^def parse_tag_lines(lines):$/;"	f
parser	.\parse.h	/^	simpleParser parser;           \/* simple parser (common case) *\/$/;"	m	struct:__anon37
parser2	.\parse.h	/^	rescanParser parser2;          \/* rescanning parser (unusual case) *\/$/;"	m	struct:__anon37
parserDefinition	.\parse.h	/^} parserDefinition;$/;"	t	typeref:struct:__anon37
parserDefinitionFunc	.\parse.h	/^typedef parserDefinition* (parserDefinitionFunc) (void);$/;"	t
parserInitialize	.\parse.h	/^typedef void (*parserInitialize) (langType language);$/;"	t
parserNew	.\parse.c	/^extern parserDefinition* parserNew (const char* name)$/;"	f
partial	.\readtags.c	/^			short partial;$/;"	m	struct:sTagFile::__anon44	file:
pascalKind	.\pascal.c	/^} pascalKind;$/;"	t	typeref:enum:__anon39	file:
path	.\read.h	/^	vString    *path;          \/* path of input file (if any) *\/$/;"	m	struct:sInputFile
pattern	.\lregex.c	/^	regex_t *pattern;$/;"	m	struct:__anon26	file:
pattern	.\readtags.h	/^		const char *pattern;$/;"	m	struct:__anon54::__anon55
patternSet	.\lregex.c	/^} patternSet;$/;"	t	typeref:struct:__anon30	file:
pattern_offset_t	.\regex.c	/^typedef int pattern_offset_t;$/;"	t	file:
patterns	.\lregex.c	/^	regexPattern *patterns;$/;"	m	struct:__anon30	file:
patterns	.\parse.h	/^	const char *const *patterns;   \/* list of default file name patterns *\/$/;"	m	struct:__anon37
perlKind	.\perl.c	/^} perlKind;$/;"	t	typeref:enum:__anon40	file:
phpKind	.\php.c	/^} phpKind;$/;"	t	typeref:enum:__anon41	file:
pipe_and_fork	.\argproc.c	/^static char *pipe_and_fork (cmd)$/;"	f	file:
plural	.\main.c	89;"	d	file:
popConditional	.\get.c	/^static boolean popConditional (void)$/;"	f	file:
pop_failure_jump	.\regex.c	/^  pop_failure_jump,$/;"	e	enum:__anon57	file:
pos	.\readtags.c	/^			off_t pos; $/;"	m	struct:sTagFile::__anon44	file:
pos	.\readtags.c	/^	off_t pos;$/;"	m	struct:sTagFile	file:
post_process_tag	.\ctags.py	/^def post_process_tag(search_obj):$/;"	f
prev	.\entry.h	/^	struct sNumTags { unsigned long added, prev; } numTags;$/;"	m	struct:eTagFile::sNumTags
prevToken	.\c.c	/^static tokenInfo *prevToken (const statementInfo *const st, unsigned int n)$/;"	f	file:
previewFirstOption	.\options.c	/^extern void previewFirstOption (cookedArgs* const args)$/;"	f
printBucket	.\keyword.c	/^static unsigned int printBucket (const unsigned int i)$/;"	f	file:
printEntry	.\keyword.c	/^static void printEntry (const hashEntry *const entry)$/;"	f	file:
printFeatureList	.\options.c	/^static void printFeatureList (void)$/;"	f	file:
printInvocationDescription	.\options.c	/^static void printInvocationDescription (void)$/;"	f	file:
printKeywordTable	.\keyword.c	/^extern void printKeywordTable (void)$/;"	f
printKinds	.\parse.c	/^static void printKinds (langType language, boolean indent)$/;"	f	file:
printLanguage	.\parse.c	/^static void printLanguage (const langType language)$/;"	f	file:
printLanguageKind	.\parse.c	/^static void printLanguageKind (const kindOption* const kind, boolean indent)$/;"	f	file:
printLanguageKinds	.\parse.c	/^extern void printLanguageKinds (const langType language)$/;"	f
printLanguageList	.\parse.c	/^extern void printLanguageList (void)$/;"	f
printLanguageMap	.\parse.c	/^extern void printLanguageMap (const langType language)$/;"	f
printLanguageMaps	.\parse.c	/^extern void printLanguageMaps (const langType language)$/;"	f
printMaps	.\parse.c	/^static void printMaps (const langType language)$/;"	f	file:
printOptionDescriptions	.\options.c	/^static void printOptionDescriptions (const optionDescription *const optDesc)$/;"	f	file:
printProgramIdentification	.\options.c	/^static void printProgramIdentification (void)$/;"	f	file:
printRegexKind	.\lregex.c	/^static void printRegexKind (const regexPattern *pat, unsigned int i, boolean indent)$/;"	f	file:
printRegexKinds	.\lregex.c	/^extern void printRegexKinds (const langType language __unused__, boolean indent __unused__)$/;"	f
printTag	.\readtags.c	/^static void printTag (const tagEntry *entry)$/;"	f	file:
printTotals	.\main.c	/^static void printTotals (const clock_t *const timeStamps)$/;"	f	file:
printTotals	.\options.h	/^	boolean printTotals;    \/* --totals  print cumulative statistics *\/$/;"	m	struct:sOptionValues
print_compiled_pattern	.\regex.c	/^print_compiled_pattern (bufp)$/;"	f
print_double_string	.\regex.c	/^print_double_string (where, string1, size1, string2, size2)$/;"	f
print_fastmap	.\regex.c	/^print_fastmap (fastmap)$/;"	f
print_partial_compiled_pattern	.\regex.c	/^print_partial_compiled_pattern (start, end)$/;"	f
print_string	.\lua.c	/^static void __unused__ print_string (char *p, char *q)$/;"	f	file:
processAngleBracket	.\c.c	/^static void processAngleBracket (void)$/;"	f	file:
processBooleanOption	.\options.c	/^static boolean processBooleanOption ($/;"	f	file:
processColon	.\c.c	/^static void processColon (statementInfo *const st)$/;"	f	file:
processEtagsInclude	.\options.c	/^static void processEtagsInclude ($/;"	f	file:
processExcludeOption	.\options.c	/^static void processExcludeOption ($/;"	f	file:
processExcmdOption	.\options.c	/^static void processExcmdOption ($/;"	f	file:
processExtraTagsOption	.\options.c	/^static void processExtraTagsOption ($/;"	f	file:
processFieldsOption	.\options.c	/^static void processFieldsOption ($/;"	f	file:
processFilterTerminatorOption	.\options.c	/^static void processFilterTerminatorOption ($/;"	f	file:
processFormatOption	.\options.c	/^static void processFormatOption ($/;"	f	file:
processHeaderListOption	.\options.c	/^static void processHeaderListOption (const int option, const char *parameter)$/;"	f	file:
processHelpOption	.\options.c	/^static void processHelpOption ($/;"	f	file:
processIgnoreOption	.\options.c	/^static void processIgnoreOption (const char *const list)$/;"	f	file:
processInitializer	.\c.c	/^static void processInitializer (statementInfo *const st)$/;"	f	file:
processInterface	.\c.c	/^static void processInterface (statementInfo *const st)$/;"	f	file:
processKindOption	.\parse.c	/^extern boolean processKindOption ($/;"	f
processLangKindOption	.\parse.c	/^static void processLangKindOption ($/;"	f	file:
processLanguageDefineOption	.\parse.c	/^extern void processLanguageDefineOption ($/;"	f
processLanguageForceOption	.\options.c	/^static void processLanguageForceOption ($/;"	f	file:
processLanguageMap	.\options.c	/^static char* processLanguageMap (char* map)$/;"	f	file:
processLanguageMapOption	.\options.c	/^static void processLanguageMapOption ($/;"	f	file:
processLanguageRegex	.\lregex.c	/^static void processLanguageRegex (const langType language,$/;"	f	file:
processLanguagesOption	.\options.c	/^static void processLanguagesOption ($/;"	f	file:
processLicenseOption	.\options.c	/^static void processLicenseOption ($/;"	f	file:
processListKindsOption	.\options.c	/^static void processListKindsOption ($/;"	f	file:
processListLanguagesOption	.\options.c	/^static void processListLanguagesOption ($/;"	f	file:
processListMapsOption	.\options.c	/^static void processListMapsOption ($/;"	f	file:
processLongOption	.\options.c	/^static void processLongOption ($/;"	f	file:
processName	.\c.c	/^static void processName (statementInfo *const st)$/;"	f	file:
processOptionFile	.\options.c	/^static void processOptionFile ($/;"	f	file:
processParametricOption	.\options.c	/^static boolean processParametricOption ($/;"	f	file:
processRegexOption	.\lregex.c	/^extern boolean processRegexOption (const char *const option,$/;"	f
processShortOption	.\options.c	/^static void processShortOption ($/;"	f	file:
processSortOption	.\options.c	/^static void processSortOption ($/;"	f	file:
processToken	.\c.c	/^static void processToken (tokenInfo *const token, statementInfo *const st)$/;"	f	file:
processVersionOption	.\options.c	/^static void processVersionOption ($/;"	f	file:
process_ex_cmd	.\ctags.py	/^def process_ex_cmd(ex):$/;"	f
process_fields	.\ctags.py	/^def process_fields(fields):$/;"	f
program	.\readtags.c	/^	} program;$/;"	m	struct:sTagFile	typeref:struct:sTagFile::__anon46	file:
program	.\readtags.h	/^	} program;$/;"	m	struct:__anon49	typeref:struct:__anon49::__anon52
ps	.\c.c	/^static void __unused__ ps (statementInfo *const st)$/;"	f	file:
pt	.\c.c	/^static void __unused__ pt (tokenInfo *const token)$/;"	f	file:
purebasic_keywords	.\basic.c	/^static KeyWord purebasic_keywords[] = {$/;"	v	file:
pushConditional	.\get.c	/^static boolean pushConditional (const boolean firstBranchChosen)$/;"	f	file:
push_dummy_failure	.\regex.c	/^  push_dummy_failure,$/;"	e	enum:__anon57	file:
pythonKind	.\python.c	/^} pythonKind;$/;"	t	typeref:enum:__anon42	file:
qualifiedTags	.\options.h	/^	boolean qualifiedTags;  \/* include tags for qualified class members *\/$/;"	m	struct:sInclude
qualifyBlockTag	.\c.c	/^static void qualifyBlockTag (statementInfo *const st,$/;"	f	file:
qualifyCompoundTag	.\c.c	/^static void qualifyCompoundTag (const statementInfo *const st,$/;"	f	file:
qualifyEnumeratorTag	.\c.c	/^static void qualifyEnumeratorTag (const statementInfo *const st,$/;"	f	file:
qualifyFunctionDeclTag	.\c.c	/^static void qualifyFunctionDeclTag (const statementInfo *const st,$/;"	f	file:
qualifyFunctionTag	.\c.c	/^static void qualifyFunctionTag (const statementInfo *const st,$/;"	f	file:
qualifyVariableTag	.\c.c	/^static void qualifyVariableTag (const statementInfo *const st,$/;"	f	file:
quickOpen	.\ctags_plugin.py	/^    def quickOpen(self, view, files, disp):$/;"	m	class:NavigateToDefinition
re_comp	.\regex.c	/^re_comp (s)$/;"	f
re_comp_buf	.\regex.c	/^static struct re_pattern_buffer re_comp_buf;$/;"	v	typeref:struct:re_pattern_buffer	file:
re_compile_fastmap	.\regex.c	/^re_compile_fastmap (bufp)$/;"	f
re_compile_pattern	.\regex.c	/^re_compile_pattern (pattern, length, bufp)$/;"	f
re_error_msg	.\regex.c	/^static const char *re_error_msg[] =$/;"	v	file:
re_exec	.\regex.c	/^re_exec (s)$/;"	f
re_match	.\regex.c	/^re_match (bufp, string, size, pos, regs)$/;"	f
re_match_2	.\regex.c	/^re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)$/;"	f
re_max_failures	.\regex.c	/^int re_max_failures = 2000;$/;"	v
re_nsub	.\regex.h	/^  size_t re_nsub;$/;"	m	struct:re_pattern_buffer
re_opcode_t	.\regex.c	/^} re_opcode_t;$/;"	t	typeref:enum:__anon57	file:
re_pattern_buffer	.\regex.h	/^struct re_pattern_buffer$/;"	s
re_registers	.\regex.h	/^struct re_registers$/;"	s
re_search	.\regex.c	/^re_search (bufp, string, size, startpos, range, regs)$/;"	f
re_search_2	.\regex.c	/^re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)$/;"	f
re_set_registers	.\regex.c	/^re_set_registers (bufp, regs, num_regs, starts, ends)$/;"	f
re_set_syntax	.\regex.c	/^re_set_syntax (syntax)$/;"	f
re_syntax_options	.\regex.c	/^reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;$/;"	v
re_syntax_table	.\regex.c	/^static char re_syntax_table[CHAR_SET_SIZE];$/;"	v	file:
readAndEmitTag	.\ruby.c	/^static void readAndEmitTag (const unsigned char** cp, rubyKind expected_kind)$/;"	f	file:
readDirective	.\get.c	/^static boolean readDirective (int c, char *const name, unsigned int maxLength)$/;"	f	file:
readFeatureName	.\eiffel.c	/^static boolean readFeatureName (tokenInfo *const token)$/;"	f	file:
readFieldValue	.\readtags.c	/^static const char *readFieldValue ($/;"	f	file:
readFileName	.\read.c	/^static vString *readFileName (void)$/;"	f	file:
readIdentifier	.\c.c	/^static void readIdentifier (tokenInfo *const token, const int firstChar)$/;"	f	file:
readIdentifier	.\fortran.c	/^static void readIdentifier (tokenInfo *const token, const int c)$/;"	f	file:
readIdentifier	.\get.c	/^static void readIdentifier (int c, vString *const name)$/;"	f	file:
readIdentifier	.\make.c	/^static void readIdentifier (const int first, vString *const id)$/;"	f	file:
readIdentifier	.\scheme.c	/^static void readIdentifier (vString *const name, const unsigned char *cp)$/;"	f	file:
readIdentifier	.\verilog.c	/^static boolean readIdentifier (vString *const name, int c)$/;"	f	file:
readIgnoreList	.\options.c	/^static void readIgnoreList (const char *const list)$/;"	f	file:
readLine	.\eiffel.c	/^extern char *readLine (vString *const vLine, FILE *const fp)$/;"	f
readLine	.\read.c	/^extern char *readLine (vString *const vLine, FILE *const fp)$/;"	f
readLineNumber	.\read.c	/^static unsigned long readLineNumber (void)$/;"	f	file:
readNext	.\readtags.c	/^static tagResult readNext (tagFile *const file, tagEntry *const entry)$/;"	f	file:
readOperator	.\asm.c	/^static const unsigned char *readOperator ($/;"	f	file:
readOperator	.\c.c	/^static void readOperator (statementInfo *const st)$/;"	f	file:
readOperator	.\whatever\asm.c	/^static const unsigned char *readOperator ($/;"	f	file:
readOptionConfiguration	.\options.c	/^extern void readOptionConfiguration (void)$/;"	f
readPackageName	.\c.c	/^static void readPackageName (tokenInfo *const token, const int firstChar)$/;"	f	file:
readPackageOrNamespace	.\c.c	/^static void readPackageOrNamespace (statementInfo *const st, const declType declaration)$/;"	f	file:
readParents	.\c.c	/^static void readParents (statementInfo *const st, const int qualifier)$/;"	f	file:
readPreProc	.\asm.c	/^static boolean readPreProc (const unsigned char *const line)$/;"	f	file:
readPreProc	.\whatever\asm.c	/^static boolean readPreProc (const unsigned char *const line)$/;"	f	file:
readPseudoTags	.\readtags.c	/^static void readPseudoTags (tagFile *const file, tagFileInfo *const info)$/;"	f	file:
readSourceLine	.\read.c	/^extern char *readSourceLine ($/;"	f
readSubToken	.\fortran.c	/^static void readSubToken (tokenInfo *const token)$/;"	f	file:
readSymbol	.\asm.c	/^static const unsigned char *readSymbol ($/;"	f	file:
readSymbol	.\whatever\asm.c	/^static const unsigned char *readSymbol ($/;"	f	file:
readTagLine	.\readtags.c	/^static int readTagLine (tagFile *const file)$/;"	f	file:
readTagLineRaw	.\readtags.c	/^static int readTagLineRaw (tagFile *const file)$/;"	f	file:
readTagLineSeek	.\readtags.c	/^static int readTagLineSeek (tagFile *const file, const off_t pos)$/;"	f	file:
readToken	.\eiffel.c	/^static void readToken (tokenInfo *const token)$/;"	f	file:
readToken	.\fortran.c	/^static void readToken (tokenInfo *const token)$/;"	f	file:
readToken	.\jscript.c	/^static void readToken (tokenInfo *const token)$/;"	f	file:
readToken	.\sql.c	/^static void readToken (tokenInfo *const token)$/;"	f	file:
readVimLine	.\vim.c	/^static const unsigned char * readVimLine (void)$/;"	f	file:
readdir	.\mac.c	/^struct dirent *readdir(DIR *dirp)$/;"	f
recurse	.\options.h	/^	boolean recurse;        \/* -R  recurse into directories *\/$/;"	m	struct:sOptionValues
recurseIntoDirectory	.\main.c	/^static boolean recurseIntoDirectory (const char *const dirName)$/;"	f	file:
recurseUsingOpendir	.\main.c	/^static boolean recurseUsingOpendir (const char *const dirName)$/;"	f	file:
reg_errcode_t	.\regex.h	/^} reg_errcode_t;$/;"	t	typeref:enum:__anon63
reg_syntax_t	.\regex.h	/^typedef unsigned reg_syntax_t;$/;"	t
regcomp	.\regex.c	/^regcomp (preg, pattern, cflags)$/;"	f
regerror	.\regex.c	/^regerror (code, preg, errbuf, errbuf_size)$/;"	f
regex	.\parse.h	/^	boolean regex;                 \/* is this a regex parser? *\/$/;"	m	struct:__anon37
regexBroken	.\lregex.c	/^static boolean regexBroken = FALSE;$/;"	v	file:
regexCallback	.\parse.h	/^typedef void (*regexCallback) (const char *line, const regexMatch *matches, unsigned int count);$/;"	t
regexMatch	.\parse.h	/^} regexMatch;$/;"	t	typeref:struct:__anon38
regexPattern	.\lregex.c	/^} regexPattern;$/;"	t	typeref:struct:__anon26	file:
regex_compile	.\regex.c	/^regex_compile (pattern, size, syntax, bufp)$/;"	f	file:
regex_t	.\regex.h	/^typedef struct re_pattern_buffer regex_t;$/;"	t	typeref:struct:re_pattern_buffer
regexec	.\regex.c	/^regexec (preg, string, nmatch, pmatch, eflags)$/;"	f
regfree	.\regex.c	/^regfree (preg)$/;"	f
register_info_type	.\regex.c	/^} register_info_type;$/;"	t	typeref:union:__anon61	file:
regmatch_t	.\regex.h	/^} regmatch_t;$/;"	t	typeref:struct:__anon64
regnum	.\regex.c	/^  regnum_t regnum;$/;"	m	struct:__anon58	file:
regnum_t	.\regex.c	/^typedef unsigned regnum_t;$/;"	t	file:
regoff_t	.\regex.h	/^typedef int regoff_t;$/;"	t
regs_allocated	.\regex.h	/^  unsigned regs_allocated : 2;$/;"	m	struct:re_pattern_buffer
reinitStatement	.\c.c	/^static void reinitStatement (statementInfo *const st, const boolean partial)$/;"	f	file:
relativeFilename	.\routines.c	/^extern char* relativeFilename (const char *file, const char *dir)$/;"	f
rememberMaxLengths	.\entry.c	/^static void rememberMaxLengths (const size_t nameLength, const size_t lineLength)$/;"	f	file:
removeLanguageExtensionMap	.\parse.c	/^extern boolean removeLanguageExtensionMap (const char *const extension)$/;"	f
replacementTruncate	.\entry.c	/^static int replacementTruncate (const char *const name, const long size)$/;"	f	file:
reportType	.\eiffel.c	/^static void reportType (tokenInfo *const token)$/;"	f	file:
rescanParser	.\parse.h	/^typedef boolean (*rescanParser) (const unsigned int passCount);$/;"	t
resizeTagFile	.\entry.c	/^static void resizeTagFile (const long newSize)$/;"	f	file:
resolveRequired	.\get.c	/^	boolean resolveRequired;     \/* must resolve if\/else\/elif\/endif branch *\/$/;"	m	struct:sCppState	file:
restartStatement	.\c.c	/^static void restartStatement (statementInfo *const st)$/;"	f	file:
retardToken	.\c.c	/^static void retardToken (statementInfo *const st)$/;"	f	file:
rewinddir	.\mac.c	/^void rewinddir(DIR *dirp)$/;"	f
rm_eo	.\regex.h	/^  regoff_t rm_eo;  \/* Byte offset from string's start to substring's end.  *\/$/;"	m	struct:__anon64
rm_so	.\regex.h	/^  regoff_t rm_so;  \/* Byte offset from string's start to substring's start.  *\/$/;"	m	struct:__anon64
rubyKind	.\ruby.c	/^} rubyKind;$/;"	t	typeref:enum:__anon66	file:
run	.\ctags_plugin.py	/^    def run(self, view, args):                    $/;"	m	class:JumpBack
run	.\ctags_plugin.py	/^    def run(self, view, args):$/;"	m	class:NavigateToDefinition
run	.\ctags_plugin.py	/^    def run(self, view, args):$/;"	m	class:RebuildCTags
run	.\ctags_plugin.py	/^    def run(self, view, args):$/;"	m	class:ShowSymbolsForCurrentFile
run	.\plugin_helpers.py	/^            def run():$/;"	f	function:threaded/decorator/threaded
sArgs	.\args.h	/^typedef struct sArgs {$/;"	s
sArgvArgs	.\args.h	/^		struct sArgvArgs {$/;"	s	union:sArgs::__anon2
sConditionalInfo	.\get.c	/^typedef struct sConditionalInfo {$/;"	s	file:
sCookedArgs	.\options.h	/^typedef struct sCookedArgs {$/;"	s
sCppState	.\get.c	/^typedef struct sCppState {$/;"	s	file:
sDirective	.\get.c	/^	struct sDirective {$/;"	s	struct:sCppState	file:
sEtags	.\entry.h	/^	struct sEtags {$/;"	s	struct:eTagFile
sExtFields	.\options.h	/^struct sExtFields {  \/* extension field content control *\/$/;"	s
sFileArgs	.\args.h	/^		struct sFileArgs {$/;"	s	union:sArgs::__anon2
sHashEntry	.\keyword.c	/^typedef struct sHashEntry {$/;"	s	file:
sInclude	.\options.h	/^struct sInclude {$/;"	s
sInputFile	.\read.h	/^typedef struct sInputFile {$/;"	s
sKeywordDesc	.\c.c	/^typedef struct sKeywordDesc {$/;"	s	file:
sKeywordDesc	.\eiffel.c	/^typedef struct sKeywordDesc {$/;"	s	file:
sKeywordDesc	.\fortran.c	/^typedef struct sKeywordDesc {$/;"	s	file:
sKeywordDesc	.\jscript.c	/^typedef struct sKeywordDesc {$/;"	s	file:
sKeywordDesc	.\sql.c	/^typedef struct sKeywordDesc {$/;"	s	file:
sKind	.\lregex.c	/^struct sKind {$/;"	s	file:
sKindOption	.\parse.h	/^typedef struct sKindOption {$/;"	s
sMax	.\entry.h	/^	struct sMax { size_t line, tag, file; } max;$/;"	s	struct:eTagFile
sMemberInfo	.\c.c	/^typedef struct sMemberInfo {$/;"	s	file:
sNumTags	.\entry.h	/^	struct sNumTags { unsigned long added, prev; } numTags;$/;"	s	struct:eTagFile
sOptionDescription	.\options.c	/^typedef struct sOptionDescription {$/;"	s	file:
sOptionValues	.\options.h	/^typedef struct sOptionValues {$/;"	s
sParenInfo	.\c.c	/^typedef struct sParenInfo {$/;"	s	file:
sSource	.\read.h	/^	struct sSource {$/;"	s	struct:sInputFile
sStatementInfo	.\c.c	/^typedef struct sStatementInfo {$/;"	s	file:
sStringArgs	.\args.h	/^		struct sStringArgs {$/;"	s	union:sArgs::__anon2
sStringList	.\strlist.h	/^typedef struct sStringList {$/;"	s
sTagEntryInfo	.\entry.h	/^typedef struct sTagEntryInfo {$/;"	s
sTagFields	.\entry.h	/^typedef struct sTagFields {$/;"	s
sTagFile	.\readtags.c	/^struct sTagFile {$/;"	s	file:
sTokenInfo	.\c.c	/^typedef struct sTokenInfo {$/;"	s	file:
sTokenInfo	.\eiffel.c	/^typedef struct sTokenInfo {$/;"	s	file:
sTokenInfo	.\fortran.c	/^typedef struct sTokenInfo {$/;"	s	file:
sTokenInfo	.\jscript.c	/^typedef struct sTokenInfo {$/;"	s	file:
sTokenInfo	.\sql.c	/^typedef struct sTokenInfo {$/;"	s	file:
sVString	.\vstring.h	/^typedef struct sVString {$/;"	s
saveIgnoreToken	.\options.c	/^static void saveIgnoreToken (vString *const ignoreToken)$/;"	f	file:
scanSeparators	.\lregex.c	/^static char* scanSeparators (char* name)$/;"	f	file:
schemeKind	.\scheme.c	/^} schemeKind;$/;"	t	typeref:enum:__anon67	file:
scope	.\c.c	/^	tagScope	scope;$/;"	m	struct:sStatementInfo	file:
scope	.\entry.h	/^		const char* scope [2];    \/* value and key *\/$/;"	m	struct:sTagEntryInfo::__anon17
scope	.\jscript.c	/^	vString *		scope;$/;"	m	struct:sTokenInfo	file:
scope	.\options.h	/^	boolean scope;$/;"	m	struct:sExtFields
scope	.\sql.c	/^	vString *	scope;$/;"	m	struct:sTokenInfo	file:
scopeString	.\c.c	/^static const char *scopeString (const tagScope scope)$/;"	f	file:
scribble	.\ctags.py	/^def scribble():$/;"	f
scroll_to_tag	.\ctags_plugin.py	/^def scroll_to_tag(view, file, symbol, pattern_or_line):$/;"	f
search	.\readtags.c	/^	} search;$/;"	m	struct:sTagFile	typeref:struct:sTagFile::__anon44	file:
secondary	.\fortran.c	/^	struct sTokenInfo *secondary;$/;"	m	struct:sTokenInfo	typeref:struct:sTokenInfo::sTokenInfo	file:
select	.\ctags_plugin.py	/^def select(view, region):$/;"	f
selected	.\routines.c	148;"	d	file:
sep	.\entry.c	713;"	d	file:
sep	.\entry.c	765;"	d	file:
sep	.\readtags.c	802;"	d	file:
sep	.\readtags.c	820;"	d	file:
setAccess	.\c.c	/^static void setAccess (statementInfo *const st, const accessType access)$/;"	f	file:
setCurrentDirectory	.\routines.c	/^extern void setCurrentDirectory (void)$/;"	f
setDefaultTagFileName	.\options.c	/^extern void setDefaultTagFileName (void)$/;"	f
setEtagsMode	.\options.c	/^static void setEtagsMode (void)$/;"	f	file:
setExecutableName	.\routines.c	/^extern void setExecutableName (const char *const path)$/;"	f
setIgnore	.\get.c	/^static boolean setIgnore (const boolean ignore)$/;"	f	file:
setInputFileName	.\read.c	/^static void setInputFileName (const char *const fileName)$/;"	f	file:
setSourceFileName	.\read.c	/^static boolean setSourceFileName (vString *const fileName)$/;"	f	file:
setSourceFileParameters	.\read.c	/^static void setSourceFileParameters (vString *const fileName)$/;"	f	file:
setToken	.\c.c	/^static void setToken (statementInfo *const st, const tokenType type)$/;"	f	file:
set_number_at	.\regex.c	/^  set_number_at,$/;"	e	enum:__anon57	file:
shKind	.\make.c	/^} shKind;$/;"	t	typeref:enum:__anon33	file:
shKind	.\sh.c	/^} shKind;$/;"	t	typeref:enum:__anon68	file:
shortOptions	.\options.h	/^	char *shortOptions;$/;"	m	struct:sCookedArgs
sig_child	.\argproc.c	/^static sig_child (chan)$/;"	f	file:
signature	.\entry.h	/^		const char* signature;$/;"	m	struct:sTagEntryInfo::__anon17
signature	.\options.h	/^	boolean signature;$/;"	m	struct:sExtFields
simple	.\options.h	/^	char simple[2];$/;"	m	struct:sCookedArgs
simpleParser	.\parse.h	/^typedef void (*simpleParser) (void);$/;"	t
singleBranch	.\get.c	/^	boolean singleBranch;       \/* choose only one branch *\/$/;"	m	struct:sConditionalInfo	file:
size	.\readtags.c	/^	off_t size;$/;"	m	struct:sTagFile	file:
size	.\readtags.c	/^	size_t size;$/;"	m	struct:__anon43	file:
size	.\regex.c	/^  unsigned size;$/;"	m	struct:__anon59	file:
size	.\regex.c	/^  unsigned size;$/;"	m	struct:__anon60	file:
size	.\routines.h	/^	unsigned long size;$/;"	m	struct:__anon65
size	.\vstring.h	/^	size_t  size;    \/* allocated size of buffer *\/$/;"	m	struct:sVString
skip	.\basic.c	/^	int skip;$/;"	m	struct:__anon9	file:
skipArgumentList	.\jscript.c	/^static void skipArgumentList (tokenInfo *const token)$/;"	f	file:
skipArgumentList	.\sql.c	/^static void skipArgumentList (tokenInfo *const token)$/;"	f	file:
skipArrayList	.\jscript.c	/^static void skipArrayList (tokenInfo *const token)$/;"	f	file:
skipBraces	.\c.c	/^static void skipBraces (void)$/;"	f	file:
skipEverything	.\python.c	/^static const char *skipEverything (const char *cp)$/;"	f	file:
skipIdentifier	.\python.c	/^static const char *skipIdentifier (const char *cp)$/;"	f	file:
skipInitializer	.\c.c	/^static int skipInitializer (statementInfo *const st)$/;"	f	file:
skipJavaThrows	.\c.c	/^static void skipJavaThrows (statementInfo *const st)$/;"	f	file:
skipLine	.\fortran.c	/^static int skipLine (void)$/;"	f	file:
skipLine	.\make.c	/^static void skipLine (void)$/;"	f	file:
skipMacro	.\c.c	/^static void skipMacro (statementInfo *const st)$/;"	f	file:
skipMemIntializerList	.\c.c	/^static void skipMemIntializerList (tokenInfo *const token)$/;"	f	file:
skipOverCComment	.\get.c	/^int skipOverCComment (void)$/;"	f
skipOverCplusComment	.\get.c	/^static int skipOverCplusComment (void)$/;"	f	file:
skipOverParens	.\fortran.c	/^static void skipOverParens (tokenInfo *const token)$/;"	f	file:
skipParens	.\c.c	/^static void skipParens (void)$/;"	f	file:
skipPast	.\fortran.c	/^static void skipPast (tokenInfo *const token, tokenType type)$/;"	f	file:
skipPastMap	.\options.c	/^static char* skipPastMap (char* p)$/;"	f	file:
skipPastMatch	.\verilog.c	/^static int skipPastMatch (const char *const pair)$/;"	f	file:
skipPostArgumentStuff	.\c.c	/^static boolean skipPostArgumentStuff ($/;"	f	file:
skipPrefix	.\vim.c	/^static const unsigned char* skipPrefix (const unsigned char* name, int *scope)$/;"	f	file:
skipSpace	.\erlang.c	/^static const unsigned char *skipSpace (const unsigned char *cp)$/;"	f	file:
skipSpace	.\python.c	/^static const char *skipSpace (const char *cp)$/;"	f	file:
skipSpace	.\sml.c	/^static const unsigned char *skipSpace (const unsigned char *cp)$/;"	f	file:
skipStatement	.\c.c	/^static void skipStatement (statementInfo *const st)$/;"	f	file:
skipStatementIfKeyword	.\fortran.c	/^static boolean skipStatementIfKeyword (tokenInfo *const token, keywordId keyword)$/;"	f	file:
skipString	.\python.c	/^static const char *skipString (const char *cp)$/;"	f	file:
skipToCharacter	.\eiffel.c	/^static int skipToCharacter (const int c)$/;"	f	file:
skipToCharacter	.\jscript.c	/^static int skipToCharacter (const int c)$/;"	f	file:
skipToCharacter	.\sql.c	/^static int skipToCharacter (const int c)$/;"	f	file:
skipToEndOfChar	.\get.c	/^static int skipToEndOfChar (void)$/;"	f	file:
skipToEndOfString	.\get.c	/^static int skipToEndOfString (boolean ignoreBackslash)$/;"	f	file:
skipToFormattedBraceMatch	.\c.c	/^static void skipToFormattedBraceMatch (void)$/;"	f	file:
skipToMatch	.\c.c	/^static void skipToMatch (const char *const pair)$/;"	f	file:
skipToMatch	.\make.c	/^static void skipToMatch (const char *const pair)$/;"	f	file:
skipToNextLine	.\fortran.c	/^static int skipToNextLine (void)$/;"	f	file:
skipToNextStatement	.\fortran.c	/^static void skipToNextStatement (tokenInfo *const token)$/;"	f	file:
skipToNonWhite	.\c.c	/^static int skipToNonWhite (void)$/;"	f	file:
skipToNonWhite	.\make.c	/^static int skipToNonWhite (void)$/;"	f	file:
skipToOneOf	.\c.c	/^static int skipToOneOf (const char *const chars)$/;"	f	file:
skipToToken	.\fortran.c	/^static void skipToToken (tokenInfo *const token, tokenType type)$/;"	f	file:
skipWhite	.\read.c	/^static int skipWhite (void)$/;"	f	file:
skipWhite	.\verilog.c	/^static int skipWhite (int c)$/;"	f	file:
skipWhitespace	.\ruby.c	/^static void skipWhitespace (const unsigned char** cp)$/;"	f	file:
smlKind	.\sml.c	/^} smlKind;$/;"	t	typeref:enum:__anon69	file:
sort	.\readtags.h	/^			sortType sort;$/;"	m	struct:__anon49::__anon51
sortMethod	.\readtags.c	/^	sortType sortMethod;$/;"	m	struct:sTagFile	file:
sortTagFile	.\entry.c	/^static void sortTagFile (void)$/;"	f	file:
sortType	.\options.h	/^typedef enum sortType {$/;"	g
sortType	.\options.h	/^} sortType;$/;"	t	typeref:enum:sortType
sortType	.\readtags.h	/^} sortType ;$/;"	t	typeref:enum:__anon47
sorted	.\options.h	/^	sortType sorted;        \/* -u,--sort  sort tags *\/$/;"	m	struct:sOptionValues
source	.\read.h	/^	} source;$/;"	m	struct:sInputFile	typeref:struct:sInputFile::sSource
sourceFileName	.\entry.h	/^	const char *sourceFileName;   \/* name of source file *\/$/;"	m	struct:sTagEntryInfo
sqlKind	.\sql.c	/^} sqlKind;$/;"	t	typeref:enum:__anon71	file:
st_atime	.\e_mac.h	/^	time_t             st_atime;    \/* Time of last access.  *\/$/;"	m	struct:stat
st_blksize	.\e_mac.h	/^	unsigned long int  st_blksize;  \/* Optimal block size for I\/O.  *\/$/;"	m	struct:stat
st_blocks	.\e_mac.h	/^	long               st_blocks;   \/* Number 512-byte blocks allocated. *\/$/;"	m	struct:stat
st_ctime	.\e_mac.h	/^	time_t             st_ctime;    \/* Time of last status change.  *\/$/;"	m	struct:stat
st_dev	.\e_mac.h	/^	dev_t              st_dev;      \/* Device.  *\/$/;"	m	struct:stat
st_gid	.\e_mac.h	/^	gid_t              st_gid;      \/* Group ID of the file's group.*\/$/;"	m	struct:stat
st_ino	.\e_mac.h	/^	ino_t              st_ino;      \/* File serial number.	*\/$/;"	m	struct:stat
st_mode	.\e_mac.h	/^	mode_t             st_mode;     \/* File mode.  *\/$/;"	m	struct:stat
st_mtime	.\e_mac.h	/^	time_t             st_mtime;    \/* Time of last modification.  *\/$/;"	m	struct:stat
st_nlink	.\e_mac.h	/^	nlink_t            st_nlink;    \/* Link count.  *\/$/;"	m	struct:stat
st_size	.\e_mac.h	/^	off_t              st_size;     \/* Size of file, in bytes.  *\/$/;"	m	struct:stat
st_uid	.\e_mac.h	/^	uid_t              st_uid;      \/* User ID of the file's owner.	*\/$/;"	m	struct:stat
stack	.\regex.c	/^  compile_stack_elt_t *stack;$/;"	m	struct:__anon59	file:
stack	.\regex.c	/^  fail_stack_elt_t *stack;$/;"	m	struct:__anon60	file:
start	.\parse.h	/^	size_t start;   \/* character index in line where match starts *\/$/;"	m	struct:__anon38
start	.\regex.h	/^  regoff_t *start;$/;"	m	struct:re_registers
start_memory	.\regex.c	/^  start_memory,$/;"	e	enum:__anon57	file:
starttoken	.\pascal.c	62;"	d	file:
stat	.\e_mac.h	/^struct stat {$/;"	s
stat	.\e_mac.h	138;"	d
stat	.\routines.c	127;"	d	file:
state	.\get.c	/^		enum eState state;       \/* current directive being processed *\/$/;"	m	struct:sCppState::sDirective	typeref:enum:sCppState::sDirective::eState	file:
statementInfo	.\c.c	/^} statementInfo;$/;"	t	typeref:struct:sStatementInfo	file:
status	.\readtags.h	/^	} status;$/;"	m	struct:__anon49	typeref:struct:__anon49::__anon50
status_address	.\argproc.c	/^	int *status_address;$/;"	m	struct:exit_control_block	file:
stop_memory	.\regex.c	/^  stop_memory,$/;"	e	enum:__anon57	file:
store_op1	.\regex.c	/^store_op1 (op, loc, arg)$/;"	f	file:
store_op2	.\regex.c	/^store_op2 (op, loc, arg1, arg2)$/;"	f	file:
strcasecmp	.\general.h	72;"	d
strcasecmp	.\general.h	74;"	d
string	.\args.h	/^			const char* string;$/;"	m	struct:sArgs::__anon2::sStringArgs
string	.\eiffel.c	/^	vString*  string;$/;"	m	struct:sTokenInfo	file:
string	.\fortran.c	/^	vString* string;$/;"	m	struct:sTokenInfo	file:
string	.\jscript.c	/^	vString *		string;$/;"	m	struct:sTokenInfo	file:
string	.\keyword.c	/^	const char *string;$/;"	m	struct:sHashEntry	file:
string	.\sql.c	/^	vString *	string;$/;"	m	struct:sTokenInfo	file:
stringArgs	.\args.h	/^		} stringArgs;$/;"	m	union:sArgs::__anon2	typeref:struct:sArgs::__anon2::sStringArgs
stringCopy	.\options.c	/^static char *stringCopy (const char *const string)$/;"	f	file:
stringList	.\strlist.h	/^} stringList;$/;"	t	typeref:struct:sStringList
stringListAdd	.\strlist.c	/^extern void stringListAdd (stringList *const current, vString *string)$/;"	f
stringListClear	.\strlist.c	/^extern void stringListClear (stringList *const current)$/;"	f
stringListCombine	.\strlist.c	/^extern void stringListCombine ($/;"	f
stringListCount	.\strlist.c	/^extern unsigned int stringListCount (const stringList *const current)$/;"	f
stringListDelete	.\strlist.c	/^extern void stringListDelete (stringList *const current)$/;"	f
stringListExtensionMatched	.\strlist.c	/^extern boolean stringListExtensionMatched ($/;"	f
stringListFileMatched	.\strlist.c	/^extern boolean stringListFileMatched ($/;"	f
stringListHas	.\strlist.c	/^extern boolean stringListHas ($/;"	f
stringListHasInsensitive	.\strlist.c	/^extern boolean stringListHasInsensitive ($/;"	f
stringListHasTest	.\strlist.c	/^extern boolean stringListHasTest ($/;"	f
stringListIndex	.\strlist.c	/^static int stringListIndex ($/;"	f	file:
stringListItem	.\strlist.c	/^extern vString* stringListItem ($/;"	f
stringListLast	.\strlist.c	/^extern vString* stringListLast (const stringList *const current)$/;"	f
stringListNew	.\strlist.c	/^extern stringList *stringListNew (void)$/;"	f
stringListNewFromArgv	.\strlist.c	/^extern stringList* stringListNewFromArgv (const char* const* const argv)$/;"	f
stringListNewFromFile	.\strlist.c	/^extern stringList* stringListNewFromFile (const char* const fileName)$/;"	f
stringListPrint	.\strlist.c	/^extern void stringListPrint (const stringList *const current)$/;"	f
stringListRemoveExtension	.\strlist.c	/^extern boolean stringListRemoveExtension ($/;"	f
stringListRemoveLast	.\strlist.c	/^extern void stringListRemoveLast (stringList *const current)$/;"	f
stringListToScope	.\ruby.c	/^static vString* stringListToScope (const stringList* list)$/;"	f	file:
stringMatch	.\get.c	30;"	d	file:
strncasecmp	.\general.h	80;"	d
strncasecmp	.\general.h	82;"	d
strnuppercmp	.\readtags.c	/^static int strnuppercmp (const char *s1, const char *s2, size_t n)$/;"	f	file:
strnuppercmp	.\routines.c	/^extern int strnuppercmp (const char *s1, const char *s2, size_t n)$/;"	f
strstr	.\routines.c	/^extern char* strstr (const char *str, const char *substr)$/;"	f
struppercmp	.\readtags.c	/^static int struppercmp (const char *s1, const char *s2)$/;"	f	file:
struppercmp	.\routines.c	/^extern int struppercmp (const char *s1, const char *s2)$/;"	f
substitute	.\lregex.c	/^static vString* substitute ($/;"	f	file:
succeed_n	.\regex.c	/^  succeed_n,$/;"	e	enum:__anon57	file:
syntax	.\regex.h	/^  reg_syntax_t syntax;$/;"	m	struct:re_pattern_buffer
syntaxspec	.\regex.c	/^  syntaxspec,$/;"	e	enum:__anon57	file:
tag	.\entry.h	/^	struct sMax { size_t line, tag, file; } max;$/;"	m	struct:eTagFile::sMax
tag	.\fortran.c	/^	tagType tag;$/;"	m	struct:sTokenInfo	file:
tag	.\lregex.c	/^		} tag;$/;"	m	union:__anon26::__anon27	typeref:struct:__anon26::__anon27::__anon28	file:
tagCheck	.\c.c	/^static void tagCheck (statementInfo *const st)$/;"	f	file:
tagEntry	.\readtags.h	/^} tagEntry;$/;"	t	typeref:struct:__anon54
tagEntryInfo	.\entry.h	/^} tagEntryInfo;$/;"	t	typeref:struct:sTagEntryInfo
tagExtensionField	.\readtags.h	/^} tagExtensionField;$/;"	t	typeref:struct:__anon53
tagFields	.\entry.h	/^} tagFields;$/;"	t	typeref:struct:sTagFields
tagFile	.\entry.h	/^} tagFile;$/;"	t	typeref:struct:eTagFile
tagFile	.\readtags.h	/^typedef struct sTagFile tagFile;$/;"	t	typeref:struct:sTagFile
tagFileFormat	.\options.h	/^	unsigned int tagFileFormat;\/* --format  tag file format (level) *\/$/;"	m	struct:sOptionValues
tagFileInfo	.\readtags.h	/^} tagFileInfo;$/;"	t	typeref:struct:__anon49
tagFileName	.\entry.c	/^extern const char *tagFileName (void)$/;"	f
tagFileName	.\options.h	/^	char *tagFileName;      \/* -o  name of tags file *\/$/;"	m	struct:sOptionValues
tagLetter	.\c.c	/^static int tagLetter (const tagType type)$/;"	f	file:
tagName	.\c.c	/^static const char *tagName (const tagType type)$/;"	f	file:
tagNameList	.\verilog.c	/^static void tagNameList (const verilogKind kind, int c)$/;"	f	file:
tagPath	.\read.h	/^		char    *tagPath;        \/* path of source file relative to tag file *\/$/;"	m	struct:sInputFile::sSource
tagRelative	.\options.h	/^	boolean tagRelative;    \/* --tag-relative file paths relative to tag file *\/$/;"	m	struct:sOptionValues
tagResult	.\readtags.h	/^typedef enum { TagFailure = 0, TagSuccess = 1 } tagResult;$/;"	t	typeref:enum:__anon48
tagScope	.\c.c	/^} tagScope;$/;"	t	typeref:enum:eTagScope	file:
tagType	.\c.c	/^} tagType;$/;"	t	typeref:enum:eTagType	file:
tagType	.\fortran.c	/^} tagType;$/;"	t	typeref:enum:eTagType	file:
tagsClose	.\readtags.c	/^extern tagResult tagsClose (tagFile *const file)$/;"	f
tagsField	.\readtags.c	/^extern const char *tagsField (const tagEntry *const entry, const char *const key)$/;"	f
tagsFind	.\readtags.c	/^extern tagResult tagsFind (tagFile *const file, tagEntry *const entry,$/;"	f
tagsFindNext	.\readtags.c	/^extern tagResult tagsFindNext (tagFile *const file, tagEntry *const entry)$/;"	f
tagsFirst	.\readtags.c	/^extern tagResult tagsFirst (tagFile *const file, tagEntry *const entry)$/;"	f
tagsNext	.\readtags.c	/^extern tagResult tagsNext (tagFile *const file, tagEntry *const entry)$/;"	f
tagsOpen	.\readtags.c	/^extern tagFile *tagsOpen (const char *const filePath, tagFileInfo *const info)$/;"	f
tagsSetSortType	.\readtags.c	/^extern tagResult tagsSetSortType (tagFile *const file, const sortType type)$/;"	f
tail	.\pascal.c	/^static boolean tail (const char *cp)$/;"	f	file:
tclKind	.\tcl.c	/^} tclKind;$/;"	t	typeref:enum:__anon72	file:
tempFile	.\routines.c	/^extern FILE *tempFile (const char *const mode, char **const pName)$/;"	f
tempnam	.\e_msoft.h	38;"	d
terminate	.\readtags.c	/^static void terminate (tagFile *const file)$/;"	f	file:
testEtagsInvocation	.\options.c	/^extern void testEtagsInvocation (void)$/;"	f
test_all_search_strings_work	.\ctags.py	/^    def test_all_search_strings_work(self):$/;"	m	class:CTagsTest
thread	.\ctags.py	/^    def thread(self):$/;"	m	class:CTagsCache
threaded	.\plugin_helpers.py	/^        def threaded(*args, **kwargs):$/;"	f	function:threaded/decorator
threaded	.\plugin_helpers.py	/^def threaded(finish=None, msg="Thread already running"):$/;"	f
timeStamp	.\main.c	485;"	d	file:
timeStamp	.\main.c	518;"	d	file:
toLowerString	.\routines.c	/^extern void toLowerString (char* str)$/;"	f
toUpperString	.\routines.c	/^extern void toUpperString (char* str)$/;"	f
token	.\basic.c	/^	char const *token;$/;"	m	struct:__anon9	file:
token	.\c.c	/^	tokenInfo*	token [(int) NumTokens];$/;"	m	struct:sStatementInfo	file:
tokenIndex	.\c.c	/^	unsigned int tokenIndex;    \/* currently active token *\/$/;"	m	struct:sStatementInfo	file:
tokenInfo	.\c.c	/^} tokenInfo;$/;"	t	typeref:struct:sTokenInfo	file:
tokenInfo	.\eiffel.c	/^} tokenInfo;$/;"	t	typeref:struct:sTokenInfo	file:
tokenInfo	.\fortran.c	/^} tokenInfo;$/;"	t	typeref:struct:sTokenInfo	file:
tokenInfo	.\jscript.c	/^} tokenInfo;$/;"	t	typeref:struct:sTokenInfo	file:
tokenInfo	.\sql.c	/^} tokenInfo;$/;"	t	typeref:struct:sTokenInfo	file:
tokenString	.\c.c	/^static const char *tokenString (const tokenType type)$/;"	f	file:
tokenType	.\c.c	/^} tokenType;$/;"	t	typeref:enum:eTokenType	file:
tokenType	.\eiffel.c	/^} tokenType;$/;"	t	typeref:enum:eTokenType	file:
tokenType	.\fortran.c	/^} tokenType;$/;"	t	typeref:enum:eTokenType	file:
tokenType	.\jscript.c	/^} tokenType;$/;"	t	typeref:enum:eTokenType	file:
tokenType	.\sql.c	/^} tokenType;$/;"	t	typeref:enum:eTokenType	file:
translate	.\regex.h	/^  char *translate;$/;"	m	struct:re_pattern_buffer
true	.\regex.c	238;"	d	file:
truncateLine	.\entry.h	/^	boolean     truncateLine;     \/* truncate tag line at end of tag name? *\/$/;"	m	struct:sTagEntryInfo
truncateTagLine	.\entry.c	/^static void truncateTagLine ($/;"	f	file:
type	.\args.h	/^	argType type;$/;"	m	struct:sArgs
type	.\c.c	/^	tokenType     type;$/;"	m	struct:sTokenInfo	file:
type	.\eiffel.c	/^	tokenType type;$/;"	m	struct:sTokenInfo	file:
type	.\fortran.c	/^	tokenType type;$/;"	m	struct:sTokenInfo	file:
type	.\jscript.c	/^	tokenType		type;$/;"	m	struct:sTokenInfo	file:
type	.\lregex.c	/^	enum pType type;$/;"	m	struct:__anon26	typeref:enum:__anon26::pType	file:
type	.\sql.c	/^	tokenType	type;$/;"	m	struct:sTokenInfo	file:
typeRef	.\entry.h	/^		const char* typeRef [2];  \/* e.g., "struct" and struct name *\/$/;"	m	struct:sTagEntryInfo::__anon17
typeRef	.\options.h	/^	boolean typeRef;$/;"	m	struct:sExtFields
u	.\args.h	/^	} u;$/;"	m	struct:sArgs	typeref:union:sArgs::__anon2
u	.\lregex.c	/^	} u;$/;"	m	struct:__anon26	typeref:union:__anon26::__anon27	file:
uid_t	.\e_mac.h	/^typedef unsigned long  uid_t;$/;"	t
unescape_ex	.\ctags.py	/^def unescape_ex(ex):$/;"	f
ungetChar	.\fortran.c	/^static void ungetChar (const int c)$/;"	f	file:
ungetch	.\get.c	/^	int		ungetch, ungetch2;   \/* ungotten characters, if any *\/$/;"	m	struct:sCppState	file:
ungetch	.\read.h	/^	int         ungetch;       \/* a single character that was ungotten *\/$/;"	m	struct:sInputFile
ungetch2	.\get.c	/^	int		ungetch, ungetch2;   \/* ungotten characters, if any *\/$/;"	m	struct:sCppState	file:
updatePseudoTags	.\entry.c	/^static long unsigned int updatePseudoTags (FILE *const fp)$/;"	f	file:
updateSortedFlag	.\entry.c	/^static void updateSortedFlag ($/;"	f	file:
url	.\readtags.c	/^		char *url;$/;"	m	struct:sTagFile::__anon46	file:
url	.\readtags.h	/^		const char *url;$/;"	m	struct:__anon49::__anon52
used	.\regex.h	/^  unsigned long used;	$/;"	m	struct:re_pattern_buffer
usedByEtags	.\options.c	/^	int usedByEtags;$/;"	m	struct:sOptionDescription	file:
vGetc	.\verilog.c	/^static int vGetc (void)$/;"	f	file:
vLine	.\entry.h	/^	vString *vLine;$/;"	m	struct:eTagFile
vString	.\vstring.h	/^} vString;$/;"	t	typeref:struct:sVString
vStringAutoResize	.\vstring.c	/^extern boolean vStringAutoResize (vString *const string)$/;"	f
vStringCat	.\vstring.h	40;"	d
vStringCatS	.\vstring.c	/^extern void vStringCatS (vString *const string, const char *const s)$/;"	f
vStringChar	.\vstring.h	44;"	d
vStringChop	.\vstring.c	/^extern void vStringChop (vString *const string)$/;"	f
vStringClear	.\vstring.c	/^extern void vStringClear (vString *const string)$/;"	f
vStringCopy	.\vstring.h	42;"	d
vStringCopyS	.\vstring.c	/^extern void vStringCopyS (vString *const string, const char *const s)$/;"	f
vStringCopyToLower	.\vstring.c	/^extern void vStringCopyToLower (vString *const dest, const vString *const src)$/;"	f
vStringDelete	.\vstring.c	/^extern void vStringDelete (vString *const string)$/;"	f
vStringInitialSize	.\vstring.c	/^static const size_t vStringInitialSize = 32;$/;"	v	file:
vStringItem	.\vstring.h	37;"	d
vStringLast	.\python.c	59;"	d	file:
vStringLength	.\vstring.h	38;"	d
vStringLower	.\vstring.h	46;"	d
vStringNCat	.\vstring.h	41;"	d
vStringNCatS	.\vstring.c	/^extern void vStringNCatS ($/;"	f
vStringNCopy	.\vstring.h	43;"	d
vStringNCopyS	.\vstring.c	/^extern void vStringNCopyS ($/;"	f
vStringNew	.\vstring.c	/^extern vString *vStringNew (void)$/;"	f
vStringNewCopy	.\vstring.c	/^extern vString *vStringNewCopy (const vString *const string)$/;"	f
vStringNewInit	.\vstring.c	/^extern vString *vStringNewInit (const char *const s)$/;"	f
vStringPut	.\vstring.c	/^extern void vStringPut (vString *const string, const int c)$/;"	f
vStringPut	.\vstring.h	30;"	d
vStringResize	.\vstring.c	/^static void vStringResize (vString *const string, const size_t newSize)$/;"	f	file:
vStringSetLength	.\vstring.c	/^extern void vStringSetLength (vString *const string)$/;"	f
vStringSize	.\vstring.h	39;"	d
vStringStripLeading	.\vstring.c	/^extern void vStringStripLeading (vString *const string)$/;"	f
vStringStripNewline	.\vstring.c	/^extern void vStringStripNewline (vString *const string)$/;"	f
vStringStripTrailing	.\vstring.c	/^extern void vStringStripTrailing (vString *const string)$/;"	f
vStringTerminate	.\vstring.h	45;"	d
vStringUpper	.\vstring.h	47;"	d
vStringValue	.\vstring.h	36;"	d
vUngetc	.\verilog.c	/^static void vUngetc (int c)$/;"	f	file:
value	.\argproc.c	/^	char *value;$/;"	m	struct:list_item	file:
value	.\entry.h	/^	const char *const *value;  \/* list of values for extension flags *\/$/;"	m	struct:sTagFields
value	.\keyword.c	/^	int value;$/;"	m	struct:sHashEntry	file:
value	.\readtags.h	/^	const char *value;$/;"	m	struct:__anon53
variableTagType	.\fortran.c	/^static tagType variableTagType (void)$/;"	f	file:
veraKind	.\c.c	/^} veraKind;$/;"	t	typeref:enum:__anon15	file:
veraTagKind	.\c.c	/^static veraKind veraTagKind (const tagType type) {$/;"	f	file:
verbose	.\options.c	/^extern void verbose (const char *const format, ...)$/;"	f
verbose	.\options.h	/^	boolean verbose;        \/* -V  verbose *\/$/;"	m	struct:sOptionValues
verilogKind	.\verilog.c	/^} verilogKind;$/;"	t	typeref:enum:__anon73	file:
version	.\readtags.c	/^		char *version;$/;"	m	struct:sTagFile::__anon46	file:
version	.\readtags.h	/^		const char *version;$/;"	m	struct:__anon49::__anon52
view_fn	.\ctags_plugin.py	/^def view_fn(view, if_None = '.'):$/;"	f
vimKind	.\vim.c	/^} vimKind;$/;"	t	typeref:enum:__anon75	file:
vstring	.\readtags.c	/^} vstring;$/;"	t	typeref:struct:__anon43	file:
wait	.\ctags_plugin.py	/^        def wait():$/;"	f	function:wait_until_loaded/wrapper
wait_until_loaded	.\ctags_plugin.py	/^def wait_until_loaded(file, window):$/;"	f
word	.\regex.c	/^  fail_stack_elt_t word;$/;"	m	union:__anon61	file:
wordbeg	.\regex.c	/^  wordbeg,	\/* Succeeds if at word beginning.  *\/$/;"	e	enum:__anon57	file:
wordbound	.\regex.c	/^  wordbound,	\/* Succeeds if at a word boundary.  *\/$/;"	e	enum:__anon57	file:
wordchar	.\regex.c	/^  wordchar,	\/* Matches any word-constituent character.  *\/$/;"	e	enum:__anon57	file:
wordend	.\regex.c	/^  wordend,	\/* Succeeds if at word end.  *\/$/;"	e	enum:__anon57	file:
wrapper	.\ctags_plugin.py	/^    def wrapper(f):$/;"	f	function:wait_until_loaded
writeCompactSourceLine	.\entry.c	/^static size_t writeCompactSourceLine (FILE *const fp, const char *const line)$/;"	f	file:
writeCtagsEntry	.\entry.c	/^static int writeCtagsEntry (const tagEntryInfo *const tag)$/;"	f	file:
writeEtagsEntry	.\entry.c	/^static int writeEtagsEntry (const tagEntryInfo *const tag)$/;"	f	file:
writeEtagsIncludes	.\entry.c	/^static void writeEtagsIncludes (FILE *const fp)$/;"	f	file:
writeLineNumberEntry	.\entry.c	/^static int writeLineNumberEntry (const tagEntryInfo *const tag)$/;"	f	file:
writePatternEntry	.\entry.c	/^static int writePatternEntry (const tagEntryInfo *const tag)$/;"	f	file:
writePseudoTag	.\entry.c	/^static void writePseudoTag ($/;"	f	file:
writeSortedTags	.\sort.c	/^static void writeSortedTags ($/;"	f	file:
writeSourceLine	.\entry.c	/^static size_t writeSourceLine (FILE *const fp, const char *const line)$/;"	f	file:
writeXrefEntry	.\entry.c	/^static int writeXrefEntry (const tagEntryInfo *const tag)$/;"	f	file:
xCalloc	.\routines.h	23;"	d
xMalloc	.\routines.h	22;"	d
xRealloc	.\routines.h	24;"	d
xref	.\options.h	/^	boolean xref;           \/* -x  generate xref output instead *\/$/;"	m	struct:sOptionValues
